"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated To be replaced with a SPI for performing work against the connection; scheduled for removal in 4.x
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the same identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If the given instance is unsaved or does not exist in the database, save it and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated use {@link org.hibernate.Session#merge(Object)}
 * @param object a transient instance with state to be copied
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(Object object) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the given identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If there is no database row with the given identifier, save the given instance and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated with no replacement
 * @param object a persistent or transient instance with state to be copied
 * @param id the identifier of the instance to copy to
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the same identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If the given instance is unsaved or does not exist in the database, save it and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated use {@link org.hibernate.Session#merge(String,Object)}
 * @param object a transient instance with state to be copied
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(String entityName,Object object) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the given identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If there is no database row with the given identifier, save the given instance and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated with no replacement
 * @param object a persistent or transient instance with state to be copied
 * @param id the identifier of the instance to copy to
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Execute a query.
 * @deprecated use {@link #createQuery}. {@link Query#list()}
 * @param query a query expressed in Hibernate's query language
 * @return a distinct list of instances (or arrays of instances)
 * @throws HibernateException
 */
public List find(String query) throws HibernateException ;
"
"/** 
 * Execute a query with bind parameters, binding a value to a ""?"" parameter in the query string.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#list()}
 * @param query the query string
 * @param value a value to be bound to a ""?"" placeholder (JDBC IN parameter).
 * @param type the Hibernate type of the value
 * @see org.hibernate.Hibernate for access to <tt>Type</tt> instances
 * @return a distinct list of instances (or arrays of instances)
 * @throws HibernateException
 */
public List find(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Execute a query with bind parameters, binding an array of values to ""?"" parameters in the query string.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#list()}
 * @param query the query string
 * @param values an array of values to be bound to the ""?"" placeholders (JDBC IN parameters).
 * @param types an array of Hibernate types of the values
 * @see org.hibernate.Hibernate for access to <tt>Type</tt> instances
 * @return a distinct list of instances
 * @throws HibernateException
 */
public List find(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. If the query has multiple return values, values will be returned in an array of type <tt>Object[].</tt><br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}. {@link Query#iterate}
 * @param query the query string
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. Write the given value to ""?"" in the query string. If the query has multiple return values, values will be returned in an array of type <tt>Object[]</tt>.<br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#iterate}
 * @param query the query string
 * @param value a value to be witten to a ""?"" placeholder in the query string
 * @param type the hibernate type of value
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. Write the given values to ""?"" in the query string. If the query has multiple return values, values will be returned in an array of type <tt>Object[]</tt>.<br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#iterate}
 * @param query the query string
 * @param values a list of values to be written to ""?"" placeholders in the query
 * @param types a list of Hibernate types of the values
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element. Filters allow efficient access to very large lazy collections. (Executing the filter does not initialize the collection.)
 * @deprecated use {@link #createFilter(Object,String)}. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @return Collection the resulting collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element.
 * @deprecated use {@link #createFilter(Object,String)}.setXYZ. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @param value a value to be witten to a ""?"" placeholder in the query string
 * @param type the hibernate type of value
 * @return Collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter,Object value,Type type) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. Bind the given parameters to ""?"" placeholders. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element.
 * @deprecated use {@link #createFilter(Object,String)}.setXYZ. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @param values a list of values to be written to ""?"" placeholders in the query
 * @param types a list of Hibernate types of the values
 * @return Collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @param value a value to be witten to a ""?"" placeholder in the query string.
 * @param type the hibernate type of value.
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @param values a list of values to be written to ""?"" placeholders in the query.
 * @param types a list of Hibernate types of the values
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Create a new instance of <tt>Query</tt> for the given SQL string.
 * @deprecated will be replaced with a more Query like interface in later release
 * @param sql a query expressed in SQL
 * @param returnAlias a table alias that appears inside <tt>{}</tt> in the SQL string
 * @param returnClass the returned persistent class
 */
public Query createSQLQuery(String sql,String returnAlias,Class returnClass);
"
"/** 
 * Create a new instance of <tt>Query</tt> for the given SQL string.
 * @deprecated will be replaced with a more Query like interface in later release
 * @param sql a query expressed in SQL
 * @param returnAliases an array of table aliases that appear inside <tt>{}</tt> in the SQL string
 * @param returnClasses the returned persistent classes
 */
public Query createSQLQuery(String sql,String[] returnAliases,Class[] returnClasses);
"
"/** 
 * Persist the given transient instance, using the given identifier.  This operation  cascades to associated instances if the association is mapped with  <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a transient instance of a persistent class
 * @param id an unused valid identifier
 * @throws HibernateException
 */
public void save(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Persist the given transient instance, using the given identifier. This operation  cascades to associated instances if the association is mapped with  <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a transient instance of a persistent class
 * @param id an unused valid identifier
 * @throws HibernateException
 */
public void save(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Update the persistent state associated with the given identifier. An exception is thrown if there is a persistent instance with the same identifier in the current session. This operation cascades to associated instances  if the association is mapped with <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a detached instance containing updated state
 * @param id identifier of persistent instance
 * @throws HibernateException
 */
public void update(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Update the persistent state associated with the given identifier. An exception is thrown if there is a persistent instance with the same identifier in the current session. This operation cascades to associated instances  if the association is mapped with <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a detached instance containing updated state
 * @param id identifier of persistent instance
 * @throws HibernateException
 */
public void update(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * This form used from annotations (?).  Essentially the same as the above using a resultset-mapping reference, but without cacheMode, readOnly, and comment. FIXME: annotations do not use it, so it can be remove from my POV
 * @deprecated
 * @param query The sql query string
 * @param resultSetRef The result-set-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 */
public NamedSQLQueryDefinition(String query,String resultSetRef,List querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,Map parameterTypes,boolean callable){
  this(query,resultSetRef,querySpaces,cacheable,cacheRegion,timeout,fetchSize,flushMode,null,false,null,parameterTypes,callable);
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(String name,String value){
  target().setAttributeValue(name,value);
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(QName qName,String value){
  target().setAttributeValue(qName,value);
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @deprecated properties may be specified via the Configuration object
 */
public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  format=PropertiesHelper.getBoolean(Environment.FORMAT_SQL,props);
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(String name,String value){
  element.setAttributeValue(name,value);
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(QName qName,String value){
  element.setAttributeValue(qName,value);
}
"
"/** 
 * The legacy contract.
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String,boolean)} instead
 */
public static CollectionType customCollection(String typeName,String role,String propertyRef,boolean embedded){
  return customCollection(typeName,null,role,propertyRef,embedded);
}
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated To be replaced with a SPI for performing work against the connection; scheduled for removal in 4.x
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the same identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If the given instance is unsaved or does not exist in the database, save it and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated use {@link org.hibernate.Session#merge(Object)}
 * @param object a transient instance with state to be copied
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(Object object) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the given identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If there is no database row with the given identifier, save the given instance and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated with no replacement
 * @param object a persistent or transient instance with state to be copied
 * @param id the identifier of the instance to copy to
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the same identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If the given instance is unsaved or does not exist in the database, save it and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated use {@link org.hibernate.Session#merge(String,Object)}
 * @param object a transient instance with state to be copied
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(String entityName,Object object) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the given identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If there is no database row with the given identifier, save the given instance and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated with no replacement
 * @param object a persistent or transient instance with state to be copied
 * @param id the identifier of the instance to copy to
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Execute a query.
 * @deprecated use {@link #createQuery}. {@link Query#list()}
 * @param query a query expressed in Hibernate's query language
 * @return a distinct list of instances (or arrays of instances)
 * @throws HibernateException
 */
public List find(String query) throws HibernateException ;
"
"/** 
 * Execute a query with bind parameters, binding a value to a ""?"" parameter in the query string.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#list()}
 * @param query the query string
 * @param value a value to be bound to a ""?"" placeholder (JDBC IN parameter).
 * @param type the Hibernate type of the value
 * @see org.hibernate.Hibernate for access to <tt>Type</tt> instances
 * @return a distinct list of instances (or arrays of instances)
 * @throws HibernateException
 */
public List find(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Execute a query with bind parameters, binding an array of values to ""?"" parameters in the query string.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#list()}
 * @param query the query string
 * @param values an array of values to be bound to the ""?"" placeholders (JDBC IN parameters).
 * @param types an array of Hibernate types of the values
 * @see org.hibernate.Hibernate for access to <tt>Type</tt> instances
 * @return a distinct list of instances
 * @throws HibernateException
 */
public List find(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. If the query has multiple return values, values will be returned in an array of type <tt>Object[].</tt><br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}. {@link Query#iterate}
 * @param query the query string
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. Write the given value to ""?"" in the query string. If the query has multiple return values, values will be returned in an array of type <tt>Object[]</tt>.<br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#iterate}
 * @param query the query string
 * @param value a value to be witten to a ""?"" placeholder in the query string
 * @param type the hibernate type of value
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. Write the given values to ""?"" in the query string. If the query has multiple return values, values will be returned in an array of type <tt>Object[]</tt>.<br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#iterate}
 * @param query the query string
 * @param values a list of values to be written to ""?"" placeholders in the query
 * @param types a list of Hibernate types of the values
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element. Filters allow efficient access to very large lazy collections. (Executing the filter does not initialize the collection.)
 * @deprecated use {@link #createFilter(Object,String)}. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @return Collection the resulting collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element.
 * @deprecated use {@link #createFilter(Object,String)}.setXYZ. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @param value a value to be witten to a ""?"" placeholder in the query string
 * @param type the hibernate type of value
 * @return Collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter,Object value,Type type) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. Bind the given parameters to ""?"" placeholders. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element.
 * @deprecated use {@link #createFilter(Object,String)}.setXYZ. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @param values a list of values to be written to ""?"" placeholders in the query
 * @param types a list of Hibernate types of the values
 * @return Collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @param value a value to be witten to a ""?"" placeholder in the query string.
 * @param type the hibernate type of value.
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @param values a list of values to be written to ""?"" placeholders in the query.
 * @param types a list of Hibernate types of the values
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Create a new instance of <tt>Query</tt> for the given SQL string.
 * @deprecated will be replaced with a more Query like interface in later release
 * @param sql a query expressed in SQL
 * @param returnAlias a table alias that appears inside <tt>{}</tt> in the SQL string
 * @param returnClass the returned persistent class
 */
public Query createSQLQuery(String sql,String returnAlias,Class returnClass);
"
"/** 
 * Create a new instance of <tt>Query</tt> for the given SQL string.
 * @deprecated will be replaced with a more Query like interface in later release
 * @param sql a query expressed in SQL
 * @param returnAliases an array of table aliases that appear inside <tt>{}</tt> in the SQL string
 * @param returnClasses the returned persistent classes
 */
public Query createSQLQuery(String sql,String[] returnAliases,Class[] returnClasses);
"
"/** 
 * Persist the given transient instance, using the given identifier.  This operation  cascades to associated instances if the association is mapped with  <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a transient instance of a persistent class
 * @param id an unused valid identifier
 * @throws HibernateException
 */
public void save(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Persist the given transient instance, using the given identifier. This operation  cascades to associated instances if the association is mapped with  <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a transient instance of a persistent class
 * @param id an unused valid identifier
 * @throws HibernateException
 */
public void save(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Update the persistent state associated with the given identifier. An exception is thrown if there is a persistent instance with the same identifier in the current session. This operation cascades to associated instances  if the association is mapped with <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a detached instance containing updated state
 * @param id identifier of persistent instance
 * @throws HibernateException
 */
public void update(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Update the persistent state associated with the given identifier. An exception is thrown if there is a persistent instance with the same identifier in the current session. This operation cascades to associated instances  if the association is mapped with <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a detached instance containing updated state
 * @param id identifier of persistent instance
 * @throws HibernateException
 */
public void update(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * This form used from annotations (?).  Essentially the same as the above using a resultset-mapping reference, but without cacheMode, readOnly, and comment. FIXME: annotations do not use it, so it can be remove from my POV
 * @deprecated
 * @param query The sql query string
 * @param resultSetRef The result-set-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 */
public NamedSQLQueryDefinition(String query,String resultSetRef,List querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,Map parameterTypes,boolean callable){
  this(query,resultSetRef,querySpaces,cacheable,cacheRegion,timeout,fetchSize,flushMode,null,false,null,parameterTypes,callable);
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(String name,String value){
  target().setAttributeValue(name,value);
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(QName qName,String value){
  target().setAttributeValue(qName,value);
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @deprecated properties may be specified via the Configuration object
 */
public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  format=PropertiesHelper.getBoolean(Environment.FORMAT_SQL,props);
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(String name,String value){
  element.setAttributeValue(name,value);
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(QName qName,String value){
  element.setAttributeValue(qName,value);
}
"
"/** 
 * The legacy contract.
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String,boolean)} instead
 */
public static CollectionType customCollection(String typeName,String role,String propertyRef,boolean embedded){
  return customCollection(typeName,null,role,propertyRef,embedded);
}
"
"/** 
 * Apply a constraint expressed in SQL, with the given JDBC parameters. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String,Object[],Type[])}
 * @param sql
 * @param values
 * @param types
 * @return Criterion
 */
public static Criterion sql(String sql,Object[] values,Type[] types){
  return new SQLCriterion(sql,values,types);
}
"
"/** 
 * Apply a constraint expressed in SQL, with the given JDBC parameter. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String,Object,Type)}
 * @param sql
 * @param value
 * @param type
 * @return Criterion
 */
public static Criterion sql(String sql,Object value,Type type){
  return new SQLCriterion(sql,new Object[]{value},new Type[]{type});
}
"
"/** 
 * Apply a constraint expressed in SQL. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String)}
 * @param sql
 * @return Criterion
 */
public static Criterion sql(String sql){
  return new SQLCriterion(sql,ArrayHelper.EMPTY_OBJECT_ARRAY,ArrayHelper.EMPTY_TYPE_ARRAY);
}
"
"/** 
 * Apply a constraint expressed in SQL, with the given JDBC parameters. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String,Object[],Type[])}
 * @param sql
 * @param values
 * @param types
 * @return Criterion
 */
public static Criterion sql(String sql,Object[] values,Type[] types){
  return new SQLCriterion(sql,values,types);
}
"
"/** 
 * Apply a constraint expressed in SQL, with the given JDBC parameter. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String,Object,Type)}
 * @param sql
 * @param value
 * @param type
 * @return Criterion
 */
public static Criterion sql(String sql,Object value,Type type){
  return new SQLCriterion(sql,new Object[]{value},new Type[]{type});
}
"
"/** 
 * Apply a constraint expressed in SQL. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String)}
 * @param sql
 * @return Criterion
 */
public static Criterion sql(String sql){
  return new SQLCriterion(sql,ArrayHelper.EMPTY_OBJECT_ARRAY,ArrayHelper.EMPTY_TYPE_ARRAY);
}
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated To be replaced with a SPI for performing work against the connection; scheduled for removal in 4.x
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the same identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If the given instance is unsaved or does not exist in the database, save it and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated use {@link org.hibernate.Session#merge(Object)}
 * @param object a transient instance with state to be copied
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(Object object) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the given identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If there is no database row with the given identifier, save the given instance and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated with no replacement
 * @param object a persistent or transient instance with state to be copied
 * @param id the identifier of the instance to copy to
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the same identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If the given instance is unsaved or does not exist in the database, save it and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated use {@link org.hibernate.Session#merge(String,Object)}
 * @param object a transient instance with state to be copied
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(String entityName,Object object) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the given identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If there is no database row with the given identifier, save the given instance and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated with no replacement
 * @param object a persistent or transient instance with state to be copied
 * @param id the identifier of the instance to copy to
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Execute a query.
 * @deprecated use {@link #createQuery}. {@link Query#list()}
 * @param query a query expressed in Hibernate's query language
 * @return a distinct list of instances (or arrays of instances)
 * @throws HibernateException
 */
public List find(String query) throws HibernateException ;
"
"/** 
 * Execute a query with bind parameters, binding a value to a ""?"" parameter in the query string.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#list()}
 * @param query the query string
 * @param value a value to be bound to a ""?"" placeholder (JDBC IN parameter).
 * @param type the Hibernate type of the value
 * @see org.hibernate.Hibernate for access to <tt>Type</tt> instances
 * @return a distinct list of instances (or arrays of instances)
 * @throws HibernateException
 */
public List find(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Execute a query with bind parameters, binding an array of values to ""?"" parameters in the query string.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#list()}
 * @param query the query string
 * @param values an array of values to be bound to the ""?"" placeholders (JDBC IN parameters).
 * @param types an array of Hibernate types of the values
 * @see org.hibernate.Hibernate for access to <tt>Type</tt> instances
 * @return a distinct list of instances
 * @throws HibernateException
 */
public List find(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. If the query has multiple return values, values will be returned in an array of type <tt>Object[].</tt><br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}. {@link Query#iterate}
 * @param query the query string
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. Write the given value to ""?"" in the query string. If the query has multiple return values, values will be returned in an array of type <tt>Object[]</tt>.<br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#iterate}
 * @param query the query string
 * @param value a value to be witten to a ""?"" placeholder in the query string
 * @param type the hibernate type of value
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. Write the given values to ""?"" in the query string. If the query has multiple return values, values will be returned in an array of type <tt>Object[]</tt>.<br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#iterate}
 * @param query the query string
 * @param values a list of values to be written to ""?"" placeholders in the query
 * @param types a list of Hibernate types of the values
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element. Filters allow efficient access to very large lazy collections. (Executing the filter does not initialize the collection.)
 * @deprecated use {@link #createFilter(Object,String)}. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @return Collection the resulting collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element.
 * @deprecated use {@link #createFilter(Object,String)}.setXYZ. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @param value a value to be witten to a ""?"" placeholder in the query string
 * @param type the hibernate type of value
 * @return Collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter,Object value,Type type) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. Bind the given parameters to ""?"" placeholders. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element.
 * @deprecated use {@link #createFilter(Object,String)}.setXYZ. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @param values a list of values to be written to ""?"" placeholders in the query
 * @param types a list of Hibernate types of the values
 * @return Collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @param value a value to be witten to a ""?"" placeholder in the query string.
 * @param type the hibernate type of value.
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @param values a list of values to be written to ""?"" placeholders in the query.
 * @param types a list of Hibernate types of the values
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Create a new instance of <tt>Query</tt> for the given SQL string.
 * @deprecated will be replaced with a more Query like interface in later release
 * @param sql a query expressed in SQL
 * @param returnAlias a table alias that appears inside <tt>{}</tt> in the SQL string
 * @param returnClass the returned persistent class
 */
public Query createSQLQuery(String sql,String returnAlias,Class returnClass);
"
"/** 
 * Create a new instance of <tt>Query</tt> for the given SQL string.
 * @deprecated will be replaced with a more Query like interface in later release
 * @param sql a query expressed in SQL
 * @param returnAliases an array of table aliases that appear inside <tt>{}</tt> in the SQL string
 * @param returnClasses the returned persistent classes
 */
public Query createSQLQuery(String sql,String[] returnAliases,Class[] returnClasses);
"
"/** 
 * Persist the given transient instance, using the given identifier.  This operation  cascades to associated instances if the association is mapped with  <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a transient instance of a persistent class
 * @param id an unused valid identifier
 * @throws HibernateException
 */
public void save(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Persist the given transient instance, using the given identifier. This operation  cascades to associated instances if the association is mapped with  <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a transient instance of a persistent class
 * @param id an unused valid identifier
 * @throws HibernateException
 */
public void save(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Update the persistent state associated with the given identifier. An exception is thrown if there is a persistent instance with the same identifier in the current session. This operation cascades to associated instances  if the association is mapped with <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a detached instance containing updated state
 * @param id identifier of persistent instance
 * @throws HibernateException
 */
public void update(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Update the persistent state associated with the given identifier. An exception is thrown if there is a persistent instance with the same identifier in the current session. This operation cascades to associated instances  if the association is mapped with <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a detached instance containing updated state
 * @param id identifier of persistent instance
 * @throws HibernateException
 */
public void update(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Apply a constraint expressed in SQL, with the given JDBC parameters. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String,Object[],Type[])}
 * @param sql
 * @param values
 * @param types
 * @return Criterion
 */
public static Criterion sql(String sql,Object[] values,Type[] types){
  return new SQLCriterion(sql,values,types);
}
"
"/** 
 * Apply a constraint expressed in SQL, with the given JDBC parameter. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String,Object,Type)}
 * @param sql
 * @param value
 * @param type
 * @return Criterion
 */
public static Criterion sql(String sql,Object value,Type type){
  return new SQLCriterion(sql,new Object[]{value},new Type[]{type});
}
"
"/** 
 * Apply a constraint expressed in SQL. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String)}
 * @param sql
 * @return Criterion
 */
public static Criterion sql(String sql){
  return new SQLCriterion(sql,ArrayHelper.EMPTY_OBJECT_ARRAY,ArrayHelper.EMPTY_TYPE_ARRAY);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * This form used from annotations (?).  Essentially the same as the above using a resultset-mapping reference, but without cacheMode, readOnly, and comment. FIXME: annotations do not use it, so it can be remove from my POV
 * @deprecated
 * @param query The sql query string
 * @param resultSetRef The result-set-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 */
public NamedSQLQueryDefinition(String query,String resultSetRef,List querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,Map parameterTypes,boolean callable){
  this(query,resultSetRef,querySpaces,cacheable,cacheRegion,timeout,fetchSize,flushMode,null,false,null,parameterTypes,callable);
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(String name,String value){
  target().setAttributeValue(name,value);
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(QName qName,String value){
  target().setAttributeValue(qName,value);
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @deprecated properties may be specified via the Configuration object
 */
public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  format=PropertiesHelper.getBoolean(Environment.FORMAT_SQL,props);
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(String name,String value){
  element.setAttributeValue(name,value);
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(QName qName,String value){
  element.setAttributeValue(qName,value);
}
"
"/** 
 * The legacy contract.
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String,boolean)} instead
 */
public static CollectionType customCollection(String typeName,String role,String propertyRef,boolean embedded){
  return customCollection(typeName,null,role,propertyRef,embedded);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @deprecated properties may be specified via the Configuration object
 */
public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  format=PropertiesHelper.getBoolean(Environment.FORMAT_SQL,props);
}
"
"/** 
 * The legacy contract.
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String,boolean)} instead
 */
public static CollectionType customCollection(String typeName,String role,String propertyRef,boolean embedded){
  return customCollection(typeName,null,role,propertyRef,embedded);
}
"
"/** 
 * The legacy contract.
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String,boolean)} instead
 */
public static CollectionType customCollection(String typeName,String role,String propertyRef,boolean embedded){
  return customCollection(typeName,null,role,propertyRef,embedded);
}
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param cfg The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  formatter=(PropertiesHelper.getBoolean(Environment.FORMAT_SQL,props) ? FormatStyle.DDL : FormatStyle.NONE).getFormatter();
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Instantiate AliasToEntityMapResultTransformer.
 * @deprecated Use the {@link #INSTANCE} reference instead of explicitly creating a new one.
 */
public AliasToEntityMapResultTransformer(){
}
"
"/** 
 * Instantiate a DistinctRootEntityResultTransformer.
 * @deprecated Use the {@link #INSTANCE} reference instead of explicitly creating a new one.
 */
public DistinctRootEntityResultTransformer(){
}
"
"/** 
 * Instamtiate a PassThroughResultTransformer.
 * @deprecated Use the {@link #INSTANCE} reference instead of explicitly creating a new one.
 */
public PassThroughResultTransformer(){
}
"
"/** 
 * Instantiate RootEntityResultTransformer.
 * @deprecated Use the {@link #INSTANCE} reference instead of explicitly creating a new one.
 */
public RootEntityResultTransformer(){
}
"
"/** 
 * Instantiate AliasToEntityMapResultTransformer.
 * @deprecated Use the {@link #INSTANCE} reference instead of explicitly creating a new one.
 */
public AliasToEntityMapResultTransformer(){
}
"
"/** 
 * Instantiate a DistinctRootEntityResultTransformer.
 * @deprecated Use the {@link #INSTANCE} reference instead of explicitly creating a new one.
 */
public DistinctRootEntityResultTransformer(){
}
"
"/** 
 * Instamtiate a PassThroughResultTransformer.
 * @deprecated Use the {@link #INSTANCE} reference instead of explicitly creating a new one.
 */
public PassThroughResultTransformer(){
}
"
"/** 
 * Instantiate RootEntityResultTransformer.
 * @deprecated Use the {@link #INSTANCE} reference instead of explicitly creating a new one.
 */
public RootEntityResultTransformer(){
}
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the same identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If the given instance is unsaved or does not exist in the database, save it and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated use {@link org.hibernate.Session#merge(Object)}
 * @param object a transient instance with state to be copied
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(Object object) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the given identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If there is no database row with the given identifier, save the given instance and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated with no replacement
 * @param object a persistent or transient instance with state to be copied
 * @param id the identifier of the instance to copy to
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the same identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If the given instance is unsaved or does not exist in the database, save it and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated use {@link org.hibernate.Session#merge(String,Object)}
 * @param object a transient instance with state to be copied
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(String entityName,Object object) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the given identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If there is no database row with the given identifier, save the given instance and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated with no replacement
 * @param object a persistent or transient instance with state to be copied
 * @param id the identifier of the instance to copy to
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Execute a query.
 * @deprecated use {@link #createQuery}. {@link Query#list()}
 * @param query a query expressed in Hibernate's query language
 * @return a distinct list of instances (or arrays of instances)
 * @throws HibernateException
 */
public List find(String query) throws HibernateException ;
"
"/** 
 * Execute a query with bind parameters, binding a value to a ""?"" parameter in the query string.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#list()}
 * @param query the query string
 * @param value a value to be bound to a ""?"" placeholder (JDBC IN parameter).
 * @param type the Hibernate type of the value
 * @see org.hibernate.Hibernate for access to <tt>Type</tt> instances
 * @return a distinct list of instances (or arrays of instances)
 * @throws HibernateException
 */
public List find(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Execute a query with bind parameters, binding an array of values to ""?"" parameters in the query string.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#list()}
 * @param query the query string
 * @param values an array of values to be bound to the ""?"" placeholders (JDBC IN parameters).
 * @param types an array of Hibernate types of the values
 * @see org.hibernate.Hibernate for access to <tt>Type</tt> instances
 * @return a distinct list of instances
 * @throws HibernateException
 */
public List find(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. If the query has multiple return values, values will be returned in an array of type <tt>Object[].</tt><br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}. {@link Query#iterate}
 * @param query the query string
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. Write the given value to ""?"" in the query string. If the query has multiple return values, values will be returned in an array of type <tt>Object[]</tt>.<br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#iterate}
 * @param query the query string
 * @param value a value to be witten to a ""?"" placeholder in the query string
 * @param type the hibernate type of value
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. Write the given values to ""?"" in the query string. If the query has multiple return values, values will be returned in an array of type <tt>Object[]</tt>.<br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#iterate}
 * @param query the query string
 * @param values a list of values to be written to ""?"" placeholders in the query
 * @param types a list of Hibernate types of the values
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element. Filters allow efficient access to very large lazy collections. (Executing the filter does not initialize the collection.)
 * @deprecated use {@link #createFilter(Object,String)}. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @return Collection the resulting collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element.
 * @deprecated use {@link #createFilter(Object,String)}.setXYZ. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @param value a value to be witten to a ""?"" placeholder in the query string
 * @param type the hibernate type of value
 * @return Collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter,Object value,Type type) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. Bind the given parameters to ""?"" placeholders. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element.
 * @deprecated use {@link #createFilter(Object,String)}.setXYZ. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @param values a list of values to be written to ""?"" placeholders in the query
 * @param types a list of Hibernate types of the values
 * @return Collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @param value a value to be witten to a ""?"" placeholder in the query string.
 * @param type the hibernate type of value.
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @param values a list of values to be written to ""?"" placeholders in the query.
 * @param types a list of Hibernate types of the values
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Create a new instance of <tt>Query</tt> for the given SQL string.
 * @deprecated will be replaced with a more Query like interface in later release
 * @param sql a query expressed in SQL
 * @param returnAlias a table alias that appears inside <tt>{}</tt> in the SQL string
 * @param returnClass the returned persistent class
 */
public Query createSQLQuery(String sql,String returnAlias,Class returnClass);
"
"/** 
 * Create a new instance of <tt>Query</tt> for the given SQL string.
 * @deprecated will be replaced with a more Query like interface in later release
 * @param sql a query expressed in SQL
 * @param returnAliases an array of table aliases that appear inside <tt>{}</tt> in the SQL string
 * @param returnClasses the returned persistent classes
 */
public Query createSQLQuery(String sql,String[] returnAliases,Class[] returnClasses);
"
"/** 
 * Persist the given transient instance, using the given identifier.  This operation  cascades to associated instances if the association is mapped with  <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a transient instance of a persistent class
 * @param id an unused valid identifier
 * @throws HibernateException
 */
public void save(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Persist the given transient instance, using the given identifier. This operation  cascades to associated instances if the association is mapped with  <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a transient instance of a persistent class
 * @param id an unused valid identifier
 * @throws HibernateException
 */
public void save(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Update the persistent state associated with the given identifier. An exception is thrown if there is a persistent instance with the same identifier in the current session. This operation cascades to associated instances  if the association is mapped with <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a detached instance containing updated state
 * @param id identifier of persistent instance
 * @throws HibernateException
 */
public void update(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Update the persistent state associated with the given identifier. An exception is thrown if there is a persistent instance with the same identifier in the current session. This operation cascades to associated instances  if the association is mapped with <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a detached instance containing updated state
 * @param id identifier of persistent instance
 * @throws HibernateException
 */
public void update(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Apply a constraint expressed in SQL, with the given JDBC parameters. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String,Object[],Type[])}
 * @param sql
 * @param values
 * @param types
 * @return Criterion
 */
public static Criterion sql(String sql,Object[] values,Type[] types){
  return new SQLCriterion(sql,values,types);
}
"
"/** 
 * Apply a constraint expressed in SQL, with the given JDBC parameter. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String,Object,Type)}
 * @param sql
 * @param value
 * @param type
 * @return Criterion
 */
public static Criterion sql(String sql,Object value,Type type){
  return new SQLCriterion(sql,new Object[]{value},new Type[]{type});
}
"
"/** 
 * Apply a constraint expressed in SQL. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String)}
 * @param sql
 * @return Criterion
 */
public static Criterion sql(String sql){
  return new SQLCriterion(sql,ArrayHelper.EMPTY_OBJECT_ARRAY,ArrayHelper.EMPTY_TYPE_ARRAY);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * This form used from annotations (?).  Essentially the same as the above using a resultset-mapping reference, but without cacheMode, readOnly, and comment. FIXME: annotations do not use it, so it can be remove from my POV
 * @deprecated
 * @param query The sql query string
 * @param resultSetRef The result-set-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 */
public NamedSQLQueryDefinition(String query,String resultSetRef,List querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,Map parameterTypes,boolean callable){
  this(query,resultSetRef,querySpaces,cacheable,cacheRegion,timeout,fetchSize,flushMode,null,false,null,parameterTypes,callable);
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(String name,String value){
  target().setAttributeValue(name,value);
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(QName qName,String value){
  target().setAttributeValue(qName,value);
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param cfg The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  formatter=(PropertiesHelper.getBoolean(Environment.FORMAT_SQL,props) ? FormatStyle.DDL : FormatStyle.NONE).getFormatter();
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(String name,String value){
  element.setAttributeValue(name,value);
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(QName qName,String value){
  element.setAttributeValue(qName,value);
}
"
"/** 
 * The legacy contract.
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String,boolean)} instead
 */
public static CollectionType customCollection(String typeName,String role,String propertyRef,boolean embedded){
  return customCollection(typeName,null,role,propertyRef,embedded);
}
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.impl.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
public void setFetchProfile(String name);
"
"/** 
 * Getter for property 'source'.  This is the session from which the event originated. <p/> Some of the pre-* events had previous exposed the event source using getSource() because they had not originally extended from {@link AbstractEvent}.
 * @return Value for property 'source'.
 * @deprecated Use {@link #getSession} instead
 */
public EventSource getSource(){
  return getSession();
}
"
"/** 
 * Getter for property 'source'.  This is the session from which the event originated. <p/> Some of the pre-* events had previous exposed the event source using getSource() because they had not originally extended from {@link AbstractEvent}.
 * @return Value for property 'source'.
 * @deprecated Use {@link #getSession} instead
 */
public EventSource getSource(){
  return getSession();
}
"
"/** 
 * Instantiate AliasToEntityMapResultTransformer. <p/> todo : make private, see deprecation...
 * @deprecated Use the {@link #INSTANCE} reference instead of explicitly creating a new one (to be removed in 3.4).
 */
public AliasToEntityMapResultTransformer(){
}
"
"/** 
 * Instantiate a DistinctRootEntityResultTransformer. <p/> todo : make private, see deprecation notice
 * @deprecated Use the {@link #INSTANCE} reference instead of explicitly creating a new one (to be removed in 3.4).
 */
public DistinctRootEntityResultTransformer(){
}
"
"/** 
 * Instamtiate a PassThroughResultTransformer.
 * @deprecated Use the {@link #INSTANCE} reference instead of explicitly creating a new one (to be removed in 3.4).
 */
public PassThroughResultTransformer(){
}
"
"/** 
 * Instantiate RootEntityResultTransformer.
 * @deprecated Use the {@link #INSTANCE} reference instead of explicitly creating a new one (to be removed in 3.4).
 */
public RootEntityResultTransformer(){
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * Allow access to the id generator factory, though this is only needed/allowed from configuration.
 * @return
 * @deprecated temporary solution 
 */
public IdentifierGeneratorFactory getIdentifierGeneratorFactory();
"
"/** 
 * Allow injection of the dialect to use.
 * @param dialect The dialect
 * @deprecated The intention is that Dialect should be required to be specified up-front and it would then getctor injected.
 */
public void setDialect(Dialect dialect);
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * Allow injection of the dialect to use.
 * @param dialect The dialect
 * @deprecated The intention is that Dialect should be required to be specified up-front and it would then getctor injected.
 */
public void setDialect(Dialect dialect);
"
"/** 
 * @deprecated as of release 3.4.0.CR2, replaced by Hibernate Search's {@link org.hibernate.search.cfg.EventListenerRegister#enableHibernateSearch(EventListeners,Properties)}
 */
@SuppressWarnings(""unchecked"") @Deprecated public static void enableHibernateSearch(EventListeners eventListeners,Properties properties){
  String enableSearchListeners=properties.getProperty(""hibernate.search.autoregister_listeners"");
  if (""false"".equalsIgnoreCase(enableSearchListeners)) {
    log.info(""Property hibernate.search.autoregister_listeners is set to false."" + "" No attempt will be made to register Hibernate Search event listeners."");
    return;
  }
  Class searchEventListenerClass=attemptToLoadSearchEventListener();
  if (searchEventListenerClass == null) {
    log.info(""Unable to find {} on the classpath. Hibernate Search is not enabled."",FULL_TEXT_INDEX_EVENT_LISTENER_CLASS);
    return;
  }
  Object searchEventListener=instantiateEventListener(searchEventListenerClass);
{
    boolean present=false;
    PostInsertEventListener[] listeners=eventListeners.getPostInsertEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostInsertEventListener[] newListeners=new PostInsertEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostInsertEventListener)searchEventListener;
        eventListeners.setPostInsertEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostInsertEventListeners(new PostInsertEventListener[]{(PostInsertEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostUpdateEventListener[] listeners=eventListeners.getPostUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostUpdateEventListener[] newListeners=new PostUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostUpdateEventListener)searchEventListener;
        eventListeners.setPostUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostUpdateEventListeners(new PostUpdateEventListener[]{(PostUpdateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostDeleteEventListener[] listeners=eventListeners.getPostDeleteEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostDeleteEventListener[] newListeners=new PostDeleteEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostDeleteEventListener)searchEventListener;
        eventListeners.setPostDeleteEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostDeleteEventListeners(new PostDeleteEventListener[]{(PostDeleteEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRecreateEventListener[] listeners=eventListeners.getPostCollectionRecreateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRecreateEventListener[] newListeners=new PostCollectionRecreateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRecreateEventListener)searchEventListener;
        eventListeners.setPostCollectionRecreateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRecreateEventListeners(new PostCollectionRecreateEventListener[]{(PostCollectionRecreateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRemoveEventListener[] listeners=eventListeners.getPostCollectionRemoveEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRemoveEventListener[] newListeners=new PostCollectionRemoveEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRemoveEventListener)searchEventListener;
        eventListeners.setPostCollectionRemoveEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRemoveEventListeners(new PostCollectionRemoveEventListener[]{(PostCollectionRemoveEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionUpdateEventListener[] listeners=eventListeners.getPostCollectionUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionUpdateEventListener[] newListeners=new PostCollectionUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionUpdateEventListener)searchEventListener;
        eventListeners.setPostCollectionUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionUpdateEventListeners(new PostCollectionUpdateEventListener[]{(PostCollectionUpdateEventListener)searchEventListener});
    }
  }
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * @deprecated as of release 3.4.0.CR2, replaced by Hibernate Search's {@link org.hibernate.search.cfg.EventListenerRegister#enableHibernateSearch(EventListeners,Properties)}
 */
@SuppressWarnings(""unchecked"") @Deprecated public static void enableHibernateSearch(EventListeners eventListeners,Properties properties){
  String enableSearchListeners=properties.getProperty(""hibernate.search.autoregister_listeners"");
  if (""false"".equalsIgnoreCase(enableSearchListeners)) {
    log.info(""Property hibernate.search.autoregister_listeners is set to false."" + "" No attempt will be made to register Hibernate Search event listeners."");
    return;
  }
  Class searchEventListenerClass=attemptToLoadSearchEventListener();
  if (searchEventListenerClass == null) {
    log.info(""Unable to find {} on the classpath. Hibernate Search is not enabled."",FULL_TEXT_INDEX_EVENT_LISTENER_CLASS);
    return;
  }
  Object searchEventListener=instantiateEventListener(searchEventListenerClass);
{
    boolean present=false;
    PostInsertEventListener[] listeners=eventListeners.getPostInsertEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostInsertEventListener[] newListeners=new PostInsertEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostInsertEventListener)searchEventListener;
        eventListeners.setPostInsertEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostInsertEventListeners(new PostInsertEventListener[]{(PostInsertEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostUpdateEventListener[] listeners=eventListeners.getPostUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostUpdateEventListener[] newListeners=new PostUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostUpdateEventListener)searchEventListener;
        eventListeners.setPostUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostUpdateEventListeners(new PostUpdateEventListener[]{(PostUpdateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostDeleteEventListener[] listeners=eventListeners.getPostDeleteEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostDeleteEventListener[] newListeners=new PostDeleteEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostDeleteEventListener)searchEventListener;
        eventListeners.setPostDeleteEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostDeleteEventListeners(new PostDeleteEventListener[]{(PostDeleteEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRecreateEventListener[] listeners=eventListeners.getPostCollectionRecreateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRecreateEventListener[] newListeners=new PostCollectionRecreateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRecreateEventListener)searchEventListener;
        eventListeners.setPostCollectionRecreateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRecreateEventListeners(new PostCollectionRecreateEventListener[]{(PostCollectionRecreateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRemoveEventListener[] listeners=eventListeners.getPostCollectionRemoveEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRemoveEventListener[] newListeners=new PostCollectionRemoveEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRemoveEventListener)searchEventListener;
        eventListeners.setPostCollectionRemoveEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRemoveEventListeners(new PostCollectionRemoveEventListener[]{(PostCollectionRemoveEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionUpdateEventListener[] listeners=eventListeners.getPostCollectionUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionUpdateEventListener[] newListeners=new PostCollectionUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionUpdateEventListener)searchEventListener;
        eventListeners.setPostCollectionUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionUpdateEventListeners(new PostCollectionUpdateEventListener[]{(PostCollectionUpdateEventListener)searchEventListener});
    }
  }
}
"
"/** 
 * @deprecated
 */
public Properties getExtraProperties(){
  return new Properties();
}
"
"/** 
 * @deprecated use getHbmfiles() rather
 */
public void setHbmfiles(List<NamedInputStream> hbmfiles){
  this.hbmfiles=hbmfiles;
}
"
"/** 
 * Creates a single node AST. <p/> TODO : this is silly, remove it...
 * @param astFactory The factory.
 * @param type The node type.
 * @param text The node text.
 * @return AST - A single node tree.
 * @deprecated silly
 */
public static AST create(ASTFactory astFactory,int type,String text){
  return astFactory.create(type,text);
}
"
"/** 
 * Get the name of a constant defined on the given class which has the given value. <p/> Note, if multiple constants have this value, the first will be returned which is known to be different on different JVM implementations.
 * @param owner The class which defines the constant
 * @param value The value of the constant.
 * @return The token type name, *or* the integer value if the name could not be found.
 * @deprecated Use #getTokenTypeName instead
 */
public static String getConstantName(Class owner,int value){
  return getTokenTypeName(owner,value);
}
"
"/** 
 * Creates a single node AST. <p/> TODO : this is silly, remove it...
 * @param astFactory The factory.
 * @param type The node type.
 * @param text The node text.
 * @return AST - A single node tree.
 * @deprecated silly
 */
public static AST create(ASTFactory astFactory,int type,String text){
  return astFactory.create(type,text);
}
"
"/** 
 * Get the name of a constant defined on the given class which has the given value. <p/> Note, if multiple constants have this value, the first will be returned which is known to be different on different JVM implementations.
 * @param owner The class which defines the constant
 * @param value The value of the constant.
 * @return The token type name, *or* the integer value if the name could not be found.
 * @deprecated Use #getTokenTypeName instead
 */
public static String getConstantName(Class owner,int value){
  return getTokenTypeName(owner,value);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(HibernatePersistence.CLASS_NAMES);
    props.remove(HibernatePersistence.PACKAGE_NAMES);
    props.remove(HibernatePersistence.HBXML_FILES);
    props.remove(HibernatePersistence.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * @deprecated
 */
public Properties getExtraProperties(){
  return new Properties();
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(HibernatePersistence.CLASS_NAMES);
    props.remove(HibernatePersistence.PACKAGE_NAMES);
    props.remove(HibernatePersistence.HBXML_FILES);
    props.remove(HibernatePersistence.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * @deprecated use getHbmfiles() rather
 */
public void setHbmfiles(List<NamedInputStream> hbmfiles){
  this.hbmfiles=hbmfiles;
}
"
"/** 
 * @deprecated
 */
public Properties getExtraProperties(){
  return new Properties();
}
"
"/** 
 * The legacy contract.
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String,boolean)} instead
 */
public static CollectionType customCollection(String typeName,String role,String propertyRef,boolean embedded){
  return customCollection(typeName,null,role,propertyRef,embedded);
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(HibernatePersistence.CLASS_NAMES);
    props.remove(HibernatePersistence.PACKAGE_NAMES);
    props.remove(HibernatePersistence.HBXML_FILES);
    props.remove(HibernatePersistence.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * @deprecated use getHbmfiles() rather
 */
public void setHbmfiles(List<NamedInputStream> hbmfiles){
  this.hbmfiles=hbmfiles;
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * @deprecated as of release 3.4.0.CR2, replaced by Hibernate Search's {@link org.hibernate.search.cfg.EventListenerRegister#enableHibernateSearch(EventListeners,Properties)}
 */
@SuppressWarnings(""unchecked"") @Deprecated public static void enableHibernateSearch(EventListeners eventListeners,Properties properties){
  String enableSearchListeners=properties.getProperty(""hibernate.search.autoregister_listeners"");
  if (""false"".equalsIgnoreCase(enableSearchListeners)) {
    log.info(""Property hibernate.search.autoregister_listeners is set to false."" + "" No attempt will be made to register Hibernate Search event listeners."");
    return;
  }
  Class searchEventListenerClass=attemptToLoadSearchEventListener();
  if (searchEventListenerClass == null) {
    log.info(""Unable to find {} on the classpath. Hibernate Search is not enabled."",FULL_TEXT_INDEX_EVENT_LISTENER_CLASS);
    return;
  }
  Object searchEventListener=instantiateEventListener(searchEventListenerClass);
{
    boolean present=false;
    PostInsertEventListener[] listeners=eventListeners.getPostInsertEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostInsertEventListener[] newListeners=new PostInsertEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostInsertEventListener)searchEventListener;
        eventListeners.setPostInsertEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostInsertEventListeners(new PostInsertEventListener[]{(PostInsertEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostUpdateEventListener[] listeners=eventListeners.getPostUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostUpdateEventListener[] newListeners=new PostUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostUpdateEventListener)searchEventListener;
        eventListeners.setPostUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostUpdateEventListeners(new PostUpdateEventListener[]{(PostUpdateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostDeleteEventListener[] listeners=eventListeners.getPostDeleteEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostDeleteEventListener[] newListeners=new PostDeleteEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostDeleteEventListener)searchEventListener;
        eventListeners.setPostDeleteEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostDeleteEventListeners(new PostDeleteEventListener[]{(PostDeleteEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRecreateEventListener[] listeners=eventListeners.getPostCollectionRecreateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRecreateEventListener[] newListeners=new PostCollectionRecreateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRecreateEventListener)searchEventListener;
        eventListeners.setPostCollectionRecreateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRecreateEventListeners(new PostCollectionRecreateEventListener[]{(PostCollectionRecreateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRemoveEventListener[] listeners=eventListeners.getPostCollectionRemoveEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRemoveEventListener[] newListeners=new PostCollectionRemoveEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRemoveEventListener)searchEventListener;
        eventListeners.setPostCollectionRemoveEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRemoveEventListeners(new PostCollectionRemoveEventListener[]{(PostCollectionRemoveEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionUpdateEventListener[] listeners=eventListeners.getPostCollectionUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionUpdateEventListener[] newListeners=new PostCollectionUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionUpdateEventListener)searchEventListener;
        eventListeners.setPostCollectionUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionUpdateEventListeners(new PostCollectionUpdateEventListener[]{(PostCollectionUpdateEventListener)searchEventListener});
    }
  }
}
"
"/** 
 * Not a direct copy from  {@link org.hibernate.util.StringHelper}, this is instead directly copied from  {@link org.hibernate.util.ArrayHelper}.
 * @param coll the collection
 * @return The int array
 * @deprecated Use {@link org.hibernate.util.ArrayHelper#toIntArray} instead.
 */
public static int[] toIntArray(Collection coll){
  return org.hibernate.util.ArrayHelper.toIntArray(coll);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
public void evictQueries() throws HibernateException ;
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(HibernatePersistence.CLASS_NAMES);
    props.remove(HibernatePersistence.PACKAGE_NAMES);
    props.remove(HibernatePersistence.HBXML_FILES);
    props.remove(HibernatePersistence.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(HibernatePersistence.CLASS_NAMES);
    props.remove(HibernatePersistence.PACKAGE_NAMES);
    props.remove(HibernatePersistence.HBXML_FILES);
    props.remove(HibernatePersistence.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * @deprecated use getHbmfiles() rather
 */
public void setHbmfiles(List<NamedInputStream> hbmfiles){
  this.hbmfiles=hbmfiles;
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * Creates a single node AST. <p/> TODO : this is silly, remove it...
 * @param astFactory The factory.
 * @param type The node type.
 * @param text The node text.
 * @return AST - A single node tree.
 * @deprecated silly
 */
public static AST create(ASTFactory astFactory,int type,String text){
  return astFactory.create(type,text);
}
"
"/** 
 * Get the name of a constant defined on the given class which has the given value. <p/> Note, if multiple constants have this value, the first will be returned which is known to be different on different JVM implementations.
 * @param owner The class which defines the constant
 * @param value The value of the constant.
 * @return The token type name, *or* the integer value if the name could not be found.
 * @deprecated Use #getTokenTypeName instead
 */
public static String getConstantName(Class owner,int value){
  return getTokenTypeName(owner,value);
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
public void evictQueries() throws HibernateException ;
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param bytes a byte array
 * @return the Blob
 * @deprecated Use {@link #createBlob(byte[],Session)} instead
 */
public static Blob createBlob(byte[] bytes){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(bytes));
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @return the Blob
 * @deprecated Use {@link #createBlob(InputStream,long,Session)} instead
 */
public static Blob createBlob(InputStream stream,int length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(stream,length));
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @return the Blob
 * @deprecated Use {@link #createBlob(InputStream,long,Session)} instead
 */
public static Blob createBlob(InputStream stream,long length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(stream,length));
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable. <p/> NOTE: this method will read the entire contents of the incoming stream in order to properly handle the  {@link Blob#length()} method.  If you do not want the stream read, use the{@link #createBlob(InputStream,long)} version instead.
 * @param stream a binary stream
 * @return the Blob
 * @throws IOException Indicates an I/O problem accessing the stream
 * @deprecated Use {@link #createBlob(InputStream,long,Session)} instead
 */
public static Blob createBlob(InputStream stream) throws IOException {
  ByteArrayOutputStream buffer=new ByteArrayOutputStream(stream.available());
  StreamUtils.copy(stream,buffer);
  return createBlob(buffer.toByteArray());
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param string The string data
 * @return The created {@link Clob}
 * @deprecated Use {@link #createClob(String,Session)} instead
 */
public static Clob createClob(String string){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(string));
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @return The created {@link Clob}
 * @deprecated Use {@link #createClob(Reader,long,Session)} instead
 */
public static Clob createClob(Reader reader,int length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(reader,length));
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @return The created {@link Clob}
 * @deprecated Use {@link #createClob(Reader,long,Session)} instead
 */
public static Clob createClob(Reader reader,long length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(reader,length));
}
"
"/** 
 * A method to extract the BLOB value from a result set.
 * @param rs The result set
 * @param name The name of the column containing the BLOB
 * @return The BLOB
 * @throws SQLException Indicates a problem accessing the result set
 * @deprecated Use {@link #get(ResultSet,String,LobCreator)} instead
 */
public Object get(ResultSet rs,String name) throws SQLException {
  return get(rs,name,NonContextualLobCreator.INSTANCE);
}
"
"/** 
 * A method to extract the CLOB value from a result set.
 * @param rs The result set
 * @param name The name of the column containing the CLOB
 * @return The CLOB
 * @throws SQLException Indicates a problem accessing the result set
 * @deprecated Use {@link #get(ResultSet,String,LobCreator)} instead
 */
public Object get(ResultSet rs,String name) throws SQLException {
  return get(rs,name,NonContextualLobCreator.INSTANCE);
}
"
"/** 
 * Creates an instance of a  {@link LobCreator} that does not use the underlying JDBC {@link java.sql.Connection}to create LOBs. <p/> This method is here solely to support the older, now-deprecated method of creating LOBs via the various  {@link org.hibernate.Hibernate#createBlob} and {@link org.hibernate.Hibernate#createClob} methods on{@link org.hibernate.Hibernate}.
 * @return The LOB creator.
 * @deprecated Use {@link #getLobCreator(LobCreationContext)} instead.
 */
public LobCreator getLobCreator();
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.impl.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
public void setFetchProfile(String name);
"
"/** 
 * Obtain a JDBC connection
 * @deprecated Obtain connections from {@link ConnectionProvider} instead
 */
public Connection openConnection() throws HibernateException ;
"
"/** 
 * Dispose of the JDBC connection
 * @deprecated Obtain connections from {@link ConnectionProvider} instead
 */
public void closeConnection(Connection conn) throws HibernateException ;
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Obtain a JDBC connection
 * @deprecated Obtain connections from {@link ConnectionProvider} instead
 */
public Connection openConnection() throws HibernateException ;
"
"/** 
 * Dispose of the JDBC connection
 * @deprecated Obtain connections from {@link ConnectionProvider} instead
 */
public void closeConnection(Connection conn) throws HibernateException ;
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with a LockRequest
 */
public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with a LockRequest
 */
public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with a LockRequest
 */
public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with a LockRequest
 */
public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with a LockRequest
 */
public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with a LockRequest
 */
public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with a LockRequest
 */
public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Set the lockmode for the objects idententified by the given alias that appears in the <tt>FROM</tt> clause.
 * @param alias a query alias, or <tt>this</tt> for a collection filter
 * @deprecated Instead use setLockOptions
 */
public Query setLockMode(String alias,LockMode lockMode);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Get the current lock mode
 * @return LockMode
 * @deprecated Instead use getLockOptions
 */
public LockMode getLockMode(){
  return lockOptions.getLockMode();
}
"
"/** 
 * Set the lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public Select setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Set lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(HibernatePersistence.CLASS_NAMES);
    props.remove(HibernatePersistence.PACKAGE_NAMES);
    props.remove(HibernatePersistence.HBXML_FILES);
    props.remove(HibernatePersistence.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * @deprecated use getHbmfiles() rather
 */
public void setHbmfiles(List<NamedInputStream> hbmfiles){
  this.hbmfiles=hbmfiles;
}
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,ExtendedMappings mappings){
  schema=BinderHelper.isDefault(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isDefault(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(HibernatePersistence.CLASS_NAMES);
    props.remove(HibernatePersistence.PACKAGE_NAMES);
    props.remove(HibernatePersistence.HBXML_FILES);
    props.remove(HibernatePersistence.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(HibernatePersistence.CLASS_NAMES);
    props.remove(HibernatePersistence.PACKAGE_NAMES);
    props.remove(HibernatePersistence.HBXML_FILES);
    props.remove(HibernatePersistence.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * @deprecated use getHbmfiles() rather
 */
public void setHbmfiles(List<NamedInputStream> hbmfiles){
  this.hbmfiles=hbmfiles;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Set lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * @deprecated use getHbmfiles() rather
 */
public void setHbmfiles(List<NamedInputStream> hbmfiles){
  this.hbmfiles=hbmfiles;
}
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,ExtendedMappings mappings){
  schema=BinderHelper.isDefault(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isDefault(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,ExtendedMappings mappings){
  schema=BinderHelper.isDefault(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isDefault(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(HibernatePersistence.CLASS_NAMES);
    props.remove(HibernatePersistence.PACKAGE_NAMES);
    props.remove(HibernatePersistence.HBXML_FILES);
    props.remove(HibernatePersistence.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * @deprecated use getHbmfiles() rather
 */
public void setHbmfiles(List<NamedInputStream> hbmfiles){
  this.hbmfiles=hbmfiles;
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * @deprecated use {@link #ManyToOneType(String,String,boolean,boolean,boolean,boolean,boolean)}
 * @noinspection JavaDoc
 */
public ManyToOneType(String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound){
  this(referencedEntityName,uniqueKeyPropertyName,!lazy,isEmbeddedInXML,unwrapProxy,ignoreNotFound,false);
}
"
"/** 
 * A many-to-one association type for the given class
 * @deprecated Use {@link #manyToOne(String,String,boolean,boolean,boolean,boolean,boolean)}
 */
public static EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound){
  return new ManyToOneType(persistentClass,uniqueKeyPropertyName,lazy,unwrapProxy,isEmbeddedInXML,ignoreNotFound);
}
"
"/** 
 * The legacy contract.
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String,boolean)} instead
 */
public static CollectionType customCollection(String typeName,String role,String propertyRef,boolean embedded){
  return customCollection(typeName,null,role,propertyRef,embedded);
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,ExtendedMappings mappings){
  schema=BinderHelper.isDefault(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isDefault(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * @deprecated use {@link #ManyToOneType(String,String,boolean,boolean,boolean,boolean,boolean)}
 * @noinspection JavaDoc
 */
public ManyToOneType(String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound){
  this(referencedEntityName,uniqueKeyPropertyName,lazy,unwrapProxy,isEmbeddedInXML,ignoreNotFound,false);
}
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,ExtendedMappings mappings){
  schema=BinderHelper.isDefault(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isDefault(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * Create a class instance initialized with the given identifier
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @param entityMode The entity mode
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @param entityMode The entity mode
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Create a class instance initialized with the given identifier
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Set the identifier and version of the given instance back to its ""unsaved"" value.
 * @param entity The entity instance
 * @param currentId The currently assigned identifier value.
 * @param currentVersion The currently assigned version value.
 * @param entityMode The entity mode represented by the entity instance.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion,EntityMode entityMode);
"
"/** 
 * Create an entity instance initialized with the given identifier.
 * @param id The identifier value for the entity to be instantiated.
 * @return The instantiated entity.
 * @throws HibernateException
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id) throws HibernateException ;
"
"/** 
 * Inject the given identifier and version into the entity, in order to ""roll back"" to their original values.
 * @param entity The entity for which to reset the id/version values
 * @param currentId The identifier value to inject into the entity.
 * @param currentVersion The version value to inject into the entity.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion);
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * Create a class instance initialized with the given identifier
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Serializable getIdentifier(Object object,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @param entityMode The entity mode
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Serializable getIdentifier(Object object,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @param entityMode The entity mode
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Create a class instance initialized with the given identifier
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Set the identifier and version of the given instance back to its ""unsaved"" value.
 * @param entity The entity instance
 * @param currentId The currently assigned identifier value.
 * @param currentVersion The currently assigned version value.
 * @param entityMode The entity mode represented by the entity instance.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion,EntityMode entityMode);
"
"/** 
 * Create an entity instance initialized with the given identifier.
 * @param id The identifier value for the entity to be instantiated.
 * @return The instantiated entity.
 * @throws HibernateException
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id) throws HibernateException ;
"
"/** 
 * Extract the identifier value from the given entity.
 * @param entity The entity from which to extract the identifier value.
 * @return The identifier value.
 * @throws HibernateException If the entity does not define an identifier property, or anerror occurs accessing its value.
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead.
 */
public Serializable getIdentifier(Object entity) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id) throws HibernateException ;
"
"/** 
 * Inject the given identifier and version into the entity, in order to ""roll back"" to their original values.
 * @param entity The entity for which to reset the id/version values
 * @param currentId The identifier value to inject into the entity.
 * @param currentVersion The version value to inject into the entity.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return new Long(value);
  }
 else   if (clazz == Integer.class) {
    return new Integer((int)value);
  }
 else   if (clazz == Short.class) {
    return new Short((short)value);
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,ExtendedMappings mappings){
  schema=BinderHelper.isDefault(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isDefault(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,ExtendedMappings mappings){
  schema=BinderHelper.isDefault(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isDefault(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Load an entity instance. If <tt>optionalObject</tt> is supplied, load the entity state into the given (uninitialized) object.
 * @deprecated use {@link #load(java.io.Serializable,Object,SessionImplementor,LockOptions)} instead.
 * @noinspection JavaDoc
 */
public Object load(Serializable id,Object optionalObject,SessionImplementor session) throws HibernateException ;
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,ExtendedMappings mappings){
  schema=BinderHelper.isDefault(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isDefault(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * @deprecated use getHbmfiles() rather
 */
public void setHbmfiles(List<NamedInputStream> hbmfiles){
  this.hbmfiles=hbmfiles;
}
"
"/** 
 * A many-to-one association type for the given class
 * @deprecated Use {@link #manyToOne(String,String,boolean,boolean,boolean,boolean,boolean)}
 */
public static EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound){
  return new ManyToOneType(persistentClass,uniqueKeyPropertyName,lazy,unwrapProxy,isEmbeddedInXML,ignoreNotFound);
}
"
"/** 
 * The legacy contract.
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String,boolean)} instead
 */
public static CollectionType customCollection(String typeName,String role,String propertyRef,boolean embedded){
  return customCollection(typeName,null,role,propertyRef,embedded);
}
"
"/** 
 * Deep copy a series of values from one array to another...
 * @param values The values to copy (the source)
 * @param types The value types
 * @param copy an array indicating which values to include in the copy
 * @param target The array into which to copy the values
 * @param session The originating session
 * @deprecated Use {@link TypeHelper#deepCopy} instead
 */
public static void deepCopy(final Object[] values,final Type[] types,final boolean[] copy,final Object[] target,final SessionImplementor session){
  TypeHelper.deepCopy(values,types,copy,target,session);
}
"
"/** 
 * Apply the  {@link Type#beforeAssemble} operation across a series of values.
 * @param row The values
 * @param types The value types
 * @param session The originating session
 * @deprecated Use {@link TypeHelper#beforeAssemble} instead
 */
public static void beforeAssemble(final Serializable[] row,final Type[] types,final SessionImplementor session){
  TypeHelper.beforeAssemble(row,types,session);
}
"
"/** 
 * Apply the  {@link Type#assemble} operation across a series of values.
 * @param row The values
 * @param types The value types
 * @param session The originating session
 * @param owner The entity ""owning"" the values
 * @return The assembled state
 * @deprecated Use {@link TypeHelper#assemble} instead
 */
public static Object[] assemble(final Serializable[] row,final Type[] types,final SessionImplementor session,final Object owner){
  return TypeHelper.assemble(row,types,session,owner);
}
"
"/** 
 * Apply the  {@link Type#disassemble} operation across a series of values.
 * @param row The values
 * @param types The value types
 * @param nonCacheable An array indicating which values to include in the disassembled state
 * @param session The originating session
 * @param owner The entity ""owning"" the values
 * @return The disassembled state
 * @deprecated Use {@link TypeHelper#disassemble} instead
 */
public static Serializable[] disassemble(final Object[] row,final Type[] types,final boolean[] nonCacheable,final SessionImplementor session,final Object owner){
  return TypeHelper.disassemble(row,types,nonCacheable,session,owner);
}
"
"/** 
 * Apply the  {@link Type#replace} operation across a series of values.
 * @param original The source of the state
 * @param target The target into which to replace the source values.
 * @param types The value types
 * @param session The originating session
 * @param owner The entity ""owning"" the values
 * @param copyCache A map representing a cache of already replaced state
 * @return The replaced state
 * @deprecated Use {@link TypeHelper#replace} instead
 */
public static Object[] replace(final Object[] original,final Object[] target,final Type[] types,final SessionImplementor session,final Object owner,final Map copyCache){
  return TypeHelper.replace(original,target,types,session,owner,copyCache);
}
"
"/** 
 * Apply the  {@link Type#replace} operation across a series of values.
 * @param original The source of the state
 * @param target The target into which to replace the source values.
 * @param types The value types
 * @param session The originating session
 * @param owner The entity ""owning"" the values
 * @param copyCache A map representing a cache of already replaced state
 * @param foreignKeyDirection FK directionality to be applied to the replacement
 * @return The replaced state
 * @deprecated Use {@link TypeHelper#replace} instead
 */
public static Object[] replace(final Object[] original,final Object[] target,final Type[] types,final SessionImplementor session,final Object owner,final Map copyCache,final ForeignKeyDirection foreignKeyDirection){
  return TypeHelper.replace(original,target,types,session,owner,copyCache,foreignKeyDirection);
}
"
"/** 
 * Apply the  {@link Type#replace} operation across a series of values, aslong as the corresponding  {@link Type} is an association.<p/> If the corresponding type is a component type, then apply  {@link Type#replace}across the component subtypes but do not replace the component value itself.
 * @param original The source of the state
 * @param target The target into which to replace the source values.
 * @param types The value types
 * @param session The originating session
 * @param owner The entity ""owning"" the values
 * @param copyCache A map representing a cache of already replaced state
 * @param foreignKeyDirection FK directionality to be applied to the replacement
 * @return The replaced state
 * @deprecated Use {@link TypeHelper#replaceAssociations} instead
 */
public static Object[] replaceAssociations(final Object[] original,final Object[] target,final Type[] types,final SessionImplementor session,final Object owner,final Map copyCache,final ForeignKeyDirection foreignKeyDirection){
  return TypeHelper.replaceAssociations(original,target,types,session,owner,copyCache,foreignKeyDirection);
}
"
"/** 
 * Determine if any of the given field values are dirty, returning an array containing indices of the dirty fields. <p/> If it is determined that no fields are dirty, null is returned.
 * @param properties The property definitions
 * @param currentState The current state of the entity
 * @param previousState The baseline state of the entity
 * @param includeColumns Columns to be included in the dirty checking, per property
 * @param anyUninitializedProperties Does the entity currently hold any uninitialized property values?
 * @param session The session from which the dirty check request originated.
 * @return Array containing indices of the dirty properties, or null if no properties considered dirty.
 * @deprecated Use {@link TypeHelper#findDirty} instead
 */
public static int[] findDirty(final StandardProperty[] properties,final Object[] currentState,final Object[] previousState,final boolean[][] includeColumns,final boolean anyUninitializedProperties,final SessionImplementor session){
  return TypeHelper.findDirty(properties,currentState,previousState,includeColumns,anyUninitializedProperties,session);
}
"
"/** 
 * Determine if any of the given field values are modified, returning an array containing indices of the modified fields. <p/> If it is determined that no fields are dirty, null is returned.
 * @param properties The property definitions
 * @param currentState The current state of the entity
 * @param previousState The baseline state of the entity
 * @param includeColumns Columns to be included in the mod checking, per property
 * @param anyUninitializedProperties Does the entity currently hold any uninitialized property values?
 * @param session The session from which the dirty check request originated.
 * @return Array containing indices of the modified properties, or null if no properties considered modified.
 * @deprecated Use {@link TypeHelper#findModified} instead
 */
public static int[] findModified(final StandardProperty[] properties,final Object[] currentState,final Object[] previousState,final boolean[][] includeColumns,final boolean anyUninitializedProperties,final SessionImplementor session){
  return TypeHelper.findModified(properties,currentState,previousState,includeColumns,anyUninitializedProperties,session);
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * A Hibernate <tt>serializable</tt> type.
 * @deprecated Use {@link SerializableType#SerializableType} instead.
 */
public static Type serializable(Class serializableClass){
  return new SerializableType(serializableClass);
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param bytes a byte array
 * @return the Blob
 * @deprecated Use {@link #createBlob(byte[],Session)} instead
 */
public static Blob createBlob(byte[] bytes){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(bytes));
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @return the Blob
 * @deprecated Use {@link #createBlob(InputStream,long,Session)} instead
 */
public static Blob createBlob(InputStream stream,int length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(stream,length));
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @return the Blob
 * @deprecated Use {@link #createBlob(InputStream,long,Session)} instead
 */
public static Blob createBlob(InputStream stream,long length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(stream,length));
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable. <p/> NOTE: this method will read the entire contents of the incoming stream in order to properly handle the  {@link Blob#length()} method.  If you do not want the stream read, use the{@link #createBlob(InputStream,long)} version instead.
 * @param stream a binary stream
 * @return the Blob
 * @throws IOException Indicates an I/O problem accessing the stream
 * @deprecated Use {@link #createBlob(InputStream,long,Session)} instead
 */
public static Blob createBlob(InputStream stream) throws IOException {
  ByteArrayOutputStream buffer=new ByteArrayOutputStream(stream.available());
  StreamUtils.copy(stream,buffer);
  return createBlob(buffer.toByteArray());
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param string The string data
 * @return The created {@link Clob}
 * @deprecated Use {@link #createClob(String,Session)} instead
 */
public static Clob createClob(String string){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(string));
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @return The created {@link Clob}
 * @deprecated Use {@link #createClob(Reader,long,Session)} instead
 */
public static Clob createClob(Reader reader,int length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(reader,length));
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @return The created {@link Clob}
 * @deprecated Use {@link #createClob(Reader,long,Session)} instead
 */
public static Clob createClob(Reader reader,long length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(reader,length));
}
"
"/** 
 * A Hibernate <tt>serializable</tt> type.
 * @param serializableClass The {@link java.io.Serializable} implementor class.
 * @return
 * @deprecated Use {@link SerializableType#SerializableType} instead.
 */
@SuppressWarnings({""unchecked""}) public static Type serializable(Class serializableClass){
  return new SerializableType(serializableClass);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#any} instead.
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type any(Type metaType,Type identifierType){
  throw new HibernateException(""Not supported"");
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type entity(Class persistentClass){
  throw new HibernateException(""Not supported"");
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type entity(String entityName){
  throw new HibernateException(""Not supported"");
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass){
  throw new HibernateException(""Not supported"");
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass,String[] parameterNames,String[] parameterValues){
  throw new HibernateException(""Not supported"");
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass,Properties parameters){
  throw new HibernateException(""Not supported"");
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param bytes a byte array
 * @return the Blob
 * @deprecated Use {@link #createBlob(byte[],Session)} instead
 */
public static Blob createBlob(byte[] bytes){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(bytes));
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @return the Blob
 * @deprecated Use {@link #createBlob(InputStream,long,Session)} instead
 */
public static Blob createBlob(InputStream stream,int length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(stream,length));
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @return the Blob
 * @deprecated Use {@link #createBlob(InputStream,long,Session)} instead
 */
public static Blob createBlob(InputStream stream,long length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(stream,length));
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable. <p/> NOTE: this method will read the entire contents of the incoming stream in order to properly handle the  {@link Blob#length()} method.  If you do not want the stream read, use the{@link #createBlob(InputStream,long)} version instead.
 * @param stream a binary stream
 * @return the Blob
 * @throws IOException Indicates an I/O problem accessing the stream
 * @deprecated Use {@link #createBlob(InputStream,long,Session)} instead
 */
public static Blob createBlob(InputStream stream) throws IOException {
  ByteArrayOutputStream buffer=new ByteArrayOutputStream(stream.available());
  StreamUtils.copy(stream,buffer);
  return createBlob(buffer.toByteArray());
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param string The string data
 * @return The created {@link Clob}
 * @deprecated Use {@link #createClob(String,Session)} instead
 */
public static Clob createClob(String string){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(string));
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @return The created {@link Clob}
 * @deprecated Use {@link #createClob(Reader,long,Session)} instead
 */
public static Clob createClob(Reader reader,int length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(reader,length));
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @return The created {@link Clob}
 * @deprecated Use {@link #createClob(Reader,long,Session)} instead
 */
public static Clob createClob(Reader reader,long length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(reader,length));
}
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
public void evictQueries() throws HibernateException ;
"
"/** 
 * @deprecated use {@link #ManyToOneType(String,String,boolean,boolean,boolean,boolean,boolean)}
 * @noinspection JavaDoc
 */
public ManyToOneType(String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound){
  this(referencedEntityName,uniqueKeyPropertyName,lazy,unwrapProxy,isEmbeddedInXML,ignoreNotFound,false);
}
"
"/** 
 * @deprecated Use {@link #nullSafeGet(ResultSet,String,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public T nullSafeGet(ResultSet rs,String name) throws HibernateException, SQLException ;
"
"/** 
 * DO NOT USER THIS FORM!
 * @deprecated Use {@link #get(ResultSet,String,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public Object get(ResultSet rs,String name) throws HibernateException, SQLException ;
"
"/** 
 * DO NOT USE THIS FORM!
 * @deprecated Use {@link #nullSafeSet(PreparedStatement,Object,int,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public void nullSafeSet(PreparedStatement st,T value,int index) throws HibernateException, SQLException ;
"
"/** 
 * DO NOT USE THIS FORM!
 * @deprecated Use {@link #set(PreparedStatement,Object,int,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public void set(PreparedStatement st,T value,int index) throws HibernateException, SQLException ;
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * A many-to-one association type for the given class
 * @deprecated Use {@link #manyToOne(String,String,boolean,boolean,boolean,boolean,boolean)}
 */
public static EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound){
  return new ManyToOneType(persistentClass,uniqueKeyPropertyName,lazy,unwrapProxy,isEmbeddedInXML,ignoreNotFound);
}
"
"/** 
 * The legacy contract.
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String,boolean)} instead
 */
public static CollectionType customCollection(String typeName,String role,String propertyRef,boolean embedded){
  return customCollection(typeName,null,role,propertyRef,embedded);
}
"
"/** 
 * Deep copy a series of values from one array to another...
 * @param values The values to copy (the source)
 * @param types The value types
 * @param copy an array indicating which values to include in the copy
 * @param target The array into which to copy the values
 * @param session The originating session
 * @deprecated Use {@link TypeHelper#deepCopy} instead
 */
public static void deepCopy(final Object[] values,final Type[] types,final boolean[] copy,final Object[] target,final SessionImplementor session){
  TypeHelper.deepCopy(values,types,copy,target,session);
}
"
"/** 
 * Apply the  {@link Type#beforeAssemble} operation across a series of values.
 * @param row The values
 * @param types The value types
 * @param session The originating session
 * @deprecated Use {@link TypeHelper#beforeAssemble} instead
 */
public static void beforeAssemble(final Serializable[] row,final Type[] types,final SessionImplementor session){
  TypeHelper.beforeAssemble(row,types,session);
}
"
"/** 
 * Apply the  {@link Type#assemble} operation across a series of values.
 * @param row The values
 * @param types The value types
 * @param session The originating session
 * @param owner The entity ""owning"" the values
 * @return The assembled state
 * @deprecated Use {@link TypeHelper#assemble} instead
 */
public static Object[] assemble(final Serializable[] row,final Type[] types,final SessionImplementor session,final Object owner){
  return TypeHelper.assemble(row,types,session,owner);
}
"
"/** 
 * Apply the  {@link Type#disassemble} operation across a series of values.
 * @param row The values
 * @param types The value types
 * @param nonCacheable An array indicating which values to include in the disassembled state
 * @param session The originating session
 * @param owner The entity ""owning"" the values
 * @return The disassembled state
 * @deprecated Use {@link TypeHelper#disassemble} instead
 */
public static Serializable[] disassemble(final Object[] row,final Type[] types,final boolean[] nonCacheable,final SessionImplementor session,final Object owner){
  return TypeHelper.disassemble(row,types,nonCacheable,session,owner);
}
"
"/** 
 * Apply the  {@link Type#replace} operation across a series of values.
 * @param original The source of the state
 * @param target The target into which to replace the source values.
 * @param types The value types
 * @param session The originating session
 * @param owner The entity ""owning"" the values
 * @param copyCache A map representing a cache of already replaced state
 * @return The replaced state
 * @deprecated Use {@link TypeHelper#replace} instead
 */
public static Object[] replace(final Object[] original,final Object[] target,final Type[] types,final SessionImplementor session,final Object owner,final Map copyCache){
  return TypeHelper.replace(original,target,types,session,owner,copyCache);
}
"
"/** 
 * Apply the  {@link Type#replace} operation across a series of values.
 * @param original The source of the state
 * @param target The target into which to replace the source values.
 * @param types The value types
 * @param session The originating session
 * @param owner The entity ""owning"" the values
 * @param copyCache A map representing a cache of already replaced state
 * @param foreignKeyDirection FK directionality to be applied to the replacement
 * @return The replaced state
 * @deprecated Use {@link TypeHelper#replace} instead
 */
public static Object[] replace(final Object[] original,final Object[] target,final Type[] types,final SessionImplementor session,final Object owner,final Map copyCache,final ForeignKeyDirection foreignKeyDirection){
  return TypeHelper.replace(original,target,types,session,owner,copyCache,foreignKeyDirection);
}
"
"/** 
 * Apply the  {@link Type#replace} operation across a series of values, aslong as the corresponding  {@link Type} is an association.<p/> If the corresponding type is a component type, then apply  {@link Type#replace}across the component subtypes but do not replace the component value itself.
 * @param original The source of the state
 * @param target The target into which to replace the source values.
 * @param types The value types
 * @param session The originating session
 * @param owner The entity ""owning"" the values
 * @param copyCache A map representing a cache of already replaced state
 * @param foreignKeyDirection FK directionality to be applied to the replacement
 * @return The replaced state
 * @deprecated Use {@link TypeHelper#replaceAssociations} instead
 */
public static Object[] replaceAssociations(final Object[] original,final Object[] target,final Type[] types,final SessionImplementor session,final Object owner,final Map copyCache,final ForeignKeyDirection foreignKeyDirection){
  return TypeHelper.replaceAssociations(original,target,types,session,owner,copyCache,foreignKeyDirection);
}
"
"/** 
 * Determine if any of the given field values are dirty, returning an array containing indices of the dirty fields. <p/> If it is determined that no fields are dirty, null is returned.
 * @param properties The property definitions
 * @param currentState The current state of the entity
 * @param previousState The baseline state of the entity
 * @param includeColumns Columns to be included in the dirty checking, per property
 * @param anyUninitializedProperties Does the entity currently hold any uninitialized property values?
 * @param session The session from which the dirty check request originated.
 * @return Array containing indices of the dirty properties, or null if no properties considered dirty.
 * @deprecated Use {@link TypeHelper#findDirty} instead
 */
public static int[] findDirty(final StandardProperty[] properties,final Object[] currentState,final Object[] previousState,final boolean[][] includeColumns,final boolean anyUninitializedProperties,final SessionImplementor session){
  return TypeHelper.findDirty(properties,currentState,previousState,includeColumns,anyUninitializedProperties,session);
}
"
"/** 
 * Determine if any of the given field values are modified, returning an array containing indices of the modified fields. <p/> If it is determined that no fields are dirty, null is returned.
 * @param properties The property definitions
 * @param currentState The current state of the entity
 * @param previousState The baseline state of the entity
 * @param includeColumns Columns to be included in the mod checking, per property
 * @param anyUninitializedProperties Does the entity currently hold any uninitialized property values?
 * @param session The session from which the dirty check request originated.
 * @return Array containing indices of the modified properties, or null if no properties considered modified.
 * @deprecated Use {@link TypeHelper#findModified} instead
 */
public static int[] findModified(final StandardProperty[] properties,final Object[] currentState,final Object[] previousState,final boolean[][] includeColumns,final boolean anyUninitializedProperties,final SessionImplementor session){
  return TypeHelper.findModified(properties,currentState,previousState,includeColumns,anyUninitializedProperties,session);
}
"
"/** 
 * A Hibernate <tt>serializable</tt> type.
 * @deprecated see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5138
 */
public static Type serializable(Class serializableClass){
  return new SerializableType(serializableClass);
}
"
"/** 
 * A Hibernate <tt>any</tt> type.
 * @param metaType       a type mapping <tt>java.lang.Class</tt> to a single column
 * @param identifierType the entity identifier type
 * @return the Type
 * @deprecated see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
public static Type any(Type metaType,Type identifierType){
  return new AnyType(metaType,identifierType);
}
"
"/** 
 * A Hibernate persistent object (entity) type.
 * @param persistentClass a mapped entity class
 * @deprecated see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
public static Type entity(Class persistentClass){
  return new ManyToOneType(persistentClass.getName());
}
"
"/** 
 * A Hibernate persistent object (entity) type.
 * @param entityName a mapped entity class
 * @deprecated see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
public static Type entity(String entityName){
  return new ManyToOneType(entityName);
}
"
"/** 
 * A Hibernate custom type.
 * @param userTypeClass a class that implements <tt>UserType</tt>
 * @deprecated see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
public static Type custom(Class userTypeClass) throws HibernateException {
  return custom(userTypeClass,null);
}
"
"/** 
 * A Hibernate parameterizable custom type.
 * @param userTypeClass   a class that implements <tt>UserType and ParameterizableType</tt>
 * @param parameterNames  the names of the parameters passed to the type
 * @param parameterValues the values of the parameters passed to the type. They must matchup with the order and length of the parameterNames array.
 * @deprecated see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
public static Type custom(Class userTypeClass,String[] parameterNames,String[] parameterValues) throws HibernateException {
  Properties parameters=new Properties();
  for (int i=0; i < parameterNames.length; i++) {
    parameters.setProperty(parameterNames[i],parameterValues[i]);
  }
  return custom(userTypeClass,parameters);
}
"
"/** 
 * A Hibernate parameterizable custom type.
 * @param userTypeClass a class that implements <tt>UserType and ParameterizableType</tt>
 * @param parameters    the parameters as a collection of name/value pairs
 * @deprecated see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
public static Type custom(Class userTypeClass,Properties parameters) throws HibernateException {
  if (CompositeUserType.class.isAssignableFrom(userTypeClass)) {
    CompositeCustomType type=new CompositeCustomType(userTypeClass,parameters);
    return type;
  }
 else {
    CustomType type=new CustomType(userTypeClass,parameters);
    return type;
  }
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param bytes a byte array
 * @return the Blob
 * @deprecated Use {@link #createBlob(byte[],Session)} instead
 */
public static Blob createBlob(byte[] bytes){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(bytes));
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @return the Blob
 * @deprecated Use {@link #createBlob(InputStream,long,Session)} instead
 */
public static Blob createBlob(InputStream stream,int length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(stream,length));
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @return the Blob
 * @deprecated Use {@link #createBlob(InputStream,long,Session)} instead
 */
public static Blob createBlob(InputStream stream,long length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(stream,length));
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable. <p/> NOTE: this method will read the entire contents of the incoming stream in order to properly handle the  {@link Blob#length()} method.  If you do not want the stream read, use the{@link #createBlob(InputStream,long)} version instead.
 * @param stream a binary stream
 * @return the Blob
 * @throws IOException Indicates an I/O problem accessing the stream
 * @deprecated Use {@link #createBlob(InputStream,long,Session)} instead
 */
public static Blob createBlob(InputStream stream) throws IOException {
  ByteArrayOutputStream buffer=new ByteArrayOutputStream(stream.available());
  StreamUtils.copy(stream,buffer);
  return createBlob(buffer.toByteArray());
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param string The string data
 * @return The created {@link Clob}
 * @deprecated Use {@link #createClob(String,Session)} instead
 */
public static Clob createClob(String string){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(string));
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @return The created {@link Clob}
 * @deprecated Use {@link #createClob(Reader,long,Session)} instead
 */
public static Clob createClob(Reader reader,int length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(reader,length));
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @return The created {@link Clob}
 * @deprecated Use {@link #createClob(Reader,long,Session)} instead
 */
public static Clob createClob(Reader reader,long length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(reader,length));
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * A many-to-one association type for the given class
 * @deprecated Use {@link #manyToOne(String,String,boolean,boolean,boolean,boolean,boolean)}
 */
public static EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound){
  return new ManyToOneType(persistentClass,uniqueKeyPropertyName,lazy,unwrapProxy,isEmbeddedInXML,ignoreNotFound);
}
"
"/** 
 * Given the name of a Hibernate basic type, return an instance of <tt>org.hibernate.type.Type</tt>.
 * @deprecated see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5138
 */
public static Type basic(String name){
  return (Type)BASIC_TYPES.get(name);
}
"
"/** 
 * Uses heuristics to deduce a Hibernate type given a string naming the type or Java class. Return an instance of <tt>org.hibernate.type.Type</tt>.
 * @deprecated see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5138
 */
public static Type heuristicType(String typeName) throws MappingException {
  return heuristicType(typeName,null);
}
"
"/** 
 * Uses heuristics to deduce a Hibernate type given a string naming the type or Java class. Return an instance of <tt>org.hibernate.type.Type</tt>.
 * @deprecated see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5138
 */
public static Type heuristicType(String typeName,Properties parameters) throws MappingException {
  Type type=TypeFactory.basic(typeName);
  if (type == null) {
    Class typeClass;
    try {
      typeClass=ReflectHelper.classForName(typeName);
    }
 catch (    ClassNotFoundException cnfe) {
      typeClass=null;
    }
    if (typeClass != null) {
      if (Type.class.isAssignableFrom(typeClass)) {
        try {
          type=(Type)typeClass.newInstance();
        }
 catch (        Exception e) {
          throw new MappingException(""Could not instantiate Type: "" + typeClass.getName(),e);
        }
        injectParameters(type,parameters);
      }
 else       if (CompositeUserType.class.isAssignableFrom(typeClass)) {
        type=new CompositeCustomType(typeClass,parameters);
      }
 else       if (UserType.class.isAssignableFrom(typeClass)) {
        type=new CustomType(typeClass,parameters);
      }
 else       if (Lifecycle.class.isAssignableFrom(typeClass)) {
        type=Hibernate.entity(typeClass);
      }
 else       if (Serializable.class.isAssignableFrom(typeClass)) {
        type=Hibernate.serializable(typeClass);
      }
    }
  }
  return type;
}
"
"/** 
 * The legacy contract.
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String,boolean)} instead
 */
public static CollectionType customCollection(String typeName,String role,String propertyRef,boolean embedded){
  return customCollection(typeName,null,role,propertyRef,embedded);
}
"
"/** 
 * Deep copy a series of values from one array to another...
 * @param values The values to copy (the source)
 * @param types The value types
 * @param copy an array indicating which values to include in the copy
 * @param target The array into which to copy the values
 * @param session The orginating session
 * @deprecated see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5138
 */
public static void deepCopy(final Object[] values,final Type[] types,final boolean[] copy,final Object[] target,final SessionImplementor session){
  for (int i=0; i < types.length; i++) {
    if (copy[i]) {
      if (values[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || values[i] == BackrefPropertyAccessor.UNKNOWN) {
        target[i]=values[i];
      }
 else {
        target[i]=types[i].deepCopy(values[i],session.getEntityMode(),session.getFactory());
      }
    }
  }
}
"
"/** 
 * Apply the  {@link Type#beforeAssemble} operation across a series of values.
 * @param row The values
 * @param types The value types
 * @param session The orginating session
 * @deprecated see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5138
 */
public static void beforeAssemble(final Serializable[] row,final Type[] types,final SessionImplementor session){
  for (int i=0; i < types.length; i++) {
    if (row[i] != LazyPropertyInitializer.UNFETCHED_PROPERTY && row[i] != BackrefPropertyAccessor.UNKNOWN) {
      types[i].beforeAssemble(row[i],session);
    }
  }
}
"
"/** 
 * Apply the  {@link Type#assemble} operation across a series of values.
 * @param row The values
 * @param types The value types
 * @param session The orginating session
 * @param owner The entity ""owning"" the values
 * @return The assembled state
 * @deprecated see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5138
 */
public static Object[] assemble(final Serializable[] row,final Type[] types,final SessionImplementor session,final Object owner){
  Object[] assembled=new Object[row.length];
  for (int i=0; i < types.length; i++) {
    if (row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN) {
      assembled[i]=row[i];
    }
 else {
      assembled[i]=types[i].assemble(row[i],session,owner);
    }
  }
  return assembled;
}
"
"/** 
 * Apply the  {@link Type#disassemble} operation across a series of values.
 * @param row The values
 * @param types The value types
 * @param nonCacheable An array indicating which values to include in the disassemled state
 * @param session The orginating session
 * @param owner The entity ""owning"" the values
 * @return The disassembled state
 * @deprecated see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5138
 */
public static Serializable[] disassemble(final Object[] row,final Type[] types,final boolean[] nonCacheable,final SessionImplementor session,final Object owner){
  Serializable[] disassembled=new Serializable[row.length];
  for (int i=0; i < row.length; i++) {
    if (nonCacheable != null && nonCacheable[i]) {
      disassembled[i]=LazyPropertyInitializer.UNFETCHED_PROPERTY;
    }
 else     if (row[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || row[i] == BackrefPropertyAccessor.UNKNOWN) {
      disassembled[i]=(Serializable)row[i];
    }
 else {
      disassembled[i]=types[i].disassemble(row[i],session,owner);
    }
  }
  return disassembled;
}
"
"/** 
 * Apply the  {@link Type#replace} operation across a series of values.
 * @param original The source of the state
 * @param target The target into which to replace the source values.
 * @param types The value types
 * @param session The orginating session
 * @param owner The entity ""owning"" the values
 * @param copyCache A map representing a cache of already replaced state
 * @return The replaced state
 * @deprecated see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5138
 */
public static Object[] replace(final Object[] original,final Object[] target,final Type[] types,final SessionImplementor session,final Object owner,final Map copyCache){
  Object[] copied=new Object[original.length];
  for (int i=0; i < types.length; i++) {
    if (original[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || original[i] == BackrefPropertyAccessor.UNKNOWN) {
      copied[i]=target[i];
    }
 else {
      copied[i]=types[i].replace(original[i],target[i],session,owner,copyCache);
    }
  }
  return copied;
}
"
"/** 
 * Apply the  {@link Type#replace} operation across a series of values.
 * @param original The source of the state
 * @param target The target into which to replace the source values.
 * @param types The value types
 * @param session The orginating session
 * @param owner The entity ""owning"" the values
 * @param copyCache A map representing a cache of already replaced state
 * @param foreignKeyDirection FK directionality to be applied to the replacement
 * @return The replaced state
 * @deprecated see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5138
 */
public static Object[] replace(final Object[] original,final Object[] target,final Type[] types,final SessionImplementor session,final Object owner,final Map copyCache,final ForeignKeyDirection foreignKeyDirection){
  Object[] copied=new Object[original.length];
  for (int i=0; i < types.length; i++) {
    if (original[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || original[i] == BackrefPropertyAccessor.UNKNOWN) {
      copied[i]=target[i];
    }
 else {
      copied[i]=types[i].replace(original[i],target[i],session,owner,copyCache,foreignKeyDirection);
    }
  }
  return copied;
}
"
"/** 
 * Apply the  {@link Type#replace} operation across a series of values, aslong as the corresponding  {@link Type} is an association.<p/> If the corresponding type is a component type, then apply  {@link #replaceAssociations}accross the component subtypes but do not replace the component value itself.
 * @param original The source of the state
 * @param target The target into which to replace the source values.
 * @param types The value types
 * @param session The orginating session
 * @param owner The entity ""owning"" the values
 * @param copyCache A map representing a cache of already replaced state
 * @param foreignKeyDirection FK directionality to be applied to the replacement
 * @return The replaced state
 * @deprecated see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5138
 */
public static Object[] replaceAssociations(final Object[] original,final Object[] target,final Type[] types,final SessionImplementor session,final Object owner,final Map copyCache,final ForeignKeyDirection foreignKeyDirection){
  Object[] copied=new Object[original.length];
  for (int i=0; i < types.length; i++) {
    if (original[i] == LazyPropertyInitializer.UNFETCHED_PROPERTY || original[i] == BackrefPropertyAccessor.UNKNOWN) {
      copied[i]=target[i];
    }
 else     if (types[i].isComponentType()) {
      AbstractComponentType componentType=(AbstractComponentType)types[i];
      Type[] subtypes=componentType.getSubtypes();
      Object[] origComponentValues=original[i] == null ? new Object[subtypes.length] : componentType.getPropertyValues(original[i],session);
      Object[] targetComponentValues=target[i] == null ? new Object[subtypes.length] : componentType.getPropertyValues(target[i],session);
      replaceAssociations(origComponentValues,targetComponentValues,subtypes,session,null,copyCache,foreignKeyDirection);
      copied[i]=target[i];
    }
 else     if (!types[i].isAssociationType()) {
      copied[i]=target[i];
    }
 else {
      copied[i]=types[i].replace(original[i],target[i],session,owner,copyCache,foreignKeyDirection);
    }
  }
  return copied;
}
"
"/** 
 * Determine if any of the given field values are dirty, returning an array containing indices of the dirty fields. <p/> If it is determined that no fields are dirty, null is returned.
 * @param properties The property definitions
 * @param currentState The current state of the entity
 * @param previousState The baseline state of the entity
 * @param includeColumns Columns to be included in the dirty checking, per property
 * @param anyUninitializedProperties Does the entity currently hold any uninitialized property values?
 * @param session The session from which the dirty check request originated.
 * @return Array containing indices of the dirty properties, or null if no properties considered dirty.
 * @deprecated see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5138
 */
public static int[] findDirty(final StandardProperty[] properties,final Object[] currentState,final Object[] previousState,final boolean[][] includeColumns,final boolean anyUninitializedProperties,final SessionImplementor session){
  int[] results=null;
  int count=0;
  int span=properties.length;
  for (int i=0; i < span; i++) {
    final boolean dirty=currentState[i] != LazyPropertyInitializer.UNFETCHED_PROPERTY && properties[i].isDirtyCheckable(anyUninitializedProperties) && properties[i].getType().isDirty(previousState[i],currentState[i],includeColumns[i],session);
    if (dirty) {
      if (results == null) {
        results=new int[span];
      }
      results[count++]=i;
    }
  }
  if (count == 0) {
    return null;
  }
 else {
    int[] trimmed=new int[count];
    System.arraycopy(results,0,trimmed,0,count);
    return trimmed;
  }
}
"
"/** 
 * Determine if any of the given field values are modified, returning an array containing indices of the modified fields. <p/> If it is determined that no fields are dirty, null is returned.
 * @param properties The property definitions
 * @param currentState The current state of the entity
 * @param previousState The baseline state of the entity
 * @param includeColumns Columns to be included in the mod checking, per property
 * @param anyUninitializedProperties Does the entity currently hold any uninitialized property values?
 * @param session The session from which the dirty check request originated.
 * @return Array containing indices of the modified properties, or null if no properties considered modified.
 * @deprecated see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5138
 */
public static int[] findModified(final StandardProperty[] properties,final Object[] currentState,final Object[] previousState,final boolean[][] includeColumns,final boolean anyUninitializedProperties,final SessionImplementor session){
  int[] results=null;
  int count=0;
  int span=properties.length;
  for (int i=0; i < span; i++) {
    final boolean modified=currentState[i] != LazyPropertyInitializer.UNFETCHED_PROPERTY && properties[i].isDirtyCheckable(anyUninitializedProperties) && properties[i].getType().isModified(previousState[i],currentState[i],includeColumns[i],session);
    if (modified) {
      if (results == null) {
        results=new int[span];
      }
      results[count++]=i;
    }
  }
  if (count == 0) {
    return null;
  }
 else {
    int[] trimmed=new int[count];
    System.arraycopy(results,0,trimmed,0,count);
    return trimmed;
  }
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * A Hibernate <tt>serializable</tt> type.
 * @param serializableClass The {@link java.io.Serializable} implementor class.
 * @return
 * @deprecated Use {@link SerializableType#SerializableType} instead.
 */
@SuppressWarnings({""unchecked""}) public static Type serializable(Class serializableClass){
  return new SerializableType(serializableClass);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#any} instead.
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type any(Type metaType,Type identifierType){
  return new AnyType(metaType,identifierType);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration"",""deprecation""}) public static Type entity(Class persistentClass){
  return entity(persistentClass.getName());
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type entity(String entityName){
  return new ManyToOneType(NoScope.INSTANCE,entityName);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass){
  return custom(userTypeClass,null);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass,String[] parameterNames,String[] parameterValues){
  return custom(userTypeClass,toProperties(parameterNames,parameterValues));
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration"",""unchecked""}) public static Type custom(Class userTypeClass,Properties parameters){
  if (CompositeUserType.class.isAssignableFrom(userTypeClass)) {
    return TypeFactory.customComponent(userTypeClass,parameters,NoScope.INSTANCE);
  }
 else {
    return TypeFactory.custom(userTypeClass,parameters,NoScope.INSTANCE);
  }
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param bytes a byte array
 * @return the Blob
 * @deprecated Use {@link #createBlob(byte[],Session)} instead
 */
public static Blob createBlob(byte[] bytes){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(bytes));
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @return the Blob
 * @deprecated Use {@link #createBlob(InputStream,long,Session)} instead
 */
public static Blob createBlob(InputStream stream,int length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(stream,length));
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @return the Blob
 * @deprecated Use {@link #createBlob(InputStream,long,Session)} instead
 */
public static Blob createBlob(InputStream stream,long length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(stream,length));
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable. <p/> NOTE: this method will read the entire contents of the incoming stream in order to properly handle the  {@link Blob#length()} method.  If you do not want the stream read, use the{@link #createBlob(InputStream,long)} version instead.
 * @param stream a binary stream
 * @return the Blob
 * @throws IOException Indicates an I/O problem accessing the stream
 * @deprecated Use {@link #createBlob(InputStream,long,Session)} instead
 */
public static Blob createBlob(InputStream stream) throws IOException {
  ByteArrayOutputStream buffer=new ByteArrayOutputStream(stream.available());
  StreamUtils.copy(stream,buffer);
  return createBlob(buffer.toByteArray());
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param string The string data
 * @return The created {@link Clob}
 * @deprecated Use {@link #createClob(String,Session)} instead
 */
public static Clob createClob(String string){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(string));
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @return The created {@link Clob}
 * @deprecated Use {@link #createClob(Reader,long,Session)} instead
 */
public static Clob createClob(Reader reader,int length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(reader,length));
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @return The created {@link Clob}
 * @deprecated Use {@link #createClob(Reader,long,Session)} instead
 */
public static Clob createClob(Reader reader,long length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(reader,length));
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #renderOrderByStringTemplate(String,ColumnMapper,SessionFactoryImplementor,Dialect,SQLFunctionRegistry)} instead
 */
public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The return type of the function.  May be either a concrete type which is preset, or variable depending upon the type of the first function argument.
 * @param columnType the type of the first argument
 * @param mapping The mapping source.
 * @return The type to be expected as a return.
 * @throws org.hibernate.QueryException Indicates an issue resolving the return type.
 * @deprecated See http://opensource.atlassian.com/projects/hibernate/browse/HHH-5212
 */
public Type getReturnType(Type columnType,Mapping mapping) throws QueryException ;
"
"/** 
 * Render the function call as SQL fragment.
 * @param args The function arguments
 * @param factory The SessionFactory
 * @return The rendered function call
 * @throws org.hibernate.QueryException Indicates a problem rendering thefunction call.
 * @deprecated See http://opensource.atlassian.com/projects/hibernate/browse/HHH-5212
 */
public String render(List args,SessionFactoryImplementor factory) throws QueryException ;
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The return type of the function.  May be either a concrete type which is preset, or variable depending upon the type of the first function argument.
 * @param columnType the type of the first argument
 * @param mapping The mapping source.
 * @return The type to be expected as a return.
 * @throws org.hibernate.QueryException Indicates an issue resolving the return type.
 * @deprecated See http://opensource.atlassian.com/projects/hibernate/browse/HHH-5212
 */
public Type getReturnType(Type columnType,Mapping mapping) throws QueryException ;
"
"/** 
 * Render the function call as SQL fragment.
 * @param args The function arguments
 * @param factory The SessionFactory
 * @return The rendered function call
 * @throws org.hibernate.QueryException Indicates a problem rendering thefunction call.
 * @deprecated See http://opensource.atlassian.com/projects/hibernate/browse/HHH-5212
 */
public String render(List args,SessionFactoryImplementor factory) throws QueryException ;
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@SuppressWarnings({""UnnecessaryBoxing""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  String optimizerClassName;
  if (NONE.equals(type)) {
    optimizerClassName=NoopOptimizer.class.getName();
  }
 else   if (HILO.equals(type)) {
    optimizerClassName=HiLoOptimizer.class.getName();
  }
 else   if (LEGACY_HILO.equals(type)) {
    optimizerClassName=LegacyHiLoAlgorithmOptimizer.class.getName();
  }
 else   if (POOL.equals(type)) {
    optimizerClassName=PooledOptimizer.class.getName();
  }
 else {
    optimizerClassName=type;
  }
  try {
    Class optimizerClass=ReflectHelper.classForName(optimizerClassName);
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    log.warn(""Unable to instantiate specified optimizer [{}], falling back to noop"",type);
  }
  return new NoopOptimizer(returnClass,incrementSize);
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  String optimizerClassName;
  if (NONE.equals(type)) {
    optimizerClassName=NoopOptimizer.class.getName();
  }
 else   if (HILO.equals(type)) {
    optimizerClassName=HiLoOptimizer.class.getName();
  }
 else   if (LEGACY_HILO.equals(type)) {
    optimizerClassName=LegacyHiLoAlgorithmOptimizer.class.getName();
  }
 else   if (POOL.equals(type)) {
    optimizerClassName=PooledOptimizer.class.getName();
  }
 else {
    optimizerClassName=type;
  }
  try {
    Class optimizerClass=ReflectHelper.classForName(optimizerClassName);
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(new Object[]{returnClass,new Integer(incrementSize)});
  }
 catch (  Throwable ignore) {
  }
  return new NoopOptimizer(returnClass,incrementSize);
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  String optimizerClassName;
  if (NONE.equals(type)) {
    optimizerClassName=NoopOptimizer.class.getName();
  }
 else   if (HILO.equals(type)) {
    optimizerClassName=HiLoOptimizer.class.getName();
  }
 else   if (LEGACY_HILO.equals(type)) {
    optimizerClassName=LegacyHiLoAlgorithmOptimizer.class.getName();
  }
 else   if (POOL.equals(type)) {
    optimizerClassName=PooledOptimizer.class.getName();
  }
 else   if (POOL_LO.equals(type)) {
    optimizerClassName=PooledLoOptimizer.class.getName();
  }
 else {
    optimizerClassName=type;
  }
  try {
    Class optimizerClass=ReflectHelper.classForName(optimizerClassName);
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(new Object[]{returnClass,new Integer(incrementSize)});
  }
 catch (  Throwable ignore) {
  }
  return new NoopOptimizer(returnClass,incrementSize);
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@SuppressWarnings({""UnnecessaryBoxing""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  String optimizerClassName;
  if (NONE.equals(type)) {
    optimizerClassName=NoopOptimizer.class.getName();
  }
 else   if (HILO.equals(type)) {
    optimizerClassName=HiLoOptimizer.class.getName();
  }
 else   if (LEGACY_HILO.equals(type)) {
    optimizerClassName=LegacyHiLoAlgorithmOptimizer.class.getName();
  }
 else   if (POOL.equals(type)) {
    optimizerClassName=PooledOptimizer.class.getName();
  }
 else   if (POOL_LO.equals(type)) {
    optimizerClassName=PooledLoOptimizer.class.getName();
  }
 else {
    optimizerClassName=type;
  }
  try {
    Class optimizerClass=ReflectHelper.classForName(optimizerClassName);
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    log.warn(""Unable to instantiate specified optimizer [{}], falling back to noop"",type);
  }
  return new NoopOptimizer(returnClass,incrementSize);
}
"
"/** 
 * A Hibernate <tt>serializable</tt> type.
 * @param serializableClass The {@link java.io.Serializable} implementor class.
 * @return
 * @deprecated Use {@link SerializableType#SerializableType} instead.
 */
@SuppressWarnings({""unchecked""}) public static Type serializable(Class serializableClass){
  return new SerializableType(serializableClass);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#any} instead.
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type any(Type metaType,Type identifierType){
  return new AnyType(metaType,identifierType);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration"",""deprecation""}) public static Type entity(Class persistentClass){
  return entity(persistentClass.getName());
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type entity(String entityName){
  return new ManyToOneType(NoScope.INSTANCE,entityName);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass){
  return custom(userTypeClass,null);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass,String[] parameterNames,String[] parameterValues){
  return custom(userTypeClass,toProperties(parameterNames,parameterValues));
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration"",""unchecked""}) public static Type custom(Class userTypeClass,Properties parameters){
  if (CompositeUserType.class.isAssignableFrom(userTypeClass)) {
    return TypeFactory.customComponent(userTypeClass,parameters,NoScope.INSTANCE);
  }
 else {
    return TypeFactory.custom(userTypeClass,parameters,NoScope.INSTANCE);
  }
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param bytes a byte array
 * @return the Blob
 * @deprecated Use {@link LobHelper#createBlob(byte[])} instead.
 */
public static Blob createBlob(byte[] bytes){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(bytes));
}
"
"/** 
 * Create a new  {@link Blob}.
 * @param bytes a byte array
 * @param session The session in which the {@link Blob} will be used.
 * @return the Blob
 * @deprecated Use {@link LobHelper#createBlob(byte[])} instead.
 */
public static Blob createBlob(byte[] bytes,Session session){
  return getLobCreator(session).createBlob(bytes);
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @return the Blob
 * @deprecated Use {@link LobHelper#createBlob(InputStream,long)} instead.
 */
@Deprecated public static Blob createBlob(InputStream stream,int length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(stream,length));
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @return the Blob
 * @deprecated Use {@link LobHelper#createBlob(InputStream,long)} instead.
 */
@Deprecated public static Blob createBlob(InputStream stream,long length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(stream,length));
}
"
"/** 
 * Create a new  {@link Blob}.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @param session The session in which the {@link Blob} will be used.
 * @return the Blob
 * @deprecated Use {@link LobHelper#createBlob(InputStream,long)} instead.
 */
@Deprecated public static Blob createBlob(InputStream stream,long length,Session session){
  return getLobCreator(session).createBlob(stream,length);
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable. <p/> NOTE: this method will read the entire contents of the incoming stream in order to properly handle the  {@link Blob#length()} method.  If you do not want the stream read, use the{@link #createBlob(InputStream,long)} version instead.
 * @param stream a binary stream
 * @return the Blob
 * @throws IOException Indicates an I/O problem accessing the stream
 * @deprecated With no direct replacement.  Use {@link #createBlob(InputStream,long)} instead, passing in the length
 */
@Deprecated public static Blob createBlob(InputStream stream) throws IOException {
  ByteArrayOutputStream buffer=new ByteArrayOutputStream(stream.available());
  StreamUtils.copy(stream,buffer);
  return createBlob(buffer.toByteArray());
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param string The string data
 * @return The created {@link Clob}
 * @deprecated Use {@link LobHelper#createClob(String)} instead
 */
@Deprecated public static Clob createClob(String string){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(string));
}
"
"/** 
 * Create a new  {@link Clob}.
 * @param string The string data
 * @param session The session in which the {@link Clob} will be used.
 * @return The created {@link Clob}
 * @deprecated Use {@link LobHelper#createClob(String)} instead
 */
@Deprecated public static Clob createClob(String string,Session session){
  return getLobCreator(session).createClob(string);
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @return The created {@link Clob}
 * @deprecated Use {@link LobHelper#createClob(Reader,long)} instead
 */
@Deprecated public static Clob createClob(Reader reader,int length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(reader,length));
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @return The created {@link Clob}
 * @deprecated Use {@link LobHelper#createClob(Reader,long)} instead
 */
@Deprecated public static Clob createClob(Reader reader,long length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(reader,length));
}
"
"/** 
 * Create a new  {@link Clob}.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @param session The session in which the {@link Clob} will be used.
 * @return The created {@link Clob}
 * @deprecated Use {@link LobHelper#createClob(Reader,long)} instead
 */
@Deprecated public static Clob createClob(Reader reader,long length,Session session){
  return getLobCreator(session).createClob(reader,length);
}
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Creates an instance of a  {@link LobCreator} that does not use the underlying JDBC {@link java.sql.Connection}to create LOBs. <p/> This method is here solely to support the older, now-deprecated method of creating LOBs via the various  {@link org.hibernate.Hibernate#createBlob} and {@link org.hibernate.Hibernate#createClob} methods on{@link org.hibernate.Hibernate}.
 * @return The LOB creator.
 * @deprecated Use {@link #getLobCreator(LobCreationContext)} instead.
 */
public LobCreator getLobCreator();
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param cfg The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  formatter=(PropertiesHelper.getBoolean(Environment.FORMAT_SQL,props) ? FormatStyle.DDL : FormatStyle.NONE).getFormatter();
  importFile=PropertiesHelper.getString(Environment.HBM2DDL_IMPORT_FILE,props,DEFAULT_IMPORT_FILE);
}
"
"/** 
 * An import file, containing raw SQL statements to be executed.
 * @param filename The import file name.
 * @return this
 * @deprecated use {@link org.hibernate.cfg.Environment.HBM2DDL_IMPORT_FILE}
 */
public SchemaExport setImportFile(String filename){
  importFile=filename;
  return this;
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param cfg The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  formatter=(PropertiesHelper.getBoolean(Environment.FORMAT_SQL,props) ? FormatStyle.DDL : FormatStyle.NONE).getFormatter();
  importFiles=PropertiesHelper.getString(Environment.HBM2DDL_IMPORT_FILES,props,DEFAULT_IMPORT_FILE);
}
"
"/** 
 * An import file, containing raw SQL statements to be executed.
 * @param filename The import file name.
 * @return this
 * @deprecated use {@link org.hibernate.cfg.Environment.HBM2DDL_IMPORT_FILE}
 */
public SchemaExport setImportFile(String filename){
  importFiles=filename;
  return this;
}
"
"/** 
 * Set lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Set lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Set lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Log the given warning and all of its nested warnings, preceded with the  {@link #DEFAULT_WARNING_MSG default message}
 * @param warning The warning to log
 * @deprecated Use {@link #walkWarnings} instead
 */
@Deprecated() @SuppressWarnings({""UnusedDeclaration""}) public static void logWarnings(SQLWarning warning){
  walkWarnings(warning,STANDARD_WARNING_HANDLER);
}
"
"/** 
 * Log the given warning and all of its nested warnings, preceded with the given message
 * @param warning The warning to log
 * @param message The prologue message
 * @deprecated Use {@link #walkWarnings} instead
 */
@Deprecated() @SuppressWarnings({""UnusedDeclaration""}) public static void logWarnings(SQLWarning warning,String message){
  final WarningHandler handler=StringHelper.isNotEmpty(message) ? new StandardWarningHandler(message) : STANDARD_WARNING_HANDLER;
  walkWarnings(warning,handler);
}
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,ExtendedMappings mappings){
  schema=BinderHelper.isDefault(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isDefault(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * @deprecated as of release 3.4.0.CR2, replaced by Hibernate Search's {@link org.hibernate.search.cfg.EventListenerRegister#enableHibernateSearch(EventListeners,Properties)}
 */
@SuppressWarnings(""unchecked"") @Deprecated public static void enableHibernateSearch(EventListeners eventListeners,Properties properties){
  String enableSearchListeners=properties.getProperty(""hibernate.search.autoregister_listeners"");
  if (""false"".equalsIgnoreCase(enableSearchListeners)) {
    log.info(""Property hibernate.search.autoregister_listeners is set to false."" + "" No attempt will be made to register Hibernate Search event listeners."");
    return;
  }
  Class searchEventListenerClass=attemptToLoadSearchEventListener();
  if (searchEventListenerClass == null) {
    log.info(""Unable to find {} on the classpath. Hibernate Search is not enabled."",FULL_TEXT_INDEX_EVENT_LISTENER_CLASS);
    return;
  }
  Object searchEventListener=instantiateEventListener(searchEventListenerClass);
{
    boolean present=false;
    PostInsertEventListener[] listeners=eventListeners.getPostInsertEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostInsertEventListener[] newListeners=new PostInsertEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostInsertEventListener)searchEventListener;
        eventListeners.setPostInsertEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostInsertEventListeners(new PostInsertEventListener[]{(PostInsertEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostUpdateEventListener[] listeners=eventListeners.getPostUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostUpdateEventListener[] newListeners=new PostUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostUpdateEventListener)searchEventListener;
        eventListeners.setPostUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostUpdateEventListeners(new PostUpdateEventListener[]{(PostUpdateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostDeleteEventListener[] listeners=eventListeners.getPostDeleteEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostDeleteEventListener[] newListeners=new PostDeleteEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostDeleteEventListener)searchEventListener;
        eventListeners.setPostDeleteEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostDeleteEventListeners(new PostDeleteEventListener[]{(PostDeleteEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRecreateEventListener[] listeners=eventListeners.getPostCollectionRecreateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRecreateEventListener[] newListeners=new PostCollectionRecreateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRecreateEventListener)searchEventListener;
        eventListeners.setPostCollectionRecreateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRecreateEventListeners(new PostCollectionRecreateEventListener[]{(PostCollectionRecreateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRemoveEventListener[] listeners=eventListeners.getPostCollectionRemoveEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRemoveEventListener[] newListeners=new PostCollectionRemoveEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRemoveEventListener)searchEventListener;
        eventListeners.setPostCollectionRemoveEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRemoveEventListeners(new PostCollectionRemoveEventListener[]{(PostCollectionRemoveEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionUpdateEventListener[] listeners=eventListeners.getPostCollectionUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionUpdateEventListener[] newListeners=new PostCollectionUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionUpdateEventListener)searchEventListener;
        eventListeners.setPostCollectionUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionUpdateEventListeners(new PostCollectionUpdateEventListener[]{(PostCollectionUpdateEventListener)searchEventListener});
    }
  }
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,ExtendedMappings mappings){
  schema=BinderHelper.isDefault(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isDefault(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * @deprecated as of release 3.4.0.CR2, replaced by Hibernate Search's {@link org.hibernate.search.cfg.EventListenerRegister#enableHibernateSearch(EventListeners,Properties)}
 */
@SuppressWarnings(""unchecked"") @Deprecated public static void enableHibernateSearch(EventListeners eventListeners,Properties properties){
  String enableSearchListeners=properties.getProperty(""hibernate.search.autoregister_listeners"");
  if (""false"".equalsIgnoreCase(enableSearchListeners)) {
    log.info(""Property hibernate.search.autoregister_listeners is set to false."" + "" No attempt will be made to register Hibernate Search event listeners."");
    return;
  }
  Class searchEventListenerClass=attemptToLoadSearchEventListener();
  if (searchEventListenerClass == null) {
    log.info(""Unable to find {} on the classpath. Hibernate Search is not enabled."",FULL_TEXT_INDEX_EVENT_LISTENER_CLASS);
    return;
  }
  Object searchEventListener=instantiateEventListener(searchEventListenerClass);
{
    boolean present=false;
    PostInsertEventListener[] listeners=eventListeners.getPostInsertEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostInsertEventListener[] newListeners=new PostInsertEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostInsertEventListener)searchEventListener;
        eventListeners.setPostInsertEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostInsertEventListeners(new PostInsertEventListener[]{(PostInsertEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostUpdateEventListener[] listeners=eventListeners.getPostUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostUpdateEventListener[] newListeners=new PostUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostUpdateEventListener)searchEventListener;
        eventListeners.setPostUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostUpdateEventListeners(new PostUpdateEventListener[]{(PostUpdateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostDeleteEventListener[] listeners=eventListeners.getPostDeleteEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostDeleteEventListener[] newListeners=new PostDeleteEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostDeleteEventListener)searchEventListener;
        eventListeners.setPostDeleteEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostDeleteEventListeners(new PostDeleteEventListener[]{(PostDeleteEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRecreateEventListener[] listeners=eventListeners.getPostCollectionRecreateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRecreateEventListener[] newListeners=new PostCollectionRecreateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRecreateEventListener)searchEventListener;
        eventListeners.setPostCollectionRecreateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRecreateEventListeners(new PostCollectionRecreateEventListener[]{(PostCollectionRecreateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRemoveEventListener[] listeners=eventListeners.getPostCollectionRemoveEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRemoveEventListener[] newListeners=new PostCollectionRemoveEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRemoveEventListener)searchEventListener;
        eventListeners.setPostCollectionRemoveEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRemoveEventListeners(new PostCollectionRemoveEventListener[]{(PostCollectionRemoveEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionUpdateEventListener[] listeners=eventListeners.getPostCollectionUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionUpdateEventListener[] newListeners=new PostCollectionUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionUpdateEventListener)searchEventListener;
        eventListeners.setPostCollectionUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionUpdateEventListeners(new PostCollectionUpdateEventListener[]{(PostCollectionUpdateEventListener)searchEventListener});
    }
  }
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  String optimizerClassName;
  if (NONE.equals(type)) {
    optimizerClassName=NoopOptimizer.class.getName();
  }
 else   if (HILO.equals(type)) {
    optimizerClassName=HiLoOptimizer.class.getName();
  }
 else   if (LEGACY_HILO.equals(type)) {
    optimizerClassName=LegacyHiLoAlgorithmOptimizer.class.getName();
  }
 else   if (POOL.equals(type)) {
    optimizerClassName=PooledOptimizer.class.getName();
  }
 else   if (POOL_LO.equals(type)) {
    optimizerClassName=PooledLoOptimizer.class.getName();
  }
 else {
    optimizerClassName=type;
  }
  try {
    Class optimizerClass=ReflectHelper.classForName(optimizerClassName);
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(new Object[]{returnClass,new Integer(incrementSize)});
  }
 catch (  Throwable ignore) {
  }
  return new NoopOptimizer(returnClass,incrementSize);
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@SuppressWarnings({""UnnecessaryBoxing""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  String optimizerClassName;
  if (NONE.equals(type)) {
    optimizerClassName=NoopOptimizer.class.getName();
  }
 else   if (HILO.equals(type)) {
    optimizerClassName=HiLoOptimizer.class.getName();
  }
 else   if (LEGACY_HILO.equals(type)) {
    optimizerClassName=LegacyHiLoAlgorithmOptimizer.class.getName();
  }
 else   if (POOL.equals(type)) {
    optimizerClassName=PooledOptimizer.class.getName();
  }
 else   if (POOL_LO.equals(type)) {
    optimizerClassName=PooledLoOptimizer.class.getName();
  }
 else {
    optimizerClassName=type;
  }
  try {
    Class optimizerClass=ReflectHelper.classForName(optimizerClassName);
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    log.warn(""Unable to instantiate specified optimizer [{}], falling back to noop"",type);
  }
  return new NoopOptimizer(returnClass,incrementSize);
}
"
"/** 
 * @deprecated use getHbmfiles() rather
 */
public void setHbmfiles(List<NamedInputStream> hbmfiles){
  this.hbmfiles=hbmfiles;
}
"
"/** 
 * Copy the state of the given object onto the persistent object with the same identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If the given instance is unsaved or does not exist in the database, save it and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated use {@link org.hibernate.Session#merge(Object)}
 * @param object a transient instance with state to be copied
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(Object object) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the given identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If there is no database row with the given identifier, save the given instance and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated with no replacement
 * @param object a persistent or transient instance with state to be copied
 * @param id the identifier of the instance to copy to
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the same identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If the given instance is unsaved or does not exist in the database, save it and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated use {@link org.hibernate.Session#merge(String,Object)}
 * @param object a transient instance with state to be copied
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(String entityName,Object object) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the given identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If there is no database row with the given identifier, save the given instance and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated with no replacement
 * @param object a persistent or transient instance with state to be copied
 * @param id the identifier of the instance to copy to
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Execute a query.
 * @deprecated use {@link #createQuery}. {@link Query#list()}
 * @param query a query expressed in Hibernate's query language
 * @return a distinct list of instances (or arrays of instances)
 * @throws HibernateException
 */
public List find(String query) throws HibernateException ;
"
"/** 
 * Execute a query with bind parameters, binding a value to a ""?"" parameter in the query string.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#list()}
 * @param query the query string
 * @param value a value to be bound to a ""?"" placeholder (JDBC IN parameter).
 * @param type the Hibernate type of the value
 * @see org.hibernate.Hibernate for access to <tt>Type</tt> instances
 * @return a distinct list of instances (or arrays of instances)
 * @throws HibernateException
 */
public List find(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Execute a query with bind parameters, binding an array of values to ""?"" parameters in the query string.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#list()}
 * @param query the query string
 * @param values an array of values to be bound to the ""?"" placeholders (JDBC IN parameters).
 * @param types an array of Hibernate types of the values
 * @see org.hibernate.Hibernate for access to <tt>Type</tt> instances
 * @return a distinct list of instances
 * @throws HibernateException
 */
public List find(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. If the query has multiple return values, values will be returned in an array of type <tt>Object[].</tt><br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}. {@link Query#iterate}
 * @param query the query string
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. Write the given value to ""?"" in the query string. If the query has multiple return values, values will be returned in an array of type <tt>Object[]</tt>.<br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#iterate}
 * @param query the query string
 * @param value a value to be witten to a ""?"" placeholder in the query string
 * @param type the hibernate type of value
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. Write the given values to ""?"" in the query string. If the query has multiple return values, values will be returned in an array of type <tt>Object[]</tt>.<br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#iterate}
 * @param query the query string
 * @param values a list of values to be written to ""?"" placeholders in the query
 * @param types a list of Hibernate types of the values
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element. Filters allow efficient access to very large lazy collections. (Executing the filter does not initialize the collection.)
 * @deprecated use {@link #createFilter(Object,String)}. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @return Collection the resulting collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element.
 * @deprecated use {@link #createFilter(Object,String)}.setXYZ. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @param value a value to be witten to a ""?"" placeholder in the query string
 * @param type the hibernate type of value
 * @return Collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter,Object value,Type type) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. Bind the given parameters to ""?"" placeholders. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element.
 * @deprecated use {@link #createFilter(Object,String)}.setXYZ. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @param values a list of values to be written to ""?"" placeholders in the query
 * @param types a list of Hibernate types of the values
 * @return Collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @param value a value to be witten to a ""?"" placeholder in the query string.
 * @param type the hibernate type of value.
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @param values a list of values to be written to ""?"" placeholders in the query.
 * @param types a list of Hibernate types of the values
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Create a new instance of <tt>Query</tt> for the given SQL string. <p/> Returned instances should all be  {@link org.hibernate.SQLQuery}.
 * @param sql a query expressed in SQL
 * @param returnAlias a table alias that appears inside <tt>{}</tt> in the SQL string
 * @param returnClass the returned persistent class
 * @deprecated use {@link org.hibernate.SQLQuery#addRoot} or {@link org.hibernate.SQLQuery#addEntity} variantsinstead to define the alias/class
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Query createSQLQuery(String sql,String returnAlias,Class returnClass);
"
"/** 
 * Create a new instance of <tt>Query</tt> for the given SQL string. <p/> Returned instances should all be  {@link org.hibernate.SQLQuery}.
 * @param sql a query expressed in SQL
 * @param returnAliases an array of table aliases that appear inside <tt>{}</tt> in the SQL string
 * @param returnClasses the returned persistent classes
 * @deprecated use {@link org.hibernate.SQLQuery#addRoot} or {@link org.hibernate.SQLQuery#addEntity} variantsinstead to define the aliases/classes
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Query createSQLQuery(String sql,String[] returnAliases,Class[] returnClasses);
"
"/** 
 * Persist the given transient instance, using the given identifier.  This operation  cascades to associated instances if the association is mapped with  <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a transient instance of a persistent class
 * @param id an unused valid identifier
 * @throws HibernateException
 */
public void save(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Persist the given transient instance, using the given identifier. This operation  cascades to associated instances if the association is mapped with  <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a transient instance of a persistent class
 * @param id an unused valid identifier
 * @throws HibernateException
 */
public void save(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Update the persistent state associated with the given identifier. An exception is thrown if there is a persistent instance with the same identifier in the current session. This operation cascades to associated instances  if the association is mapped with <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a detached instance containing updated state
 * @param id identifier of persistent instance
 * @throws HibernateException
 */
public void update(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Update the persistent state associated with the given identifier. An exception is thrown if there is a persistent instance with the same identifier in the current session. This operation cascades to associated instances  if the association is mapped with <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a detached instance containing updated state
 * @param id identifier of persistent instance
 * @throws HibernateException
 */
public void update(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * This form used from annotations (?).  Essentially the same as the above using a resultset-mapping reference, but without cacheMode, readOnly, and comment. FIXME: annotations do not use it, so it can be remove from my POV
 * @deprecated
 * @param query The sql query string
 * @param resultSetRef The result-set-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 */
public NamedSQLQueryDefinition(String query,String resultSetRef,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,Map parameterTypes,boolean callable){
  this(query,resultSetRef,querySpaces,cacheable,cacheRegion,timeout,fetchSize,flushMode,null,false,null,parameterTypes,callable);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * @deprecated use {@link #ManyToOneType(String,String,boolean,boolean,boolean,boolean,boolean)}
 * @noinspection JavaDoc
 */
public ManyToOneType(String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound){
  this(referencedEntityName,uniqueKeyPropertyName,lazy,unwrapProxy,isEmbeddedInXML,ignoreNotFound,false);
}
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isDefault(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isDefault(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * A Hibernate <tt>serializable</tt> type.
 * @param serializableClass The {@link java.io.Serializable} implementor class.
 * @return
 * @deprecated Use {@link SerializableType#SerializableType} instead.
 */
@SuppressWarnings({""unchecked""}) public static Type serializable(Class serializableClass){
  return new SerializableType(serializableClass);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#any} instead.
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type any(Type metaType,Type identifierType){
  return new AnyType(metaType,identifierType);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration"",""deprecation""}) public static Type entity(Class persistentClass){
  return entity(persistentClass.getName());
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type entity(String entityName){
  return new ManyToOneType(NoScope.INSTANCE,entityName);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass){
  return custom(userTypeClass,null);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass,String[] parameterNames,String[] parameterValues){
  return custom(userTypeClass,toProperties(parameterNames,parameterValues));
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration"",""unchecked""}) public static Type custom(Class userTypeClass,Properties parameters){
  if (CompositeUserType.class.isAssignableFrom(userTypeClass)) {
    return TypeFactory.customComponent(userTypeClass,parameters,NoScope.INSTANCE);
  }
 else {
    return TypeFactory.custom(userTypeClass,parameters,NoScope.INSTANCE);
  }
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param bytes a byte array
 * @return the Blob
 * @deprecated Use {@link LobHelper#createBlob(byte[])} instead.
 */
public static Blob createBlob(byte[] bytes){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(bytes));
}
"
"/** 
 * Create a new  {@link Blob}.
 * @param bytes a byte array
 * @param session The session in which the {@link Blob} will be used.
 * @return the Blob
 * @deprecated Use {@link LobHelper#createBlob(byte[])} instead.
 */
public static Blob createBlob(byte[] bytes,Session session){
  return getLobCreator(session).createBlob(bytes);
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @return the Blob
 * @deprecated Use {@link LobHelper#createBlob(InputStream,long)} instead.
 */
@Deprecated public static Blob createBlob(InputStream stream,int length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(stream,length));
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @return the Blob
 * @deprecated Use {@link LobHelper#createBlob(InputStream,long)} instead.
 */
@Deprecated public static Blob createBlob(InputStream stream,long length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(stream,length));
}
"
"/** 
 * Create a new  {@link Blob}.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @param session The session in which the {@link Blob} will be used.
 * @return the Blob
 * @deprecated Use {@link LobHelper#createBlob(InputStream,long)} instead.
 */
@Deprecated public static Blob createBlob(InputStream stream,long length,Session session){
  return getLobCreator(session).createBlob(stream,length);
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable. <p/> NOTE: this method will read the entire contents of the incoming stream in order to properly handle the  {@link Blob#length()} method.  If you do not want the stream read, use the{@link #createBlob(InputStream,long)} version instead.
 * @param stream a binary stream
 * @return the Blob
 * @throws IOException Indicates an I/O problem accessing the stream
 * @deprecated With no direct replacement.  Use {@link #createBlob(InputStream,long)} instead, passing in the length
 */
@Deprecated public static Blob createBlob(InputStream stream) throws IOException {
  ByteArrayOutputStream buffer=new ByteArrayOutputStream(stream.available());
  StreamUtils.copy(stream,buffer);
  return createBlob(buffer.toByteArray());
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param string The string data
 * @return The created {@link Clob}
 * @deprecated Use {@link LobHelper#createClob(String)} instead
 */
@Deprecated public static Clob createClob(String string){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(string));
}
"
"/** 
 * Create a new  {@link Clob}.
 * @param string The string data
 * @param session The session in which the {@link Clob} will be used.
 * @return The created {@link Clob}
 * @deprecated Use {@link LobHelper#createClob(String)} instead
 */
@Deprecated public static Clob createClob(String string,Session session){
  return getLobCreator(session).createClob(string);
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @return The created {@link Clob}
 * @deprecated Use {@link LobHelper#createClob(Reader,long)} instead
 */
@Deprecated public static Clob createClob(Reader reader,int length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(reader,length));
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @return The created {@link Clob}
 * @deprecated Use {@link LobHelper#createClob(Reader,long)} instead
 */
@Deprecated public static Clob createClob(Reader reader,long length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(reader,length));
}
"
"/** 
 * Create a new  {@link Clob}.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @param session The session in which the {@link Clob} will be used.
 * @return The created {@link Clob}
 * @deprecated Use {@link LobHelper#createClob(Reader,long)} instead
 */
@Deprecated public static Clob createClob(Reader reader,long length,Session session){
  return getLobCreator(session).createClob(reader,length);
}
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
public void evictQueries() throws HibernateException ;
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #renderOrderByStringTemplate(String,ColumnMapper,SessionFactoryImplementor,Dialect,SQLFunctionRegistry)} instead
 */
public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Set lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.impl.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
public void setFetchProfile(String name);
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.impl.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
public void setFetchProfile(String name);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.impl.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
public void setFetchProfile(String name);
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * A Hibernate <tt>serializable</tt> type.
 * @param serializableClass The {@link java.io.Serializable} implementor class.
 * @return
 * @deprecated Use {@link SerializableType#SerializableType} instead.
 */
@SuppressWarnings({""unchecked""}) public static Type serializable(Class serializableClass){
  return new SerializableType(serializableClass);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#any} instead.
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type any(Type metaType,Type identifierType){
  return new AnyType(metaType,identifierType);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration"",""deprecation""}) public static Type entity(Class persistentClass){
  return entity(persistentClass.getName());
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type entity(String entityName){
  return new ManyToOneType(NoScope.INSTANCE,entityName);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass){
  return custom(userTypeClass,null);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass,String[] parameterNames,String[] parameterValues){
  return custom(userTypeClass,toProperties(parameterNames,parameterValues));
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration"",""unchecked""}) public static Type custom(Class userTypeClass,Properties parameters){
  if (CompositeUserType.class.isAssignableFrom(userTypeClass)) {
    return TypeFactory.customComponent(userTypeClass,parameters,NoScope.INSTANCE);
  }
 else {
    return TypeFactory.custom(userTypeClass,parameters,NoScope.INSTANCE);
  }
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param cfg The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  formatter=(ConfigurationHelper.getBoolean(Environment.FORMAT_SQL,props) ? FormatStyle.DDL : FormatStyle.NONE).getFormatter();
  importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,props,DEFAULT_IMPORT_FILE);
}
"
"/** 
 * An import file, containing raw SQL statements to be executed.
 * @param filename The import file name.
 * @return this
 * @deprecated use {@link org.hibernate.cfg.Environment.HBM2DDL_IMPORT_FILE}
 */
public SchemaExport setImportFile(String filename){
  importFiles=filename;
  return this;
}
"
"/** 
 * A Hibernate <tt>serializable</tt> type.
 * @param serializableClass The {@link java.io.Serializable} implementor class.
 * @return
 * @deprecated Use {@link SerializableType#SerializableType} instead.
 */
@SuppressWarnings({""unchecked""}) public static Type serializable(Class serializableClass){
  return new SerializableType(serializableClass);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#any} instead.
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type any(Type metaType,Type identifierType){
  return new AnyType(metaType,identifierType);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration"",""deprecation""}) public static Type entity(Class persistentClass){
  return entity(persistentClass.getName());
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type entity(String entityName){
  return new ManyToOneType(NoScope.INSTANCE,entityName);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass){
  return custom(userTypeClass,null);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass,String[] parameterNames,String[] parameterValues){
  return custom(userTypeClass,toProperties(parameterNames,parameterValues));
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration"",""unchecked""}) public static Type custom(Class userTypeClass,Properties parameters){
  if (CompositeUserType.class.isAssignableFrom(userTypeClass)) {
    return TypeFactory.customComponent(userTypeClass,parameters,NoScope.INSTANCE);
  }
 else {
    return TypeFactory.custom(userTypeClass,parameters,NoScope.INSTANCE);
  }
}
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
public void evictQueries() throws HibernateException ;
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * @deprecated use getHbmfiles() rather
 */
public void setHbmfiles(List<NamedInputStream> hbmfiles){
  this.hbmfiles=hbmfiles;
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * @deprecated as of release 3.4.0.CR2, replaced by Hibernate Search's {@link org.hibernate.search.cfg.EventListenerRegister#enableHibernateSearch(EventListeners,Properties)}
 */
@SuppressWarnings(""unchecked"") @Deprecated public static void enableHibernateSearch(EventListeners eventListeners,Properties properties){
  String enableSearchListeners=properties.getProperty(""hibernate.search.autoregister_listeners"");
  if (""false"".equalsIgnoreCase(enableSearchListeners)) {
    log.info(""Property hibernate.search.autoregister_listeners is set to false."" + "" No attempt will be made to register Hibernate Search event listeners."");
    return;
  }
  Class searchEventListenerClass=attemptToLoadSearchEventListener();
  if (searchEventListenerClass == null) {
    log.info(""Unable to find {} on the classpath. Hibernate Search is not enabled."",FULL_TEXT_INDEX_EVENT_LISTENER_CLASS);
    return;
  }
  Object searchEventListener=instantiateEventListener(searchEventListenerClass);
{
    boolean present=false;
    PostInsertEventListener[] listeners=eventListeners.getPostInsertEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostInsertEventListener[] newListeners=new PostInsertEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostInsertEventListener)searchEventListener;
        eventListeners.setPostInsertEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostInsertEventListeners(new PostInsertEventListener[]{(PostInsertEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostUpdateEventListener[] listeners=eventListeners.getPostUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostUpdateEventListener[] newListeners=new PostUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostUpdateEventListener)searchEventListener;
        eventListeners.setPostUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostUpdateEventListeners(new PostUpdateEventListener[]{(PostUpdateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostDeleteEventListener[] listeners=eventListeners.getPostDeleteEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostDeleteEventListener[] newListeners=new PostDeleteEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostDeleteEventListener)searchEventListener;
        eventListeners.setPostDeleteEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostDeleteEventListeners(new PostDeleteEventListener[]{(PostDeleteEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRecreateEventListener[] listeners=eventListeners.getPostCollectionRecreateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRecreateEventListener[] newListeners=new PostCollectionRecreateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRecreateEventListener)searchEventListener;
        eventListeners.setPostCollectionRecreateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRecreateEventListeners(new PostCollectionRecreateEventListener[]{(PostCollectionRecreateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRemoveEventListener[] listeners=eventListeners.getPostCollectionRemoveEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRemoveEventListener[] newListeners=new PostCollectionRemoveEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRemoveEventListener)searchEventListener;
        eventListeners.setPostCollectionRemoveEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRemoveEventListeners(new PostCollectionRemoveEventListener[]{(PostCollectionRemoveEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionUpdateEventListener[] listeners=eventListeners.getPostCollectionUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionUpdateEventListener[] newListeners=new PostCollectionUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionUpdateEventListener)searchEventListener;
        eventListeners.setPostCollectionUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionUpdateEventListeners(new PostCollectionUpdateEventListener[]{(PostCollectionUpdateEventListener)searchEventListener});
    }
  }
}
"
"/** 
 * Copy the state of the given object onto the persistent object with the same identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If the given instance is unsaved or does not exist in the database, save it and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated use {@link org.hibernate.Session#merge(Object)}
 * @param object a transient instance with state to be copied
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(Object object) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the given identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If there is no database row with the given identifier, save the given instance and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated with no replacement
 * @param object a persistent or transient instance with state to be copied
 * @param id the identifier of the instance to copy to
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the same identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If the given instance is unsaved or does not exist in the database, save it and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated use {@link org.hibernate.Session#merge(String,Object)}
 * @param object a transient instance with state to be copied
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(String entityName,Object object) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the given identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If there is no database row with the given identifier, save the given instance and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated with no replacement
 * @param object a persistent or transient instance with state to be copied
 * @param id the identifier of the instance to copy to
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Execute a query.
 * @deprecated use {@link #createQuery}. {@link Query#list()}
 * @param query a query expressed in Hibernate's query language
 * @return a distinct list of instances (or arrays of instances)
 * @throws HibernateException
 */
public List find(String query) throws HibernateException ;
"
"/** 
 * Execute a query with bind parameters, binding a value to a ""?"" parameter in the query string.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#list()}
 * @param query the query string
 * @param value a value to be bound to a ""?"" placeholder (JDBC IN parameter).
 * @param type the Hibernate type of the value
 * @see org.hibernate.Hibernate for access to <tt>Type</tt> instances
 * @return a distinct list of instances (or arrays of instances)
 * @throws HibernateException
 */
public List find(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Execute a query with bind parameters, binding an array of values to ""?"" parameters in the query string.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#list()}
 * @param query the query string
 * @param values an array of values to be bound to the ""?"" placeholders (JDBC IN parameters).
 * @param types an array of Hibernate types of the values
 * @see org.hibernate.Hibernate for access to <tt>Type</tt> instances
 * @return a distinct list of instances
 * @throws HibernateException
 */
public List find(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. If the query has multiple return values, values will be returned in an array of type <tt>Object[].</tt><br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}. {@link Query#iterate}
 * @param query the query string
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. Write the given value to ""?"" in the query string. If the query has multiple return values, values will be returned in an array of type <tt>Object[]</tt>.<br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#iterate}
 * @param query the query string
 * @param value a value to be witten to a ""?"" placeholder in the query string
 * @param type the hibernate type of value
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. Write the given values to ""?"" in the query string. If the query has multiple return values, values will be returned in an array of type <tt>Object[]</tt>.<br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#iterate}
 * @param query the query string
 * @param values a list of values to be written to ""?"" placeholders in the query
 * @param types a list of Hibernate types of the values
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element. Filters allow efficient access to very large lazy collections. (Executing the filter does not initialize the collection.)
 * @deprecated use {@link #createFilter(Object,String)}. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @return Collection the resulting collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element.
 * @deprecated use {@link #createFilter(Object,String)}.setXYZ. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @param value a value to be witten to a ""?"" placeholder in the query string
 * @param type the hibernate type of value
 * @return Collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter,Object value,Type type) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. Bind the given parameters to ""?"" placeholders. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element.
 * @deprecated use {@link #createFilter(Object,String)}.setXYZ. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @param values a list of values to be written to ""?"" placeholders in the query
 * @param types a list of Hibernate types of the values
 * @return Collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @param value a value to be witten to a ""?"" placeholder in the query string.
 * @param type the hibernate type of value.
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @param values a list of values to be written to ""?"" placeholders in the query.
 * @param types a list of Hibernate types of the values
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Create a new instance of <tt>Query</tt> for the given SQL string. <p/> Returned instances should all be  {@link org.hibernate.SQLQuery}.
 * @param sql a query expressed in SQL
 * @param returnAlias a table alias that appears inside <tt>{}</tt> in the SQL string
 * @param returnClass the returned persistent class
 * @deprecated use {@link org.hibernate.SQLQuery#addRoot} or {@link org.hibernate.SQLQuery#addEntity} variantsinstead to define the alias/class
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Query createSQLQuery(String sql,String returnAlias,Class returnClass);
"
"/** 
 * Create a new instance of <tt>Query</tt> for the given SQL string. <p/> Returned instances should all be  {@link org.hibernate.SQLQuery}.
 * @param sql a query expressed in SQL
 * @param returnAliases an array of table aliases that appear inside <tt>{}</tt> in the SQL string
 * @param returnClasses the returned persistent classes
 * @deprecated use {@link org.hibernate.SQLQuery#addRoot} or {@link org.hibernate.SQLQuery#addEntity} variantsinstead to define the aliases/classes
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Query createSQLQuery(String sql,String[] returnAliases,Class[] returnClasses);
"
"/** 
 * Persist the given transient instance, using the given identifier.  This operation  cascades to associated instances if the association is mapped with  <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a transient instance of a persistent class
 * @param id an unused valid identifier
 * @throws HibernateException
 */
public void save(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Persist the given transient instance, using the given identifier. This operation  cascades to associated instances if the association is mapped with  <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a transient instance of a persistent class
 * @param id an unused valid identifier
 * @throws HibernateException
 */
public void save(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Update the persistent state associated with the given identifier. An exception is thrown if there is a persistent instance with the same identifier in the current session. This operation cascades to associated instances  if the association is mapped with <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a detached instance containing updated state
 * @param id identifier of persistent instance
 * @throws HibernateException
 */
public void update(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Update the persistent state associated with the given identifier. An exception is thrown if there is a persistent instance with the same identifier in the current session. This operation cascades to associated instances  if the association is mapped with <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a detached instance containing updated state
 * @param id identifier of persistent instance
 * @throws HibernateException
 */
public void update(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Apply a constraint expressed in SQL, with the given JDBC parameters. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String,Object[],Type[])}
 * @param sql
 * @param values
 * @param types
 * @return Criterion
 */
public static Criterion sql(String sql,Object[] values,Type[] types){
  return new SQLCriterion(sql,values,types);
}
"
"/** 
 * Apply a constraint expressed in SQL, with the given JDBC parameter. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String,Object,Type)}
 * @param sql
 * @param value
 * @param type
 * @return Criterion
 */
public static Criterion sql(String sql,Object value,Type type){
  return new SQLCriterion(sql,new Object[]{value},new Type[]{type});
}
"
"/** 
 * Apply a constraint expressed in SQL. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String)}
 * @param sql
 * @return Criterion
 */
public static Criterion sql(String sql){
  return new SQLCriterion(sql,ArrayHelper.EMPTY_OBJECT_ARRAY,ArrayHelper.EMPTY_TYPE_ARRAY);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Allow access to the id generator factory, though this is only needed/allowed from configuration.
 * @return
 * @deprecated temporary solution 
 */
public IdentifierGeneratorFactory getIdentifierGeneratorFactory();
"
"/** 
 * This form used from annotations (?).  Essentially the same as the above using a resultset-mapping reference, but without cacheMode, readOnly, and comment. FIXME: annotations do not use it, so it can be remove from my POV
 * @deprecated
 * @param query The sql query string
 * @param resultSetRef The result-set-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 */
public NamedSQLQueryDefinition(String query,String resultSetRef,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,Map parameterTypes,boolean callable){
  this(query,resultSetRef,querySpaces,cacheable,cacheRegion,timeout,fetchSize,flushMode,null,false,null,parameterTypes,callable);
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.impl.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
public void setFetchProfile(String name);
"
"/** 
 * Getter for property 'source'.  This is the session from which the event originated. <p/> Some of the pre-* events had previous exposed the event source using getSource() because they had not originally extended from {@link AbstractEvent}.
 * @return Value for property 'source'.
 * @deprecated Use {@link #getSession} instead
 */
public EventSource getSource(){
  return getSession();
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * Creates a single node AST. <p/> TODO : this is silly, remove it...
 * @param astFactory The factory.
 * @param type The node type.
 * @param text The node text.
 * @return AST - A single node tree.
 * @deprecated silly
 */
public static AST create(ASTFactory astFactory,int type,String text){
  return astFactory.create(type,text);
}
"
"/** 
 * Get the name of a constant defined on the given class which has the given value. <p/> Note, if multiple constants have this value, the first will be returned which is known to be different on different JVM implementations.
 * @param owner The class which defines the constant
 * @param value The value of the constant.
 * @return The token type name, *or* the integer value if the name could not be found.
 * @deprecated Use #getTokenTypeName instead
 */
public static String getConstantName(Class owner,int value){
  return getTokenTypeName(owner,value);
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return new Long(value);
  }
 else   if (clazz == Integer.class) {
    return new Integer((int)value);
  }
 else   if (clazz == Short.class) {
    return new Short((short)value);
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@SuppressWarnings({""UnnecessaryBoxing""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  String optimizerClassName;
  if (NONE.equals(type)) {
    optimizerClassName=NoopOptimizer.class.getName();
  }
 else   if (HILO.equals(type)) {
    optimizerClassName=HiLoOptimizer.class.getName();
  }
 else   if (LEGACY_HILO.equals(type)) {
    optimizerClassName=LegacyHiLoAlgorithmOptimizer.class.getName();
  }
 else   if (POOL.equals(type)) {
    optimizerClassName=PooledOptimizer.class.getName();
  }
 else   if (POOL_LO.equals(type)) {
    optimizerClassName=PooledLoOptimizer.class.getName();
  }
 else {
    optimizerClassName=type;
  }
  try {
    Class optimizerClass=ReflectHelper.classForName(optimizerClassName);
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    log.warn(""Unable to instantiate specified optimizer [{}], falling back to noop"",type);
  }
  return new NoopOptimizer(returnClass,incrementSize);
}
"
"/** 
 * Allow injection of the dialect to use.
 * @param dialect The dialect
 * @deprecated The intention is that Dialect should be required to be specified up-front and it would then getctor injected.
 */
public void setDialect(Dialect dialect);
"
"/** 
 * Obtain a JDBC connection
 * @deprecated Obtain connections from {@link ConnectionProvider} instead
 */
public Connection openConnection() throws HibernateException ;
"
"/** 
 * Dispose of the JDBC connection
 * @deprecated Obtain connections from {@link ConnectionProvider} instead
 */
public void closeConnection(Connection conn) throws HibernateException ;
"
"/** 
 * Load an entity instance. If <tt>optionalObject</tt> is supplied, load the entity state into the given (uninitialized) object.
 * @deprecated use {@link #load(java.io.Serializable,Object,SessionImplementor,LockOptions)} instead.
 * @noinspection JavaDoc
 */
public Object load(Serializable id,Object optionalObject,SessionImplementor session) throws HibernateException ;
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * Create a class instance initialized with the given identifier
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Serializable getIdentifier(Object object,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @param entityMode The entity mode
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Serializable getIdentifier(Object object,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @param entityMode The entity mode
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Create a class instance initialized with the given identifier
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Set the identifier and version of the given instance back to its ""unsaved"" value.
 * @param entity The entity instance
 * @param currentId The currently assigned identifier value.
 * @param currentVersion The currently assigned version value.
 * @param entityMode The entity mode represented by the entity instance.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion,EntityMode entityMode);
"
"/** 
 * @deprecated
 */
public void setAttributeValue(String name,String value){
  target().setAttributeValue(name,value);
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(QName qName,String value){
  target().setAttributeValue(qName,value);
}
"
"/** 
 * Get the current lock mode
 * @return LockMode
 * @deprecated Instead use getLockOptions
 */
public LockMode getLockMode(){
  return lockOptions.getLockMode();
}
"
"/** 
 * Set the lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public Select setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #renderOrderByStringTemplate(String,ColumnMapper,SessionFactoryImplementor,Dialect,SQLFunctionRegistry)} instead
 */
public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param cfg The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  formatter=(ConfigurationHelper.getBoolean(Environment.FORMAT_SQL,props) ? FormatStyle.DDL : FormatStyle.NONE).getFormatter();
  importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,props,DEFAULT_IMPORT_FILE);
}
"
"/** 
 * An import file, containing raw SQL statements to be executed.
 * @param filename The import file name.
 * @return this
 * @deprecated use {@link org.hibernate.cfg.Environment.HBM2DDL_IMPORT_FILE}
 */
public SchemaExport setImportFile(String filename){
  importFiles=filename;
  return this;
}
"
"/** 
 * Set lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(String name,String value){
  element.setAttributeValue(name,value);
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(QName qName,String value){
  element.setAttributeValue(qName,value);
}
"
"/** 
 * Create an entity instance initialized with the given identifier.
 * @param id The identifier value for the entity to be instantiated.
 * @return The instantiated entity.
 * @throws HibernateException
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id) throws HibernateException ;
"
"/** 
 * Extract the identifier value from the given entity.
 * @param entity The entity from which to extract the identifier value.
 * @return The identifier value.
 * @throws HibernateException If the entity does not define an identifier property, or anerror occurs accessing its value.
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead.
 */
public Serializable getIdentifier(Object entity) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id) throws HibernateException ;
"
"/** 
 * Inject the given identifier and version into the entity, in order to ""roll back"" to their original values.
 * @param entity The entity for which to reset the id/version values
 * @param currentId The identifier value to inject into the entity.
 * @param currentVersion The version value to inject into the entity.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion);
"
"/** 
 * @deprecated Use {@link #nullSafeGet(ResultSet,String,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public T nullSafeGet(ResultSet rs,String name) throws HibernateException, SQLException ;
"
"/** 
 * DO NOT USER THIS FORM!
 * @deprecated Use {@link #get(ResultSet,String,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public Object get(ResultSet rs,String name) throws HibernateException, SQLException ;
"
"/** 
 * DO NOT USE THIS FORM!
 * @deprecated Use {@link #nullSafeSet(PreparedStatement,Object,int,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public void nullSafeSet(PreparedStatement st,T value,int index) throws HibernateException, SQLException ;
"
"/** 
 * DO NOT USE THIS FORM!
 * @deprecated Use {@link #set(PreparedStatement,Object,int,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public void set(PreparedStatement st,T value,int index) throws HibernateException, SQLException ;
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * Log the given warning and all of its nested warnings, preceded with the  {@link #DEFAULT_WARNING_MSG default message}
 * @param warning The warning to log
 * @deprecated Use {@link #walkWarnings} instead
 */
@Deprecated() @SuppressWarnings({""UnusedDeclaration""}) public static void logWarnings(SQLWarning warning){
  walkWarnings(warning,STANDARD_WARNING_HANDLER);
}
"
"/** 
 * Log the given warning and all of its nested warnings, preceded with the given message
 * @param warning The warning to log
 * @param message The prologue message
 * @deprecated Use {@link #walkWarnings} instead
 */
@Deprecated() @SuppressWarnings({""UnusedDeclaration""}) public static void logWarnings(SQLWarning warning,String message){
  final WarningHandler handler=StringHelper.isNotEmpty(message) ? new StandardWarningHandler(message) : STANDARD_WARNING_HANDLER;
  walkWarnings(warning,handler);
}
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
public void evictQueries() throws HibernateException ;
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param cfg The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  formatter=(ConfigurationHelper.getBoolean(Environment.FORMAT_SQL,props) ? FormatStyle.DDL : FormatStyle.NONE).getFormatter();
  importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,props,DEFAULT_IMPORT_FILE);
}
"
"/** 
 * An import file, containing raw SQL statements to be executed.
 * @param filename The import file name.
 * @return this
 * @deprecated use {@link org.hibernate.cfg.Environment.HBM2DDL_IMPORT_FILE}
 */
public SchemaExport setImportFile(String filename){
  importFiles=filename;
  return this;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.impl.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
public void setFetchProfile(String name);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.impl.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
public void setFetchProfile(String name);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
@Deprecated public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
@Deprecated public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
@Deprecated public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * @deprecated as of release 3.4.0.CR2, replaced by Hibernate Search's {@link org.hibernate.search.cfg.EventListenerRegister#enableHibernateSearch(EventListeners,Properties)}
 */
@SuppressWarnings(""unchecked"") @Deprecated public static void enableHibernateSearch(EventListeners eventListeners,Properties properties){
  String enableSearchListeners=properties.getProperty(""hibernate.search.autoregister_listeners"");
  if (""false"".equalsIgnoreCase(enableSearchListeners)) {
    LOG.willNotRegisterListeners();
    return;
  }
  Class searchEventListenerClass=attemptToLoadSearchEventListener();
  if (searchEventListenerClass == null) {
    LOG.unableToFindListenerClass(FULL_TEXT_INDEX_EVENT_LISTENER_CLASS);
    return;
  }
  Object searchEventListener=instantiateEventListener(searchEventListenerClass);
{
    boolean present=false;
    PostInsertEventListener[] listeners=eventListeners.getPostInsertEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostInsertEventListener[] newListeners=new PostInsertEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostInsertEventListener)searchEventListener;
        eventListeners.setPostInsertEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostInsertEventListeners(new PostInsertEventListener[]{(PostInsertEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostUpdateEventListener[] listeners=eventListeners.getPostUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostUpdateEventListener[] newListeners=new PostUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostUpdateEventListener)searchEventListener;
        eventListeners.setPostUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostUpdateEventListeners(new PostUpdateEventListener[]{(PostUpdateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostDeleteEventListener[] listeners=eventListeners.getPostDeleteEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostDeleteEventListener[] newListeners=new PostDeleteEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostDeleteEventListener)searchEventListener;
        eventListeners.setPostDeleteEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostDeleteEventListeners(new PostDeleteEventListener[]{(PostDeleteEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRecreateEventListener[] listeners=eventListeners.getPostCollectionRecreateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRecreateEventListener[] newListeners=new PostCollectionRecreateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRecreateEventListener)searchEventListener;
        eventListeners.setPostCollectionRecreateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRecreateEventListeners(new PostCollectionRecreateEventListener[]{(PostCollectionRecreateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRemoveEventListener[] listeners=eventListeners.getPostCollectionRemoveEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRemoveEventListener[] newListeners=new PostCollectionRemoveEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRemoveEventListener)searchEventListener;
        eventListeners.setPostCollectionRemoveEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRemoveEventListeners(new PostCollectionRemoveEventListener[]{(PostCollectionRemoveEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionUpdateEventListener[] listeners=eventListeners.getPostCollectionUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionUpdateEventListener[] newListeners=new PostCollectionUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionUpdateEventListener)searchEventListener;
        eventListeners.setPostCollectionUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionUpdateEventListeners(new PostCollectionUpdateEventListener[]{(PostCollectionUpdateEventListener)searchEventListener});
    }
  }
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
@Deprecated public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
@Deprecated public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
@Deprecated public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
@Deprecated public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return new Long(value);
  }
 else   if (clazz == Integer.class) {
    return new Integer((int)value);
  }
 else   if (clazz == Short.class) {
    return new Short((short)value);
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  String optimizerClassName;
  if (NONE.equals(type)) {
    optimizerClassName=NoopOptimizer.class.getName();
  }
 else   if (HILO.equals(type)) {
    optimizerClassName=HiLoOptimizer.class.getName();
  }
 else   if (LEGACY_HILO.equals(type)) {
    optimizerClassName=LegacyHiLoAlgorithmOptimizer.class.getName();
  }
 else   if (POOL.equals(type)) {
    optimizerClassName=PooledOptimizer.class.getName();
  }
 else   if (POOL_LO.equals(type)) {
    optimizerClassName=PooledLoOptimizer.class.getName();
  }
 else {
    optimizerClassName=type;
  }
  try {
    Class optimizerClass=ReflectHelper.classForName(optimizerClassName);
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return new NoopOptimizer(returnClass,incrementSize);
}
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * @deprecated as of release 3.4.0.CR2, replaced by Hibernate Search's {@link org.hibernate.search.cfg.EventListenerRegister#enableHibernateSearch(EventListeners,Properties)}
 */
@SuppressWarnings(""unchecked"") @Deprecated public static void enableHibernateSearch(EventListeners eventListeners,Properties properties){
  String enableSearchListeners=properties.getProperty(""hibernate.search.autoregister_listeners"");
  if (""false"".equalsIgnoreCase(enableSearchListeners)) {
    LOG.willNotRegisterListeners();
    return;
  }
  Class searchEventListenerClass=attemptToLoadSearchEventListener();
  if (searchEventListenerClass == null) {
    LOG.unableToFindListenerClass(FULL_TEXT_INDEX_EVENT_LISTENER_CLASS);
    return;
  }
  Object searchEventListener=instantiateEventListener(searchEventListenerClass);
{
    boolean present=false;
    PostInsertEventListener[] listeners=eventListeners.getPostInsertEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostInsertEventListener[] newListeners=new PostInsertEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostInsertEventListener)searchEventListener;
        eventListeners.setPostInsertEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostInsertEventListeners(new PostInsertEventListener[]{(PostInsertEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostUpdateEventListener[] listeners=eventListeners.getPostUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostUpdateEventListener[] newListeners=new PostUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostUpdateEventListener)searchEventListener;
        eventListeners.setPostUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostUpdateEventListeners(new PostUpdateEventListener[]{(PostUpdateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostDeleteEventListener[] listeners=eventListeners.getPostDeleteEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostDeleteEventListener[] newListeners=new PostDeleteEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostDeleteEventListener)searchEventListener;
        eventListeners.setPostDeleteEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostDeleteEventListeners(new PostDeleteEventListener[]{(PostDeleteEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRecreateEventListener[] listeners=eventListeners.getPostCollectionRecreateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRecreateEventListener[] newListeners=new PostCollectionRecreateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRecreateEventListener)searchEventListener;
        eventListeners.setPostCollectionRecreateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRecreateEventListeners(new PostCollectionRecreateEventListener[]{(PostCollectionRecreateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRemoveEventListener[] listeners=eventListeners.getPostCollectionRemoveEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRemoveEventListener[] newListeners=new PostCollectionRemoveEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRemoveEventListener)searchEventListener;
        eventListeners.setPostCollectionRemoveEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRemoveEventListeners(new PostCollectionRemoveEventListener[]{(PostCollectionRemoveEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionUpdateEventListener[] listeners=eventListeners.getPostCollectionUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionUpdateEventListener[] newListeners=new PostCollectionUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionUpdateEventListener)searchEventListener;
        eventListeners.setPostCollectionUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionUpdateEventListeners(new PostCollectionUpdateEventListener[]{(PostCollectionUpdateEventListener)searchEventListener});
    }
  }
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * A Hibernate <tt>serializable</tt> type.
 * @param serializableClass The {@link java.io.Serializable} implementor class.
 * @return
 * @deprecated Use {@link SerializableType#SerializableType} instead.
 */
@SuppressWarnings({""unchecked""}) public static Type serializable(Class serializableClass){
  return new SerializableType(serializableClass);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#any} instead.
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type any(Type metaType,Type identifierType){
  return new AnyType(metaType,identifierType);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration"",""deprecation""}) public static Type entity(Class persistentClass){
  return entity(persistentClass.getName());
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type entity(String entityName){
  return new ManyToOneType(NoScope.INSTANCE,entityName);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass){
  return custom(userTypeClass,null);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass,String[] parameterNames,String[] parameterValues){
  return custom(userTypeClass,toProperties(parameterNames,parameterValues));
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration"",""unchecked""}) public static Type custom(Class userTypeClass,Properties parameters){
  if (CompositeUserType.class.isAssignableFrom(userTypeClass)) {
    return TypeFactory.customComponent(userTypeClass,parameters,NoScope.INSTANCE);
  }
 else {
    return TypeFactory.custom(userTypeClass,parameters,NoScope.INSTANCE);
  }
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param bytes a byte array
 * @return the Blob
 * @deprecated Use {@link LobHelper#createBlob(byte[])} instead.
 */
public static Blob createBlob(byte[] bytes){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(bytes));
}
"
"/** 
 * Create a new  {@link Blob}.
 * @param bytes a byte array
 * @param session The session in which the {@link Blob} will be used.
 * @return the Blob
 * @deprecated Use {@link LobHelper#createBlob(byte[])} instead on the {@link LobHelper} obtained from{@link Session#getLobHelper()}
 */
public static Blob createBlob(byte[] bytes,Session session){
  return getLobCreator(session).createBlob(bytes);
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @return the Blob
 * @deprecated Use {@link LobHelper#createBlob(InputStream,long)} instead.
 */
@Deprecated public static Blob createBlob(InputStream stream,int length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(stream,length));
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @return the Blob
 * @deprecated Use {@link LobHelper#createBlob(InputStream,long)} instead.
 */
@Deprecated public static Blob createBlob(InputStream stream,long length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(stream,length));
}
"
"/** 
 * Create a new  {@link Blob}.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @param session The session in which the {@link Blob} will be used.
 * @return the Blob
 * @deprecated Use {@link LobHelper#createBlob(InputStream,long)} instead.
 */
@Deprecated public static Blob createBlob(InputStream stream,long length,Session session){
  return getLobCreator(session).createBlob(stream,length);
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable. <p/> NOTE: this method will read the entire contents of the incoming stream in order to properly handle the  {@link Blob#length()} method.  If you do not want the stream read, use the{@link #createBlob(InputStream,long)} version instead.
 * @param stream a binary stream
 * @return the Blob
 * @throws IOException Indicates an I/O problem accessing the stream
 * @deprecated With no direct replacement.  Use {@link #createBlob(InputStream,long)} instead, passing in the length
 */
@Deprecated public static Blob createBlob(InputStream stream) throws IOException {
  ByteArrayOutputStream buffer=new ByteArrayOutputStream(stream.available());
  StreamUtils.copy(stream,buffer);
  return createBlob(buffer.toByteArray());
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param string The string data
 * @return The created {@link Clob}
 * @deprecated Use {@link LobHelper#createClob(String)} instead
 */
@Deprecated public static Clob createClob(String string){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(string));
}
"
"/** 
 * Create a new  {@link Clob}.
 * @param string The string data
 * @param session The session in which the {@link Clob} will be used.
 * @return The created {@link Clob}
 * @deprecated Use {@link LobHelper#createClob(String)} instead on the {@link LobHelper} obtained from{@link Session#getLobHelper()}
 */
@Deprecated public static Clob createClob(String string,Session session){
  return getLobCreator(session).createClob(string);
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @return The created {@link Clob}
 * @deprecated Use {@link LobHelper#createClob(Reader,long)} instead
 */
@Deprecated public static Clob createClob(Reader reader,int length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(reader,length));
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @return The created {@link Clob}
 * @deprecated Use {@link LobHelper#createClob(Reader,long)} instead
 */
@Deprecated public static Clob createClob(Reader reader,long length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(reader,length));
}
"
"/** 
 * Create a new  {@link Clob}.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @param session The session in which the {@link Clob} will be used.
 * @return The created {@link Clob}
 * @deprecated Use {@link LobHelper#createClob(Reader,long)} instead
 */
@Deprecated public static Clob createClob(Reader reader,long length,Session session){
  return getLobCreator(session).createClob(reader,length);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param cfg The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  formatter=(ConfigurationHelper.getBoolean(Environment.FORMAT_SQL,props) ? FormatStyle.DDL : FormatStyle.NONE).getFormatter();
  importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,props,DEFAULT_IMPORT_FILE);
}
"
"/** 
 * An import file, containing raw SQL statements to be executed.
 * @param filename The import file name.
 * @return this
 * @deprecated use {@link org.hibernate.cfg.Environment.HBM2DDL_IMPORT_FILE}
 */
@Deprecated public SchemaExport setImportFile(String filename){
  importFiles=filename;
  return this;
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * Log the given warning and all of its nested warnings, preceded with the  {@link #DEFAULT_WARNING_MSG default message}
 * @param warning The warning to log
 * @deprecated Use {@link #walkWarnings} instead
 */
@Deprecated() @SuppressWarnings({""UnusedDeclaration""}) public static void logWarnings(SQLWarning warning){
  walkWarnings(warning,STANDARD_WARNING_HANDLER);
}
"
"/** 
 * Log the given warning and all of its nested warnings, preceded with the given message
 * @param warning The warning to log
 * @param message The prologue message
 * @deprecated Use {@link #walkWarnings} instead
 */
@Deprecated() @SuppressWarnings({""UnusedDeclaration""}) public static void logWarnings(SQLWarning warning,String message){
  final WarningHandler handler=StringHelper.isNotEmpty(message) ? new StandardWarningHandler(message) : STANDARD_WARNING_HANDLER;
  walkWarnings(warning,handler);
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
@Deprecated public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return new Long(value);
  }
 else   if (clazz == Integer.class) {
    return new Integer((int)value);
  }
 else   if (clazz == Short.class) {
    return new Short((short)value);
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  String optimizerClassName;
  if (NONE.equals(type)) {
    optimizerClassName=NoopOptimizer.class.getName();
  }
 else   if (HILO.equals(type)) {
    optimizerClassName=HiLoOptimizer.class.getName();
  }
 else   if (LEGACY_HILO.equals(type)) {
    optimizerClassName=LegacyHiLoAlgorithmOptimizer.class.getName();
  }
 else   if (POOL.equals(type)) {
    optimizerClassName=PooledOptimizer.class.getName();
  }
 else   if (POOL_LO.equals(type)) {
    optimizerClassName=PooledLoOptimizer.class.getName();
  }
 else {
    optimizerClassName=type;
  }
  try {
    Class optimizerClass=ReflectHelper.classForName(optimizerClassName);
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return new NoopOptimizer(returnClass,incrementSize);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param cfg The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  formatter=(ConfigurationHelper.getBoolean(Environment.FORMAT_SQL,props) ? FormatStyle.DDL : FormatStyle.NONE).getFormatter();
  importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,props,DEFAULT_IMPORT_FILE);
}
"
"/** 
 * An import file, containing raw SQL statements to be executed.
 * @param filename The import file name.
 * @return this
 * @deprecated use {@link org.hibernate.cfg.Environment.HBM2DDL_IMPORT_FILE}
 */
@Deprecated public SchemaExport setImportFile(String filename){
  importFiles=filename;
  return this;
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * Log the given warning and all of its nested warnings, preceded with the  {@link #DEFAULT_WARNING_MSG default message}
 * @param warning The warning to log
 * @deprecated Use {@link #walkWarnings} instead
 */
@Deprecated() @SuppressWarnings({""UnusedDeclaration""}) public static void logWarnings(SQLWarning warning){
  walkWarnings(warning,STANDARD_WARNING_HANDLER);
}
"
"/** 
 * Log the given warning and all of its nested warnings, preceded with the given message
 * @param warning The warning to log
 * @param message The prologue message
 * @deprecated Use {@link #walkWarnings} instead
 */
@Deprecated() @SuppressWarnings({""UnusedDeclaration""}) public static void logWarnings(SQLWarning warning,String message){
  final WarningHandler handler=StringHelper.isNotEmpty(message) ? new StandardWarningHandler(message) : STANDARD_WARNING_HANDLER;
  walkWarnings(warning,handler);
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
@Deprecated public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
@Deprecated public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
@Deprecated public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param cfg The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  formatter=(ConfigurationHelper.getBoolean(Environment.FORMAT_SQL,props) ? FormatStyle.DDL : FormatStyle.NONE).getFormatter();
  importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,props,DEFAULT_IMPORT_FILE);
}
"
"/** 
 * An import file, containing raw SQL statements to be executed.
 * @param filename The import file name.
 * @return this
 * @deprecated use {@link org.hibernate.cfg.Environment.HBM2DDL_IMPORT_FILE}
 */
@Deprecated public SchemaExport setImportFile(String filename){
  importFiles=filename;
  return this;
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * A Hibernate <tt>serializable</tt> type.
 * @param serializableClass The {@link java.io.Serializable} implementor class.
 * @return
 * @deprecated Use {@link SerializableType#SerializableType} instead.
 */
@SuppressWarnings({""unchecked""}) public static Type serializable(Class serializableClass){
  return new SerializableType(serializableClass);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#any} instead.
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type any(Type metaType,Type identifierType){
  return new AnyType(metaType,identifierType);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration"",""deprecation""}) public static Type entity(Class persistentClass){
  return entity(persistentClass.getName());
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type entity(String entityName){
  return new ManyToOneType(NoScope.INSTANCE,entityName);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass){
  return custom(userTypeClass,null);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass,String[] parameterNames,String[] parameterValues){
  return custom(userTypeClass,toProperties(parameterNames,parameterValues));
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration"",""unchecked""}) public static Type custom(Class userTypeClass,Properties parameters){
  if (CompositeUserType.class.isAssignableFrom(userTypeClass)) {
    return TypeFactory.customComponent(userTypeClass,parameters,NoScope.INSTANCE);
  }
 else {
    return TypeFactory.custom(userTypeClass,parameters,NoScope.INSTANCE);
  }
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param bytes a byte array
 * @return the Blob
 * @deprecated Use {@link LobHelper#createBlob(byte[])} instead.
 */
public static Blob createBlob(byte[] bytes){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(bytes));
}
"
"/** 
 * Create a new  {@link Blob}.
 * @param bytes a byte array
 * @param session The session in which the {@link Blob} will be used.
 * @return the Blob
 * @deprecated Use {@link LobHelper#createBlob(byte[])} instead on the {@link LobHelper} obtained from{@link Session#getLobHelper()}
 */
public static Blob createBlob(byte[] bytes,Session session){
  return getLobCreator(session).createBlob(bytes);
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @return the Blob
 * @deprecated Use {@link LobHelper#createBlob(InputStream,long)} instead.
 */
@Deprecated public static Blob createBlob(InputStream stream,int length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(stream,length));
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @return the Blob
 * @deprecated Use {@link LobHelper#createBlob(InputStream,long)} instead.
 */
@Deprecated public static Blob createBlob(InputStream stream,long length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createBlob(stream,length));
}
"
"/** 
 * Create a new  {@link Blob}.
 * @param stream a binary stream
 * @param length the number of bytes in the stream
 * @param session The session in which the {@link Blob} will be used.
 * @return the Blob
 * @deprecated Use {@link LobHelper#createBlob(InputStream,long)} instead.
 */
@Deprecated public static Blob createBlob(InputStream stream,long length,Session session){
  return getLobCreator(session).createBlob(stream,length);
}
"
"/** 
 * Create a new  {@link Blob}. The returned object will be initially immutable. <p/> NOTE: this method will read the entire contents of the incoming stream in order to properly handle the  {@link Blob#length()} method.  If you do not want the stream read, use the{@link #createBlob(InputStream,long)} version instead.
 * @param stream a binary stream
 * @return the Blob
 * @throws IOException Indicates an I/O problem accessing the stream
 * @deprecated With no direct replacement.  Use {@link #createBlob(InputStream,long)} instead, passing in the length
 */
@Deprecated public static Blob createBlob(InputStream stream) throws IOException {
  ByteArrayOutputStream buffer=new ByteArrayOutputStream(stream.available());
  StreamUtils.copy(stream,buffer);
  return createBlob(buffer.toByteArray());
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param string The string data
 * @return The created {@link Clob}
 * @deprecated Use {@link LobHelper#createClob(String)} instead
 */
@Deprecated public static Clob createClob(String string){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(string));
}
"
"/** 
 * Create a new  {@link Clob}.
 * @param string The string data
 * @param session The session in which the {@link Clob} will be used.
 * @return The created {@link Clob}
 * @deprecated Use {@link LobHelper#createClob(String)} instead on the {@link LobHelper} obtained from{@link Session#getLobHelper()}
 */
@Deprecated public static Clob createClob(String string,Session session){
  return getLobCreator(session).createClob(string);
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @return The created {@link Clob}
 * @deprecated Use {@link LobHelper#createClob(Reader,long)} instead
 */
@Deprecated public static Clob createClob(Reader reader,int length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(reader,length));
}
"
"/** 
 * Create a new  {@link Clob}. The returned object will be initially immutable.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @return The created {@link Clob}
 * @deprecated Use {@link LobHelper#createClob(Reader,long)} instead
 */
@Deprecated public static Clob createClob(Reader reader,long length){
  return NonContextualLobCreator.INSTANCE.wrap(NonContextualLobCreator.INSTANCE.createClob(reader,length));
}
"
"/** 
 * Create a new  {@link Clob}.
 * @param reader a character stream
 * @param length the number of characters in the stream
 * @param session The session in which the {@link Clob} will be used.
 * @return The created {@link Clob}
 * @deprecated Use {@link LobHelper#createClob(Reader,long)} instead
 */
@Deprecated public static Clob createClob(Reader reader,long length,Session session){
  return getLobCreator(session).createClob(reader,length);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * A Hibernate <tt>serializable</tt> type.
 * @param serializableClass The {@link java.io.Serializable} implementor class.
 * @return
 * @deprecated Use {@link SerializableType#SerializableType} instead.
 */
@SuppressWarnings({""unchecked""}) public static Type serializable(Class serializableClass){
  return new SerializableType(serializableClass);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#any} instead.
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type any(Type metaType,Type identifierType){
  return new AnyType(metaType,identifierType);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration"",""deprecation""}) public static Type entity(Class persistentClass){
  return entity(persistentClass.getName());
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type entity(String entityName){
  return new ManyToOneType(NoScope.INSTANCE,entityName);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass){
  return custom(userTypeClass,null);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass,String[] parameterNames,String[] parameterValues){
  return custom(userTypeClass,toProperties(parameterNames,parameterValues));
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration"",""unchecked""}) public static Type custom(Class userTypeClass,Properties parameters){
  if (CompositeUserType.class.isAssignableFrom(userTypeClass)) {
    return TypeFactory.customComponent(userTypeClass,parameters,NoScope.INSTANCE);
  }
 else {
    return TypeFactory.custom(userTypeClass,parameters,NoScope.INSTANCE);
  }
}
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
public void evictQueries() throws HibernateException ;
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
@Deprecated public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
@Deprecated public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
@Deprecated public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * @deprecated as of release 3.4.0.CR2, replaced by Hibernate Search's {@link org.hibernate.search.cfg.EventListenerRegister#enableHibernateSearch(EventListeners,Properties)}
 */
@SuppressWarnings(""unchecked"") @Deprecated public static void enableHibernateSearch(EventListeners eventListeners,Properties properties){
  String enableSearchListeners=properties.getProperty(""hibernate.search.autoregister_listeners"");
  if (""false"".equalsIgnoreCase(enableSearchListeners)) {
    LOG.willNotRegisterListeners();
    return;
  }
  Class searchEventListenerClass=attemptToLoadSearchEventListener();
  if (searchEventListenerClass == null) {
    LOG.unableToFindListenerClass(FULL_TEXT_INDEX_EVENT_LISTENER_CLASS);
    return;
  }
  Object searchEventListener=instantiateEventListener(searchEventListenerClass);
{
    boolean present=false;
    PostInsertEventListener[] listeners=eventListeners.getPostInsertEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostInsertEventListener[] newListeners=new PostInsertEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostInsertEventListener)searchEventListener;
        eventListeners.setPostInsertEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostInsertEventListeners(new PostInsertEventListener[]{(PostInsertEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostUpdateEventListener[] listeners=eventListeners.getPostUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostUpdateEventListener[] newListeners=new PostUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostUpdateEventListener)searchEventListener;
        eventListeners.setPostUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostUpdateEventListeners(new PostUpdateEventListener[]{(PostUpdateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostDeleteEventListener[] listeners=eventListeners.getPostDeleteEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostDeleteEventListener[] newListeners=new PostDeleteEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostDeleteEventListener)searchEventListener;
        eventListeners.setPostDeleteEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostDeleteEventListeners(new PostDeleteEventListener[]{(PostDeleteEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRecreateEventListener[] listeners=eventListeners.getPostCollectionRecreateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRecreateEventListener[] newListeners=new PostCollectionRecreateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRecreateEventListener)searchEventListener;
        eventListeners.setPostCollectionRecreateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRecreateEventListeners(new PostCollectionRecreateEventListener[]{(PostCollectionRecreateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRemoveEventListener[] listeners=eventListeners.getPostCollectionRemoveEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRemoveEventListener[] newListeners=new PostCollectionRemoveEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRemoveEventListener)searchEventListener;
        eventListeners.setPostCollectionRemoveEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRemoveEventListeners(new PostCollectionRemoveEventListener[]{(PostCollectionRemoveEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionUpdateEventListener[] listeners=eventListeners.getPostCollectionUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionUpdateEventListener[] newListeners=new PostCollectionUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionUpdateEventListener)searchEventListener;
        eventListeners.setPostCollectionUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionUpdateEventListeners(new PostCollectionUpdateEventListener[]{(PostCollectionUpdateEventListener)searchEventListener});
    }
  }
}
"
"/** 
 * Copy the state of the given object onto the persistent object with the same identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If the given instance is unsaved or does not exist in the database, save it and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated use {@link org.hibernate.Session#merge(Object)}
 * @param object a transient instance with state to be copied
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(Object object) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the given identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If there is no database row with the given identifier, save the given instance and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated with no replacement
 * @param object a persistent or transient instance with state to be copied
 * @param id the identifier of the instance to copy to
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the same identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If the given instance is unsaved or does not exist in the database, save it and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated use {@link org.hibernate.Session#merge(String,Object)}
 * @param object a transient instance with state to be copied
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(String entityName,Object object) throws HibernateException ;
"
"/** 
 * Copy the state of the given object onto the persistent object with the given identifier. If there is no persistent instance currently associated with the session, it will be loaded. Return the persistent instance. If there is no database row with the given identifier, save the given instance and return it as a newly persistent instance. Otherwise, the given instance does not become associated with the session.
 * @deprecated with no replacement
 * @param object a persistent or transient instance with state to be copied
 * @param id the identifier of the instance to copy to
 * @return an updated persistent instance
 */
public Object saveOrUpdateCopy(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Execute a query.
 * @deprecated use {@link #createQuery}. {@link Query#list()}
 * @param query a query expressed in Hibernate's query language
 * @return a distinct list of instances (or arrays of instances)
 * @throws HibernateException
 */
public List find(String query) throws HibernateException ;
"
"/** 
 * Execute a query with bind parameters, binding a value to a ""?"" parameter in the query string.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#list()}
 * @param query the query string
 * @param value a value to be bound to a ""?"" placeholder (JDBC IN parameter).
 * @param type the Hibernate type of the value
 * @see org.hibernate.Hibernate for access to <tt>Type</tt> instances
 * @return a distinct list of instances (or arrays of instances)
 * @throws HibernateException
 */
public List find(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Execute a query with bind parameters, binding an array of values to ""?"" parameters in the query string.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#list()}
 * @param query the query string
 * @param values an array of values to be bound to the ""?"" placeholders (JDBC IN parameters).
 * @param types an array of Hibernate types of the values
 * @see org.hibernate.Hibernate for access to <tt>Type</tt> instances
 * @return a distinct list of instances
 * @throws HibernateException
 */
public List find(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. If the query has multiple return values, values will be returned in an array of type <tt>Object[].</tt><br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}. {@link Query#iterate}
 * @param query the query string
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. Write the given value to ""?"" in the query string. If the query has multiple return values, values will be returned in an array of type <tt>Object[]</tt>.<br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#iterate}
 * @param query the query string
 * @param value a value to be witten to a ""?"" placeholder in the query string
 * @param type the hibernate type of value
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Execute a query and return the results in an iterator. Write the given values to ""?"" in the query string. If the query has multiple return values, values will be returned in an array of type <tt>Object[]</tt>.<br> <br> Entities returned as results are initialized on demand. The first SQL query returns identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve objects than <tt>find()</tt>.
 * @deprecated use {@link #createQuery}.setXYZ. {@link Query#iterate}
 * @param query the query string
 * @param values a list of values to be written to ""?"" placeholders in the query
 * @param types a list of Hibernate types of the values
 * @return an iterator
 * @throws HibernateException
 */
public Iterator iterate(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element. Filters allow efficient access to very large lazy collections. (Executing the filter does not initialize the collection.)
 * @deprecated use {@link #createFilter(Object,String)}. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @return Collection the resulting collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element.
 * @deprecated use {@link #createFilter(Object,String)}.setXYZ. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @param value a value to be witten to a ""?"" placeholder in the query string
 * @param type the hibernate type of value
 * @return Collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter,Object value,Type type) throws HibernateException ;
"
"/** 
 * Apply a filter to a persistent collection. Bind the given parameters to ""?"" placeholders. A filter is a Hibernate query that may refer to <tt>this</tt>, the collection element.
 * @deprecated use {@link #createFilter(Object,String)}.setXYZ. {@link Query#list}
 * @param collection a persistent collection to filter
 * @param filter a filter query string
 * @param values a list of values to be written to ""?"" placeholders in the query
 * @param types a list of Hibernate types of the values
 * @return Collection
 * @throws HibernateException
 */
public Collection filter(Object collection,String filter,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @param value a value to be witten to a ""?"" placeholder in the query string.
 * @param type the hibernate type of value.
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query,Object value,Type type) throws HibernateException ;
"
"/** 
 * Delete all objects returned by the query. Return the number of objects deleted. <p/> Note that this is very different from the delete-statement support added in HQL since 3.1.  The functionality here is to actually peform the query and then iterate the results calling  {@link #delete(Object)} individually.
 * @deprecated consider using HQL delete statements
 * @param query the query string
 * @param values a list of values to be written to ""?"" placeholders in the query.
 * @param types a list of Hibernate types of the values
 * @return the number of instances deleted
 * @throws HibernateException
 */
public int delete(String query,Object[] values,Type[] types) throws HibernateException ;
"
"/** 
 * Create a new instance of <tt>Query</tt> for the given SQL string. <p/> Returned instances should all be  {@link org.hibernate.SQLQuery}.
 * @param sql a query expressed in SQL
 * @param returnAlias a table alias that appears inside <tt>{}</tt> in the SQL string
 * @param returnClass the returned persistent class
 * @deprecated use {@link org.hibernate.SQLQuery#addRoot} or {@link org.hibernate.SQLQuery#addEntity} variantsinstead to define the alias/class
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Query createSQLQuery(String sql,String returnAlias,Class returnClass);
"
"/** 
 * Create a new instance of <tt>Query</tt> for the given SQL string. <p/> Returned instances should all be  {@link org.hibernate.SQLQuery}.
 * @param sql a query expressed in SQL
 * @param returnAliases an array of table aliases that appear inside <tt>{}</tt> in the SQL string
 * @param returnClasses the returned persistent classes
 * @deprecated use {@link org.hibernate.SQLQuery#addRoot} or {@link org.hibernate.SQLQuery#addEntity} variantsinstead to define the aliases/classes
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Query createSQLQuery(String sql,String[] returnAliases,Class[] returnClasses);
"
"/** 
 * Persist the given transient instance, using the given identifier.  This operation  cascades to associated instances if the association is mapped with  <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a transient instance of a persistent class
 * @param id an unused valid identifier
 * @throws HibernateException
 */
public void save(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Persist the given transient instance, using the given identifier. This operation  cascades to associated instances if the association is mapped with  <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a transient instance of a persistent class
 * @param id an unused valid identifier
 * @throws HibernateException
 */
public void save(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Update the persistent state associated with the given identifier. An exception is thrown if there is a persistent instance with the same identifier in the current session. This operation cascades to associated instances  if the association is mapped with <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a detached instance containing updated state
 * @param id identifier of persistent instance
 * @throws HibernateException
 */
public void update(Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Update the persistent state associated with the given identifier. An exception is thrown if there is a persistent instance with the same identifier in the current session. This operation cascades to associated instances  if the association is mapped with <tt>cascade=""save-update""</tt>.
 * @deprecated declare identifier properties for all classes
 * @param object a detached instance containing updated state
 * @param id identifier of persistent instance
 * @throws HibernateException
 */
public void update(String entityName,Object object,Serializable id) throws HibernateException ;
"
"/** 
 * Apply a constraint expressed in SQL, with the given JDBC parameters. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String,Object[],Type[])}
 * @param sql
 * @param values
 * @param types
 * @return Criterion
 */
public static Criterion sql(String sql,Object[] values,Type[] types){
  return new SQLCriterion(sql,values,types);
}
"
"/** 
 * Apply a constraint expressed in SQL, with the given JDBC parameter. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String,Object,Type)}
 * @param sql
 * @param value
 * @param type
 * @return Criterion
 */
public static Criterion sql(String sql,Object value,Type type){
  return new SQLCriterion(sql,new Object[]{value},new Type[]{type});
}
"
"/** 
 * Apply a constraint expressed in SQL. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String)}
 * @param sql
 * @return Criterion
 */
public static Criterion sql(String sql){
  return new SQLCriterion(sql,ArrayHelper.EMPTY_OBJECT_ARRAY,ArrayHelper.EMPTY_TYPE_ARRAY);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Allow access to the id generator factory, though this is only needed/allowed from configuration.
 * @return
 * @deprecated temporary solution 
 */
public IdentifierGeneratorFactory getIdentifierGeneratorFactory();
"
"/** 
 * This form used from annotations (?).  Essentially the same as the above using a resultset-mapping reference, but without cacheMode, readOnly, and comment. FIXME: annotations do not use it, so it can be remove from my POV
 * @deprecated
 * @param query The sql query string
 * @param resultSetRef The result-set-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 */
public NamedSQLQueryDefinition(String query,String resultSetRef,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,Map parameterTypes,boolean callable){
  this(query,resultSetRef,querySpaces,cacheable,cacheRegion,timeout,fetchSize,flushMode,null,false,null,parameterTypes,callable);
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.impl.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
public void setFetchProfile(String name);
"
"/** 
 * Getter for property 'source'.  This is the session from which the event originated. <p/> Some of the pre-* events had previous exposed the event source using getSource() because they had not originally extended from {@link AbstractEvent}.
 * @return Value for property 'source'.
 * @deprecated Use {@link #getSession} instead
 */
public EventSource getSource(){
  return getSession();
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * Creates a single node AST. <p/> TODO : this is silly, remove it...
 * @param astFactory The factory.
 * @param type The node type.
 * @param text The node text.
 * @return AST - A single node tree.
 * @deprecated silly
 */
public static AST create(ASTFactory astFactory,int type,String text){
  return astFactory.create(type,text);
}
"
"/** 
 * Get the name of a constant defined on the given class which has the given value. <p/> Note, if multiple constants have this value, the first will be returned which is known to be different on different JVM implementations.
 * @param owner The class which defines the constant
 * @param value The value of the constant.
 * @return The token type name, *or* the integer value if the name could not be found.
 * @deprecated Use #getTokenTypeName instead
 */
public static String getConstantName(Class owner,int value){
  return getTokenTypeName(owner,value);
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
@Deprecated public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return new Long(value);
  }
 else   if (clazz == Integer.class) {
    return new Integer((int)value);
  }
 else   if (clazz == Short.class) {
    return new Short((short)value);
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  String optimizerClassName;
  if (NONE.equals(type)) {
    optimizerClassName=NoopOptimizer.class.getName();
  }
 else   if (HILO.equals(type)) {
    optimizerClassName=HiLoOptimizer.class.getName();
  }
 else   if (LEGACY_HILO.equals(type)) {
    optimizerClassName=LegacyHiLoAlgorithmOptimizer.class.getName();
  }
 else   if (POOL.equals(type)) {
    optimizerClassName=PooledOptimizer.class.getName();
  }
 else   if (POOL_LO.equals(type)) {
    optimizerClassName=PooledLoOptimizer.class.getName();
  }
 else {
    optimizerClassName=type;
  }
  try {
    Class optimizerClass=ReflectHelper.classForName(optimizerClassName);
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return new NoopOptimizer(returnClass,incrementSize);
}
"
"/** 
 * Allow injection of the dialect to use.
 * @param dialect The dialect
 * @deprecated The intention is that Dialect should be required to be specified up-front and it would then getctor injected.
 */
public void setDialect(Dialect dialect);
"
"/** 
 * Load an entity instance. If <tt>optionalObject</tt> is supplied, load the entity state into the given (uninitialized) object.
 * @deprecated use {@link #load(java.io.Serializable,Object,SessionImplementor,LockOptions)} instead.
 * @noinspection JavaDoc
 */
public Object load(Serializable id,Object optionalObject,SessionImplementor session) throws HibernateException ;
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * Create a class instance initialized with the given identifier
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Serializable getIdentifier(Object object,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @param entityMode The entity mode
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Serializable getIdentifier(Object object,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @param entityMode The entity mode
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Create a class instance initialized with the given identifier
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Set the identifier and version of the given instance back to its ""unsaved"" value.
 * @param entity The entity instance
 * @param currentId The currently assigned identifier value.
 * @param currentVersion The currently assigned version value.
 * @param entityMode The entity mode represented by the entity instance.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion,EntityMode entityMode);
"
"/** 
 * @deprecated
 */
public void setAttributeValue(String name,String value){
  target().setAttributeValue(name,value);
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(QName qName,String value){
  target().setAttributeValue(qName,value);
}
"
"/** 
 * Get the current lock mode
 * @return LockMode
 * @deprecated Instead use getLockOptions
 */
public LockMode getLockMode(){
  return lockOptions.getLockMode();
}
"
"/** 
 * Set the lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public Select setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #renderOrderByStringTemplate(String,ColumnMapper,SessionFactoryImplementor,Dialect,SQLFunctionRegistry)} instead
 */
public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param cfg The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  formatter=(ConfigurationHelper.getBoolean(Environment.FORMAT_SQL,props) ? FormatStyle.DDL : FormatStyle.NONE).getFormatter();
  importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,props,DEFAULT_IMPORT_FILE);
}
"
"/** 
 * An import file, containing raw SQL statements to be executed.
 * @param filename The import file name.
 * @return this
 * @deprecated use {@link org.hibernate.cfg.Environment.HBM2DDL_IMPORT_FILE}
 */
@Deprecated public SchemaExport setImportFile(String filename){
  importFiles=filename;
  return this;
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(String name,String value){
  element.setAttributeValue(name,value);
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(QName qName,String value){
  element.setAttributeValue(qName,value);
}
"
"/** 
 * Create an entity instance initialized with the given identifier.
 * @param id The identifier value for the entity to be instantiated.
 * @return The instantiated entity.
 * @throws HibernateException
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id) throws HibernateException ;
"
"/** 
 * Extract the identifier value from the given entity.
 * @param entity The entity from which to extract the identifier value.
 * @return The identifier value.
 * @throws HibernateException If the entity does not define an identifier property, or anerror occurs accessing its value.
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead.
 */
public Serializable getIdentifier(Object entity) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id) throws HibernateException ;
"
"/** 
 * Inject the given identifier and version into the entity, in order to ""roll back"" to their original values.
 * @param entity The entity for which to reset the id/version values
 * @param currentId The identifier value to inject into the entity.
 * @param currentVersion The version value to inject into the entity.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion);
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * @deprecated Use {@link #nullSafeGet(ResultSet,String,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public T nullSafeGet(ResultSet rs,String name) throws HibernateException, SQLException ;
"
"/** 
 * DO NOT USER THIS FORM!
 * @deprecated Use {@link #get(ResultSet,String,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public Object get(ResultSet rs,String name) throws HibernateException, SQLException ;
"
"/** 
 * DO NOT USE THIS FORM!
 * @deprecated Use {@link #nullSafeSet(PreparedStatement,Object,int,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public void nullSafeSet(PreparedStatement st,T value,int index) throws HibernateException, SQLException ;
"
"/** 
 * DO NOT USE THIS FORM!
 * @deprecated Use {@link #set(PreparedStatement,Object,int,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public void set(PreparedStatement st,T value,int index) throws HibernateException, SQLException ;
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * Log the given warning and all of its nested warnings, preceded with the  {@link #DEFAULT_WARNING_MSG default message}
 * @param warning The warning to log
 * @deprecated Use {@link #walkWarnings} instead
 */
@Deprecated() @SuppressWarnings({""UnusedDeclaration""}) public static void logWarnings(SQLWarning warning){
  walkWarnings(warning,STANDARD_WARNING_HANDLER);
}
"
"/** 
 * Log the given warning and all of its nested warnings, preceded with the given message
 * @param warning The warning to log
 * @param message The prologue message
 * @deprecated Use {@link #walkWarnings} instead
 */
@Deprecated() @SuppressWarnings({""UnusedDeclaration""}) public static void logWarnings(SQLWarning warning,String message){
  final WarningHandler handler=StringHelper.isNotEmpty(message) ? new StandardWarningHandler(message) : STANDARD_WARNING_HANDLER;
  walkWarnings(warning,handler);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * @deprecated use getHbmfiles() rather
 */
public void setHbmfiles(List<NamedInputStream> hbmfiles){
  this.hbmfiles=hbmfiles;
}
"
"/** 
 * Set lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
@Deprecated public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
@Deprecated public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
@Deprecated public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * {@inheritDoc}
 * @deprecated Use {@link #nullSafeGet(ResultSet,String,SessionImplementor)} instead
 */
public T nullSafeGet(ResultSet rs,String name) throws HibernateException, SQLException {
  return nullSafeGet(rs,name,NO_OPTIONS);
}
"
"/** 
 * {@inheritDoc}
 * @deprecated Use {@link #get(ResultSet,String,SessionImplementor)} instead.
 */
public Object get(ResultSet rs,String name) throws HibernateException, SQLException {
  return nullSafeGet(rs,name);
}
"
"/** 
 * {@inheritDoc}
 * @deprecated Use {@link #nullSafeSet(PreparedStatement,Object,int,SessionImplementor)} instead.
 */
public void nullSafeSet(PreparedStatement st,T value,int index) throws HibernateException, SQLException {
  nullSafeSet(st,value,index,NO_OPTIONS);
}
"
"/** 
 * {@inheritDoc}
 * @deprecated Use {@link #set(PreparedStatement,Object,int,SessionImplementor)} instead.
 */
public void set(PreparedStatement st,T value,int index) throws HibernateException, SQLException {
  nullSafeSet(st,value,index);
}
"
"/** 
 * Retrieve an instance of the mapped class from a JDBC resultset. Implementors should handle possibility of null values.
 * @param rs a JDBC result set
 * @param names the column names
 * @param owner the containing entity
 * @return Object
 * @throws HibernateException
 * @throws SQLException
 * @deprecated SessionImplementor will be added as an argument in a future version (see HHH-5968)
 */
public Object nullSafeGet(ResultSet rs,String[] names,Object owner) throws HibernateException, SQLException ;
"
"/** 
 * Write an instance of the mapped class to a prepared statement. Implementors should handle possibility of null values. A multi-column type should be written to parameters starting from <tt>index</tt>.
 * @param st a JDBC prepared statement
 * @param value the object to write
 * @param index statement parameter index
 * @throws HibernateException
 * @throws SQLException
 * @deprecated SessionImplementor will be added as an argument in a future version (see HHH-5968)
 */
public void nullSafeSet(PreparedStatement st,Object value,int index) throws HibernateException, SQLException ;
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
public void evictQueries() throws HibernateException ;
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.impl.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
public void setFetchProfile(String name);
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
public void evictQueries() throws HibernateException ;
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.impl.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
public void setFetchProfile(String name);
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param cfg The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  formatter=(ConfigurationHelper.getBoolean(Environment.FORMAT_SQL,props) ? FormatStyle.DDL : FormatStyle.NONE).getFormatter();
  importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,props,DEFAULT_IMPORT_FILE);
}
"
"/** 
 * An import file, containing raw SQL statements to be executed.
 * @param filename The import file name.
 * @return this
 * @deprecated use {@link org.hibernate.cfg.Environment.HBM2DDL_IMPORT_FILE}
 */
public SchemaExport setImportFile(String filename){
  importFiles=filename;
  return this;
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryImpl(properties);
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((ServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * @deprecated as of release 3.4.0.CR2, replaced by Hibernate Search's {@link org.hibernate.search.cfg.EventListenerRegister#enableHibernateSearch(EventListeners,Properties)}
 */
@SuppressWarnings(""unchecked"") @Deprecated public static void enableHibernateSearch(EventListeners eventListeners,Properties properties){
  String enableSearchListeners=properties.getProperty(""hibernate.search.autoregister_listeners"");
  if (""false"".equalsIgnoreCase(enableSearchListeners)) {
    log.info(""Property hibernate.search.autoregister_listeners is set to false."" + "" No attempt will be made to register Hibernate Search event listeners."");
    return;
  }
  Class searchEventListenerClass=attemptToLoadSearchEventListener();
  if (searchEventListenerClass == null) {
    log.info(""Unable to find {} on the classpath. Hibernate Search is not enabled."",FULL_TEXT_INDEX_EVENT_LISTENER_CLASS);
    return;
  }
  Object searchEventListener=instantiateEventListener(searchEventListenerClass);
{
    boolean present=false;
    PostInsertEventListener[] listeners=eventListeners.getPostInsertEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostInsertEventListener[] newListeners=new PostInsertEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostInsertEventListener)searchEventListener;
        eventListeners.setPostInsertEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostInsertEventListeners(new PostInsertEventListener[]{(PostInsertEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostUpdateEventListener[] listeners=eventListeners.getPostUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostUpdateEventListener[] newListeners=new PostUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostUpdateEventListener)searchEventListener;
        eventListeners.setPostUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostUpdateEventListeners(new PostUpdateEventListener[]{(PostUpdateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostDeleteEventListener[] listeners=eventListeners.getPostDeleteEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostDeleteEventListener[] newListeners=new PostDeleteEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostDeleteEventListener)searchEventListener;
        eventListeners.setPostDeleteEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostDeleteEventListeners(new PostDeleteEventListener[]{(PostDeleteEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRecreateEventListener[] listeners=eventListeners.getPostCollectionRecreateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRecreateEventListener[] newListeners=new PostCollectionRecreateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRecreateEventListener)searchEventListener;
        eventListeners.setPostCollectionRecreateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRecreateEventListeners(new PostCollectionRecreateEventListener[]{(PostCollectionRecreateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRemoveEventListener[] listeners=eventListeners.getPostCollectionRemoveEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRemoveEventListener[] newListeners=new PostCollectionRemoveEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRemoveEventListener)searchEventListener;
        eventListeners.setPostCollectionRemoveEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRemoveEventListeners(new PostCollectionRemoveEventListener[]{(PostCollectionRemoveEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionUpdateEventListener[] listeners=eventListeners.getPostCollectionUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionUpdateEventListener[] newListeners=new PostCollectionUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionUpdateEventListener)searchEventListener;
        eventListeners.setPostCollectionUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionUpdateEventListeners(new PostCollectionUpdateEventListener[]{(PostCollectionUpdateEventListener)searchEventListener});
    }
  }
}
"
"/** 
 * Apply a constraint expressed in SQL, with the given JDBC parameters. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String,Object[],Type[])}
 * @param sql
 * @param values
 * @param types
 * @return Criterion
 */
public static Criterion sql(String sql,Object[] values,Type[] types){
  return new SQLCriterion(sql,values,types);
}
"
"/** 
 * Apply a constraint expressed in SQL, with the given JDBC parameter. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String,Object,Type)}
 * @param sql
 * @param value
 * @param type
 * @return Criterion
 */
public static Criterion sql(String sql,Object value,Type type){
  return new SQLCriterion(sql,new Object[]{value},new Type[]{type});
}
"
"/** 
 * Apply a constraint expressed in SQL. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String)}
 * @param sql
 * @return Criterion
 */
public static Criterion sql(String sql){
  return new SQLCriterion(sql,ArrayHelper.EMPTY_OBJECT_ARRAY,ArrayHelper.EMPTY_TYPE_ARRAY);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@SuppressWarnings({""UnnecessaryBoxing""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  String optimizerClassName;
  if (NONE.equals(type)) {
    optimizerClassName=NoopOptimizer.class.getName();
  }
 else   if (HILO.equals(type)) {
    optimizerClassName=HiLoOptimizer.class.getName();
  }
 else   if (LEGACY_HILO.equals(type)) {
    optimizerClassName=LegacyHiLoAlgorithmOptimizer.class.getName();
  }
 else   if (POOL.equals(type)) {
    optimizerClassName=PooledOptimizer.class.getName();
  }
 else   if (POOL_LO.equals(type)) {
    optimizerClassName=PooledLoOptimizer.class.getName();
  }
 else {
    optimizerClassName=type;
  }
  try {
    Class optimizerClass=ReflectHelper.classForName(optimizerClassName);
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    log.warn(""Unable to instantiate specified optimizer [{}], falling back to noop"",type);
  }
  return new NoopOptimizer(returnClass,incrementSize);
}
"
"/** 
 * A Hibernate <tt>serializable</tt> type.
 * @param serializableClass The {@link java.io.Serializable} implementor class.
 * @return
 * @deprecated Use {@link SerializableType#SerializableType} instead.
 */
@SuppressWarnings({""unchecked""}) public static Type serializable(Class serializableClass){
  return new SerializableType(serializableClass);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#any} instead.
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type any(Type metaType,Type identifierType){
  return new AnyType(metaType,identifierType);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration"",""deprecation""}) public static Type entity(Class persistentClass){
  return entity(persistentClass.getName());
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type entity(String entityName){
  return new ManyToOneType(NoScope.INSTANCE,entityName);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass){
  return custom(userTypeClass,null);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass,String[] parameterNames,String[] parameterValues){
  return custom(userTypeClass,toProperties(parameterNames,parameterValues));
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration"",""unchecked""}) public static Type custom(Class userTypeClass,Properties parameters){
  if (CompositeUserType.class.isAssignableFrom(userTypeClass)) {
    return TypeFactory.customComponent(userTypeClass,parameters,NoScope.INSTANCE);
  }
 else {
    return TypeFactory.custom(userTypeClass,parameters,NoScope.INSTANCE);
  }
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * Get the current lock mode
 * @return LockMode
 * @deprecated Instead use getLockOptions
 */
public LockMode getLockMode(){
  return lockOptions.getLockMode();
}
"
"/** 
 * Set the lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public Select setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #renderOrderByStringTemplate(String,ColumnMapper,SessionFactoryImplementor,Dialect,SQLFunctionRegistry)} instead
 */
public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param cfg The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  formatter=(ConfigurationHelper.getBoolean(Environment.FORMAT_SQL,props) ? FormatStyle.DDL : FormatStyle.NONE).getFormatter();
  importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,props,DEFAULT_IMPORT_FILE);
}
"
"/** 
 * An import file, containing raw SQL statements to be executed.
 * @param filename The import file name.
 * @return this
 * @deprecated use {@link org.hibernate.cfg.Environment#HBM2DDL_IMPORT_FILES}
 */
public SchemaExport setImportFile(String filename){
  importFiles=filename;
  return this;
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param cfg The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  formatter=(ConfigurationHelper.getBoolean(Environment.FORMAT_SQL,props) ? FormatStyle.DDL : FormatStyle.NONE).getFormatter();
  importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,props,DEFAULT_IMPORT_FILE);
}
"
"/** 
 * An import file, containing raw SQL statements to be executed.
 * @param filename The import file name.
 * @return this
 * @deprecated use {@link org.hibernate.cfg.Environment#HBM2DDL_IMPORT_FILES}
 */
@Deprecated public SchemaExport setImportFile(String filename){
  importFiles=filename;
  return this;
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.impl.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
public void evictQueries() throws HibernateException ;
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryImpl(properties);
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((ServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
@Deprecated public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
@Deprecated public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
@Deprecated public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * @deprecated as of release 3.4.0.CR2, replaced by Hibernate Search's {@link org.hibernate.search.cfg.EventListenerRegister#enableHibernateSearch(EventListeners,Properties)}
 */
@SuppressWarnings(""unchecked"") @Deprecated public static void enableHibernateSearch(EventListeners eventListeners,Properties properties){
  String enableSearchListeners=properties.getProperty(""hibernate.search.autoregister_listeners"");
  if (""false"".equalsIgnoreCase(enableSearchListeners)) {
    LOG.willNotRegisterListeners();
    return;
  }
  Class searchEventListenerClass=attemptToLoadSearchEventListener();
  if (searchEventListenerClass == null) {
    LOG.unableToFindListenerClass(FULL_TEXT_INDEX_EVENT_LISTENER_CLASS);
    return;
  }
  Object searchEventListener=instantiateEventListener(searchEventListenerClass);
{
    boolean present=false;
    PostInsertEventListener[] listeners=eventListeners.getPostInsertEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostInsertEventListener[] newListeners=new PostInsertEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostInsertEventListener)searchEventListener;
        eventListeners.setPostInsertEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostInsertEventListeners(new PostInsertEventListener[]{(PostInsertEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostUpdateEventListener[] listeners=eventListeners.getPostUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostUpdateEventListener[] newListeners=new PostUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostUpdateEventListener)searchEventListener;
        eventListeners.setPostUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostUpdateEventListeners(new PostUpdateEventListener[]{(PostUpdateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostDeleteEventListener[] listeners=eventListeners.getPostDeleteEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostDeleteEventListener[] newListeners=new PostDeleteEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostDeleteEventListener)searchEventListener;
        eventListeners.setPostDeleteEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostDeleteEventListeners(new PostDeleteEventListener[]{(PostDeleteEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRecreateEventListener[] listeners=eventListeners.getPostCollectionRecreateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRecreateEventListener[] newListeners=new PostCollectionRecreateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRecreateEventListener)searchEventListener;
        eventListeners.setPostCollectionRecreateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRecreateEventListeners(new PostCollectionRecreateEventListener[]{(PostCollectionRecreateEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionRemoveEventListener[] listeners=eventListeners.getPostCollectionRemoveEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionRemoveEventListener[] newListeners=new PostCollectionRemoveEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionRemoveEventListener)searchEventListener;
        eventListeners.setPostCollectionRemoveEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionRemoveEventListeners(new PostCollectionRemoveEventListener[]{(PostCollectionRemoveEventListener)searchEventListener});
    }
  }
{
    boolean present=false;
    PostCollectionUpdateEventListener[] listeners=eventListeners.getPostCollectionUpdateEventListeners();
    if (listeners != null) {
      for (      Object eventListener : listeners) {
        present=present || searchEventListenerClass == eventListener.getClass();
      }
      if (!present) {
        int length=listeners.length + 1;
        PostCollectionUpdateEventListener[] newListeners=new PostCollectionUpdateEventListener[length];
        System.arraycopy(listeners,0,newListeners,0,length - 1);
        newListeners[length - 1]=(PostCollectionUpdateEventListener)searchEventListener;
        eventListeners.setPostCollectionUpdateEventListeners(newListeners);
      }
    }
 else {
      eventListeners.setPostCollectionUpdateEventListeners(new PostCollectionUpdateEventListener[]{(PostCollectionUpdateEventListener)searchEventListener});
    }
  }
}
"
"/** 
 * Apply a constraint expressed in SQL, with the given JDBC parameters. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String,Object[],Type[])}
 * @param sql
 * @param values
 * @param types
 * @return Criterion
 */
@Deprecated public static Criterion sql(String sql,Object[] values,Type[] types){
  return new SQLCriterion(sql,values,types);
}
"
"/** 
 * Apply a constraint expressed in SQL, with the given JDBC parameter. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String,Object,Type)}
 * @param sql
 * @param value
 * @param type
 * @return Criterion
 */
@Deprecated public static Criterion sql(String sql,Object value,Type type){
  return new SQLCriterion(sql,new Object[]{value},new Type[]{type});
}
"
"/** 
 * Apply a constraint expressed in SQL. Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String)}
 * @param sql
 * @return Criterion
 */
@Deprecated public static Criterion sql(String sql){
  return new SQLCriterion(sql,ArrayHelper.EMPTY_OBJECT_ARRAY,ArrayHelper.EMPTY_TYPE_ARRAY);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.impl.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
@Deprecated @Override public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  String optimizerClassName;
  if (NONE.equals(type)) {
    optimizerClassName=NoopOptimizer.class.getName();
  }
 else   if (HILO.equals(type)) {
    optimizerClassName=HiLoOptimizer.class.getName();
  }
 else   if (LEGACY_HILO.equals(type)) {
    optimizerClassName=LegacyHiLoAlgorithmOptimizer.class.getName();
  }
 else   if (POOL.equals(type)) {
    optimizerClassName=PooledOptimizer.class.getName();
  }
 else   if (POOL_LO.equals(type)) {
    optimizerClassName=PooledLoOptimizer.class.getName();
  }
 else {
    optimizerClassName=type;
  }
  try {
    Class optimizerClass=ReflectHelper.classForName(optimizerClassName);
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return new NoopOptimizer(returnClass,incrementSize);
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * Get the current lock mode
 * @return LockMode
 * @deprecated Instead use getLockOptions
 */
public LockMode getLockMode(){
  return lockOptions.getLockMode();
}
"
"/** 
 * Set the lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public Select setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #renderOrderByStringTemplate(String,ColumnMapper,SessionFactoryImplementor,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param cfg The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  formatter=(ConfigurationHelper.getBoolean(Environment.FORMAT_SQL,props) ? FormatStyle.DDL : FormatStyle.NONE).getFormatter();
  importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,props,DEFAULT_IMPORT_FILE);
}
"
"/** 
 * An import file, containing raw SQL statements to be executed.
 * @param filename The import file name.
 * @return this
 * @deprecated use {@link org.hibernate.cfg.Environment#HBM2DDL_IMPORT_FILES}
 */
@Deprecated public SchemaExport setImportFile(String filename){
  importFiles=filename;
  return this;
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * @deprecated use getHbmfiles() rather
 */
public void setHbmfiles(List<NamedInputStream> hbmfiles){
  this.hbmfiles=hbmfiles;
}
"
"/** 
 * @deprecated use getHbmfiles() rather
 */
public void setHbmfiles(List<NamedInputStream> hbmfiles){
  this.hbmfiles=hbmfiles;
}
"
"/** 
 * @deprecated use getHbmfiles() rather
 */
public void setHbmfiles(List<NamedInputStream> hbmfiles){
  this.hbmfiles=hbmfiles;
}
"
"/** 
 * @deprecated Use {@link #getValue()}. {@link Value#getTable() getTable()} instead; to be removed on completion of new metamodel code
 * @return
 */
@Deprecated public TableSpecification getTable();
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
public void evictQueries() throws HibernateException ;
"
"/** 
 * Create a class instance initialized with the given identifier
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Serializable getIdentifier(Object object,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @param entityMode The entity mode
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Serializable getIdentifier(Object object,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @param entityMode The entity mode
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Create a class instance initialized with the given identifier
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Set the identifier and version of the given instance back to its ""unsaved"" value.
 * @param entity The entity instance
 * @param currentId The currently assigned identifier value.
 * @param currentVersion The currently assigned version value.
 * @param entityMode The entity mode represented by the entity instance.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion,EntityMode entityMode);
"
"/** 
 * Create an entity instance initialized with the given identifier.
 * @param id The identifier value for the entity to be instantiated.
 * @return The instantiated entity.
 * @throws HibernateException
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id) throws HibernateException ;
"
"/** 
 * Extract the identifier value from the given entity.
 * @param entity The entity from which to extract the identifier value.
 * @return The identifier value.
 * @throws HibernateException If the entity does not define an identifier property, or anerror occurs accessing its value.
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead.
 */
public Serializable getIdentifier(Object entity) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id) throws HibernateException ;
"
"/** 
 * Inject the given identifier and version into the entity, in order to ""roll back"" to their original values.
 * @param entity The entity for which to reset the id/version values
 * @param currentId The identifier value to inject into the entity.
 * @param currentVersion The version value to inject into the entity.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion);
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.impl.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
@Deprecated public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
@Deprecated public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
@Deprecated public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * A Hibernate <tt>serializable</tt> type.
 * @param serializableClass The {@link java.io.Serializable} implementor class.
 * @return
 * @deprecated Use {@link SerializableType#SerializableType} instead.
 */
@SuppressWarnings({""unchecked""}) public static Type serializable(Class serializableClass){
  return new SerializableType(serializableClass);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#any} instead.
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type any(Type metaType,Type identifierType){
  return new AnyType(metaType,identifierType);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration"",""deprecation""}) public static Type entity(Class persistentClass){
  return entity(persistentClass.getName());
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#entity} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type entity(String entityName){
  return new ManyToOneType(NoScope.INSTANCE,entityName);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass){
  return custom(userTypeClass,null);
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration""}) public static Type custom(Class userTypeClass,String[] parameterNames,String[] parameterValues){
  return custom(userTypeClass,toProperties(parameterNames,parameterValues));
}
"
"/** 
 * DO NOT USE!
 * @deprecated Use {@link TypeHelper#custom} instead; see http://opensource.atlassian.com/projects/hibernate/browse/HHH-5182
 */
@SuppressWarnings({""JavaDoc"",""UnusedDeclaration"",""unchecked""}) public static Type custom(Class userTypeClass,Properties parameters){
  if (CompositeUserType.class.isAssignableFrom(userTypeClass)) {
    return TypeFactory.customComponent(userTypeClass,parameters,NoScope.INSTANCE);
  }
 else {
    return TypeFactory.custom(userTypeClass,parameters,NoScope.INSTANCE);
  }
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
@Deprecated public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
@Deprecated public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
@Deprecated public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new BasicServiceRegistryImpl(properties);
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((BasicServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param cfg The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  formatter=(ConfigurationHelper.getBoolean(Environment.FORMAT_SQL,props) ? FormatStyle.DDL : FormatStyle.NONE).getFormatter();
  importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,props,DEFAULT_IMPORT_FILE);
}
"
"/** 
 * An import file, containing raw SQL statements to be executed.
 * @param filename The import file name.
 * @return this
 * @deprecated use {@link org.hibernate.cfg.Environment#HBM2DDL_IMPORT_FILES}
 */
@Deprecated public SchemaExport setImportFile(String filename){
  importFiles=filename;
  return this;
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new BasicServiceRegistryImpl(properties);
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((BasicServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Get the JDBC connection of this Session.<br> <br> If the session is using aggressive collection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @return the JDBC connection in use by the <tt>Session</tt>
 * @throws HibernateException if the <tt>Session</tt> is disconnected
 * @deprecated (scheduled for removal in 4.x).  Replacement depends on need; for doing direct JDBC stuff use{@link #doWork}; for opening a 'temporary Session' use (TBD).
 */
public Connection connection() throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Returns the current JDBC connection associated with this instance.<br> <br> If the session is using aggressive connection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @deprecated just missed when deprecating same method from {@link Session}
 */
@Deprecated public Connection connection();
"
"/** 
 * Should be set only once for the session.  Would rather this be supplied to opening the session, as being discussed for HHH-2860
 * @param identifier The tenant identifier.
 * @deprecated HHH-2860
 */
@Deprecated public void setTenantIdentifier(String identifier);
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
@Deprecated public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
@Deprecated public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
@Deprecated public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.impl.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param cfg The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration cfg,Properties properties) throws HibernateException {
  dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  connectionHelper=new ManagedProviderConnectionHelper(props);
  dropSQL=cfg.generateDropSchemaScript(dialect);
  createSQL=cfg.generateSchemaCreationScript(dialect);
  formatter=(ConfigurationHelper.getBoolean(Environment.FORMAT_SQL,props) ? FormatStyle.DDL : FormatStyle.NONE).getFormatter();
  importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,props,DEFAULT_IMPORT_FILE);
}
"
"/** 
 * An import file, containing raw SQL statements to be executed.
 * @param filename The import file name.
 * @return this
 * @deprecated use {@link org.hibernate.cfg.Environment#HBM2DDL_IMPORT_FILES}
 */
@Deprecated public SchemaExport setImportFile(String filename){
  importFiles=filename;
  return this;
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.impl.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.impl.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new BasicServiceRegistryImpl(properties);
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((BasicServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new BasicServiceRegistryImpl(properties);
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((BasicServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new BasicServiceRegistryImpl(properties);
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((BasicServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new BasicServiceRegistryImpl(properties);
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((BasicServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.impl.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new BasicServiceRegistryImpl(properties);
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((BasicServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
@Deprecated @Override public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Starts a new Session with the given entity mode in effect. This secondary Session inherits the connection, transaction, and other context information from the primary Session. It doesn't need to be flushed or closed by the developer.
 * @param entityMode The entity mode to use for the new session.
 * @return The new session
 * @deprecated
 */
@Deprecated public Session getSession(EntityMode entityMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
public void evictQueries() throws HibernateException ;
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new BasicServiceRegistryImpl(properties);
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((BasicServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
@Deprecated public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
@Deprecated public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
@Deprecated public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
@Deprecated public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return new Long(value);
  }
 else   if (clazz == Integer.class) {
    return new Integer((int)value);
  }
 else   if (clazz == Short.class) {
    return new Short((short)value);
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  String optimizerClassName;
  if (NONE.equals(type)) {
    optimizerClassName=NoopOptimizer.class.getName();
  }
 else   if (HILO.equals(type)) {
    optimizerClassName=HiLoOptimizer.class.getName();
  }
 else   if (LEGACY_HILO.equals(type)) {
    optimizerClassName=LegacyHiLoAlgorithmOptimizer.class.getName();
  }
 else   if (POOL.equals(type)) {
    optimizerClassName=PooledOptimizer.class.getName();
  }
 else   if (POOL_LO.equals(type)) {
    optimizerClassName=PooledLoOptimizer.class.getName();
  }
 else {
    optimizerClassName=type;
  }
  try {
    Class optimizerClass=ReflectHelper.classForName(optimizerClassName);
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return new NoopOptimizer(returnClass,incrementSize);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * @deprecated Use {@link #getValue()}. {@link Value#getTable() getTable()} instead; to be removed on completion of new metamodel code
 * @return
 */
@Deprecated public TableSpecification getTable();
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #getValue()}. {@link Value#getTable() getTable()} instead; to be removed on completion of new metamodel code
 * @return
 */
@Deprecated public TableSpecification getTable();
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * @deprecated Use {@link #getValue()}. {@link Value#getTable() getTable()} instead; to be removed on completion of new metamodel code
 * @return
 */
@Deprecated public TableSpecification getTable();
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new BasicServiceRegistryImpl(properties);
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((BasicServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #getValue()}. {@link Value#getTable() getTable()} instead; to be removed on completion of new metamodel code
 * @return
 */
@Deprecated public TableSpecification getTable();
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((BasicServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((BasicServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((BasicServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Allow access to the id generator factory, though this is only needed/allowed from configuration.
 * @return
 * @deprecated temporary solution 
 */
public IdentifierGeneratorFactory getIdentifierGeneratorFactory();
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * @deprecated Use {@link #getValue()}. {@link Value#getTable() getTable()} instead; to be removed on completion of new metamodel code
 * @return
 */
@Deprecated public TableSpecification getTable();
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((BasicServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Use {@link #getValue()}. {@link Value#getTable() getTable()} instead; to be removed on completion of new metamodel code
 * @return
 */
@Deprecated public TableSpecification getTable();
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * @deprecated Use {@link #getValue()}. {@link Value#getTable() getTable()} instead; to be removed on completion of new metamodel code
 * @return
 */
@Deprecated public TableSpecification getTable();
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((BasicServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  Properties props=new Properties();
  if (workingVars != null) {
    props.putAll(workingVars);
    props.remove(AvailableSettings.CLASS_NAMES);
    props.remove(AvailableSettings.PACKAGE_NAMES);
    props.remove(AvailableSettings.HBXML_FILES);
    props.remove(AvailableSettings.LOADED_CLASSES);
  }
  configure(props,workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Does this JVM handle  {@link java.sql.Timestamp} in the JDK 1.4 compliant way wrt to nano rolling>
 * @return True if the JDK 1.4 (JDBC3) specification for {@link java.sql.Timestamp} nano rolling is adhered to.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmHasJDK14Timestamp(){
  return JVM_HAS_JDK14_TIMESTAMP;
}
"
"/** 
 * Does this JVM support  {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap}? <p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if {@link java.util.LinkedHashSet} and {@link java.util.LinkedHashMap} are available.
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 * @see java.util.LinkedHashSet
 * @see java.util.LinkedHashMap
 */
public static boolean jvmSupportsLinkedHashCollections(){
  return JVM_SUPPORTS_LINKED_HASH_COLLECTIONS;
}
"
"/** 
 * Does this JDK/JVM define the JDBC  {@link Statement} interface with a 'getGeneratedKeys' method?<p/> Note, this is true for JDK 1.4 and above; hence the deprecation.
 * @return True if generated keys can be retrieved via Statement; false otherwise.
 * @see Statement
 * @deprecated Starting with 3.3 Hibernate requires JDK 1.4 or higher
 */
public static boolean jvmSupportsGetGeneratedKeys(){
  return JVM_SUPPORTS_GET_GENERATED_KEYS;
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
public void evictQueries() throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
public void evictQueries() throws HibernateException ;
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Serializable getIdentifier(Object object,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @param entityMode The entity mode
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Create a class instance initialized with the given identifier
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Set the identifier and version of the given instance back to its ""unsaved"" value.
 * @param entity The entity instance
 * @param currentId The currently assigned identifier value.
 * @param currentVersion The currently assigned version value.
 * @param entityMode The entity mode represented by the entity instance.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion,EntityMode entityMode);
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
public void evictQueries() throws HibernateException ;
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((BasicServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Allow access to the id generator factory, though this is only needed/allowed from configuration.
 * @return
 * @deprecated temporary solution 
 */
public IdentifierGeneratorFactory getIdentifierGeneratorFactory();
"
"/** 
 * This form used from annotations (?).  Essentially the same as the above using a resultset-mapping reference, but without cacheMode, readOnly, and comment. FIXME: annotations do not use it, so it can be remove from my POV
 * @deprecated
 * @param query The sql query string
 * @param resultSetRef The result-set-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 */
public NamedSQLQueryDefinition(String query,String resultSetRef,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,Map parameterTypes,boolean callable){
  this(query,resultSetRef,querySpaces,cacheable,cacheRegion,timeout,fetchSize,flushMode,null,false,null,parameterTypes,callable);
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * Load an entity instance. If <tt>optionalObject</tt> is supplied, load the entity state into the given (uninitialized) object.
 * @deprecated use {@link #load(java.io.Serializable,Object,SessionImplementor,LockOptions)} instead.
 * @noinspection JavaDoc
 */
public Object load(Serializable id,Object optionalObject,SessionImplementor session) throws HibernateException ;
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * Create a class instance initialized with the given identifier
 * @deprecated Use {@link #instantiate(Serializable,org.hibernate.engine.spi.SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Serializable getIdentifier(Object object,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @param entityMode The entity mode
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Serializable getIdentifier(Object object,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @param entityMode The entity mode
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Create a class instance initialized with the given identifier
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id,EntityMode entityMode) throws HibernateException ;
"
"/** 
 * Set the identifier and version of the given instance back to its ""unsaved"" value.
 * @param entity The entity instance
 * @param currentId The currently assigned identifier value.
 * @param currentVersion The currently assigned version value.
 * @param entityMode The entity mode represented by the entity instance.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion,EntityMode entityMode);
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #renderOrderByStringTemplate(String,ColumnMapper,SessionFactoryImplementor,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * Create an entity instance initialized with the given identifier.
 * @param id The identifier value for the entity to be instantiated.
 * @return The instantiated entity.
 * @throws HibernateException
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id) throws HibernateException ;
"
"/** 
 * Extract the identifier value from the given entity.
 * @param entity The entity from which to extract the identifier value.
 * @return The identifier value.
 * @throws HibernateException If the entity does not define an identifier property, or anerror occurs accessing its value.
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead.
 */
public Serializable getIdentifier(Object entity) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id) throws HibernateException ;
"
"/** 
 * Inject the given identifier and version into the entity, in order to ""roll back"" to their original values.
 * @param entity The entity for which to reset the id/version values
 * @param currentId The identifier value to inject into the entity.
 * @param currentVersion The version value to inject into the entity.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion);
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
@Deprecated @Override public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * Creates a single node AST. <p/> TODO : this is silly, remove it...
 * @param astFactory The factory.
 * @param type The node type.
 * @param text The node text.
 * @return AST - A single node tree.
 * @deprecated silly
 */
public static AST create(ASTFactory astFactory,int type,String text){
  return astFactory.create(type,text);
}
"
"/** 
 * Get the name of a constant defined on the given class which has the given value. <p/> Note, if multiple constants have this value, the first will be returned which is known to be different on different JVM implementations.
 * @param owner The class which defines the constant
 * @param value The value of the constant.
 * @return The token type name, *or* the integer value if the name could not be found.
 * @deprecated Use #getTokenTypeName instead
 */
public static String getConstantName(Class owner,int value){
  return getTokenTypeName(owner,value);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((BasicServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Getter for property 'source'.  This is the session from which the event originated. <p/> Some of the pre-* events had previous exposed the event source using getSource() because they had not originally extended from {@link AbstractEvent}.
 * @return Value for property 'source'.
 * @deprecated Use {@link #getSession} instead
 */
public EventSource getSource(){
  return getSession();
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * @deprecated Use {@link #getValue()}. {@link Value#getTable() getTable()} instead; to be removed on completion of new metamodel code
 * @return
 */
@Deprecated public TableSpecification getTable();
"
"/** 
 * Starts a new Session with the given entity mode in effect. This secondary Session inherits the connection, transaction, and other context information from the primary Session. It doesn't need to be flushed or closed by the developer.
 * @param entityMode The entity mode to use for the new session.
 * @return The new session
 * @deprecated
 */
@Deprecated public Session getSession(EntityMode entityMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * @return
 * @deprecated Use {@link #getValue()}. {@link Value#getTable() getTable()} instead; to be removed on completion of new metamodel code
 */
@Deprecated public TableSpecification getTable();
"
"/** 
 * @return
 * @deprecated Use {@link #getValue()}. {@link Value#getTable() getTable()} instead; to be removed on completion of new metamodel code
 */
@Deprecated public TableSpecification getTable();
"
"/** 
 * Starts a new Session with the given entity mode in effect. This secondary Session inherits the connection, transaction, and other context information from the primary Session. It doesn't need to be flushed or closed by the developer.
 * @param entityMode The entity mode to use for the new session.
 * @return The new session
 * @deprecated
 */
@Deprecated public Session getSession(EntityMode entityMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
@Deprecated public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
@Deprecated public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use {@link #getLoadQueryInfluencers} instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String, String, JoinType, Criterion}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,String,org.hibernate.sql.JoinType,org.hibernate.criterion.Criterion)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * @deprecated use {@link #createAlias(String,String,JoinType)}
 */
@Deprecated public DetachedCriteria createAlias(String associationPath,String alias,int joinType) throws HibernateException {
  return createAlias(associationPath,alias,JoinType.parse(joinType));
}
"
"/** 
 * @deprecated use {@link #createAlias(String,String,JoinType,Criterion)}
 */
@Deprecated public DetachedCriteria createAlias(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException {
  return createAlias(associationPath,alias,JoinType.parse(joinType),withClause);
}
"
"/** 
 * @deprecated use {@link #createCriteria(String,JoinType)}
 */
@Deprecated public DetachedCriteria createCriteria(String associationPath,int joinType) throws HibernateException {
  return createCriteria(associationPath,JoinType.parse(joinType));
}
"
"/** 
 * @deprecated use {@link #createCriteria(String,String,JoinType)}
 */
@Deprecated public DetachedCriteria createCriteria(String associationPath,String alias,int joinType) throws HibernateException {
  return createCriteria(associationPath,alias,JoinType.parse(joinType));
}
"
"/** 
 * @deprecated use {@link #createCriteria(String,String,JoinType,Criterion)}
 */
@Deprecated public DetachedCriteria createCriteria(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException {
  return createCriteria(associationPath,alias,JoinType.parse(joinType),withClause);
}
"
"/** 
 * This form used from annotations (?).  Essentially the same as the above using a resultset-mapping reference, but without cacheMode, readOnly, and comment. FIXME: annotations do not use it, so it can be remove from my POV
 * @deprecated
 * @param query The sql query string
 * @param resultSetRef The result-set-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 */
public NamedSQLQueryDefinition(String query,String resultSetRef,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,Map parameterTypes,boolean callable){
  this(null,query,resultSetRef,querySpaces,cacheable,cacheRegion,timeout,fetchSize,flushMode,null,false,null,parameterTypes,callable);
}
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
public void evictQueries() throws HibernateException ;
"
"/** 
 * This form used from annotations (?).  Essentially the same as the above using a resultset-mapping reference, but without cacheMode, readOnly, and comment. FIXME: annotations do not use it, so it can be remove from my POV
 * @deprecated
 * @param query The sql query string
 * @param resultSetRef The result-set-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 */
public NamedSQLQueryDefinition(String query,String resultSetRef,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,Map parameterTypes,boolean callable){
  this(null,query,resultSetRef,querySpaces,cacheable,cacheRegion,timeout,fetchSize,flushMode,null,false,null,parameterTypes,callable);
}
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
public void evictQueries() throws HibernateException ;
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.impl.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
@Deprecated public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
@Deprecated public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use {@link #getLoadQueryInfluencers} instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * Create an entity instance initialized with the given identifier.
 * @param id The identifier value for the entity to be instantiated.
 * @return The instantiated entity.
 * @throws HibernateException
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id) throws HibernateException ;
"
"/** 
 * Extract the identifier value from the given entity.
 * @param entity The entity from which to extract the identifier value.
 * @return The identifier value.
 * @throws HibernateException If the entity does not define an identifier property, or anerror occurs accessing its value.
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead.
 */
public Serializable getIdentifier(Object entity) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id) throws HibernateException ;
"
"/** 
 * Inject the given identifier and version into the entity, in order to ""roll back"" to their original values.
 * @param entity The entity for which to reset the id/version values
 * @param currentId The identifier value to inject into the entity.
 * @param currentVersion The version value to inject into the entity.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion);
"
"/** 
 * This form used from annotations (?).  Essentially the same as the above using a resultset-mapping reference, but without cacheMode, readOnly, and comment. FIXME: annotations do not use it, so it can be remove from my POV
 * @deprecated
 * @param query The sql query string
 * @param resultSetRef The result-set-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 */
public NamedSQLQueryDefinition(String query,String resultSetRef,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,Map parameterTypes,boolean callable){
  this(null,query,resultSetRef,querySpaces,cacheable,cacheRegion,timeout,fetchSize,flushMode,null,false,null,parameterTypes,callable);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Allow injection of the dialect to use.
 * @param dialect The dialect
 * @deprecated The intention is that Dialect should be required to be specified up-front and it would then getctor injected.
 */
public void setDialect(Dialect dialect);
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Temporary.  Needed for integration with legacy  {@link org.hibernate.mapping} configuration of persisters.
 * @deprecated
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public FetchMode getFetchMode();
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
@Deprecated public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return new Long(value);
  }
 else   if (clazz == Integer.class) {
    return new Integer((int)value);
  }
 else   if (clazz == Short.class) {
    return new Short((short)value);
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((BasicServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((BasicServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Allow injection of the dialect to use.
 * @param dialect The dialect
 * @deprecated The intention is that Dialect should be required to be specified up-front and it would then getctor injected.
 */
public void setDialect(Dialect dialect);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((BasicServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(Environment.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries() throws HibernateException ;
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String, String, JoinType, Criterion}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,String,org.hibernate.sql.JoinType,org.hibernate.criterion.Criterion)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries() throws HibernateException ;
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * @deprecated use {@link #createAlias(String,String,JoinType)}
 */
@Deprecated public DetachedCriteria createAlias(String associationPath,String alias,int joinType) throws HibernateException {
  return createAlias(associationPath,alias,JoinType.parse(joinType));
}
"
"/** 
 * @deprecated use {@link #createAlias(String,String,JoinType,Criterion)}
 */
@Deprecated public DetachedCriteria createAlias(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException {
  return createAlias(associationPath,alias,JoinType.parse(joinType),withClause);
}
"
"/** 
 * @deprecated use {@link #createCriteria(String,JoinType)}
 */
@Deprecated public DetachedCriteria createCriteria(String associationPath,int joinType) throws HibernateException {
  return createCriteria(associationPath,JoinType.parse(joinType));
}
"
"/** 
 * @deprecated use {@link #createCriteria(String,String,JoinType)}
 */
@Deprecated public DetachedCriteria createCriteria(String associationPath,String alias,int joinType) throws HibernateException {
  return createCriteria(associationPath,alias,JoinType.parse(joinType));
}
"
"/** 
 * @deprecated use {@link #createCriteria(String,String,JoinType,Criterion)}
 */
@Deprecated public DetachedCriteria createCriteria(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException {
  return createCriteria(associationPath,alias,JoinType.parse(joinType),withClause);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use {@link #getLoadQueryInfluencers} instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * Creates a single node AST. <p/> TODO : this is silly, remove it...
 * @param astFactory The factory.
 * @param type The node type.
 * @param text The node text.
 * @return AST - A single node tree.
 * @deprecated silly
 */
public static AST create(ASTFactory astFactory,int type,String text){
  return astFactory.create(type,text);
}
"
"/** 
 * Get the name of a constant defined on the given class which has the given value. <p/> Note, if multiple constants have this value, the first will be returned which is known to be different on different JVM implementations.
 * @param owner The class which defines the constant
 * @param value The value of the constant.
 * @return The token type name, *or* the integer value if the name could not be found.
 * @deprecated Use #getTokenTypeName instead
 */
public static String getConstantName(Class owner,int value){
  return getTokenTypeName(owner,value);
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
@Deprecated public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return new Long(value);
  }
 else   if (clazz == Integer.class) {
    return new Integer((int)value);
  }
 else   if (clazz == Short.class) {
    return new Short((short)value);
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  String optimizerClassName;
  if (NONE.equals(type)) {
    optimizerClassName=NoopOptimizer.class.getName();
  }
 else   if (HILO.equals(type)) {
    optimizerClassName=HiLoOptimizer.class.getName();
  }
 else   if (LEGACY_HILO.equals(type)) {
    optimizerClassName=LegacyHiLoAlgorithmOptimizer.class.getName();
  }
 else   if (POOL.equals(type)) {
    optimizerClassName=PooledOptimizer.class.getName();
  }
 else   if (POOL_LO.equals(type)) {
    optimizerClassName=PooledLoOptimizer.class.getName();
  }
 else {
    optimizerClassName=type;
  }
  try {
    Class optimizerClass=ReflectHelper.classForName(optimizerClassName);
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return new NoopOptimizer(returnClass,incrementSize);
}
"
"/** 
 * Allow injection of the dialect to use.
 * @param dialect The dialect
 * @deprecated The intention is that Dialect should be required to be specified up-front and it would then getctor injected.
 */
public void setDialect(Dialect dialect);
"
"/** 
 * Load an entity instance. If <tt>optionalObject</tt> is supplied, load the entity state into the given (uninitialized) object.
 * @deprecated use {@link #load(java.io.Serializable,Object,SessionImplementor,LockOptions)} instead.
 * @noinspection JavaDoc
 */
public Object load(Serializable id,Object optionalObject,SessionImplementor session) throws HibernateException ;
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(String name,String value){
  target().setAttributeValue(name,value);
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(QName qName,String value){
  target().setAttributeValue(qName,value);
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #renderOrderByStringTemplate(String,ColumnMapper,SessionFactoryImplementor,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(String name,String value){
  element.setAttributeValue(name,value);
}
"
"/** 
 * @deprecated
 */
public void setAttributeValue(QName qName,String value){
  element.setAttributeValue(qName,value);
}
"
"/** 
 * Create an entity instance initialized with the given identifier.
 * @param id The identifier value for the entity to be instantiated.
 * @return The instantiated entity.
 * @throws HibernateException
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public Object instantiate(Serializable id) throws HibernateException ;
"
"/** 
 * Extract the identifier value from the given entity.
 * @param entity The entity from which to extract the identifier value.
 * @return The identifier value.
 * @throws HibernateException If the entity does not define an identifier property, or anerror occurs accessing its value.
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead.
 */
public Serializable getIdentifier(Object entity) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 * @noinspection JavaDoc
 */
public void setIdentifier(Object entity,Serializable id) throws HibernateException ;
"
"/** 
 * Inject the given identifier and version into the entity, in order to ""roll back"" to their original values.
 * @param entity The entity for which to reset the id/version values
 * @param currentId The identifier value to inject into the entity.
 * @param currentVersion The version value to inject into the entity.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion);
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
@Deprecated public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return new Long(value);
  }
 else   if (clazz == Integer.class) {
    return new Integer((int)value);
  }
 else   if (clazz == Short.class) {
    return new Short((short)value);
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  String optimizerClassName;
  if (NONE.equals(type)) {
    optimizerClassName=NoopOptimizer.class.getName();
  }
 else   if (HILO.equals(type)) {
    optimizerClassName=HiLoOptimizer.class.getName();
  }
 else   if (LEGACY_HILO.equals(type)) {
    optimizerClassName=LegacyHiLoAlgorithmOptimizer.class.getName();
  }
 else   if (POOL.equals(type)) {
    optimizerClassName=PooledOptimizer.class.getName();
  }
 else   if (POOL_LO.equals(type)) {
    optimizerClassName=PooledLoOptimizer.class.getName();
  }
 else {
    optimizerClassName=type;
  }
  try {
    Class optimizerClass=ReflectHelper.classForName(optimizerClassName);
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return new NoopOptimizer(returnClass,incrementSize);
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Creates a single node AST. <p/> TODO : this is silly, remove it...
 * @param astFactory The factory.
 * @param type The node type.
 * @param text The node text.
 * @return AST - A single node tree.
 * @deprecated silly
 */
public static AST create(ASTFactory astFactory,int type,String text){
  return astFactory.create(type,text);
}
"
"/** 
 * Get the name of a constant defined on the given class which has the given value. <p/> Note, if multiple constants have this value, the first will be returned which is known to be different on different JVM implementations.
 * @param owner The class which defines the constant
 * @param value The value of the constant.
 * @return The token type name, *or* the integer value if the name could not be found.
 * @deprecated Use #getTokenTypeName instead
 */
public static String getConstantName(Class owner,int value){
  return getTokenTypeName(owner,value);
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
@Deprecated public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return value;
  }
 else   if (clazz == Integer.class) {
    return (int)value;
  }
 else   if (clazz == Short.class) {
    return (short)value;
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Creates a single node AST. <p/> TODO : this is silly, remove it...
 * @param astFactory The factory.
 * @param type The node type.
 * @param text The node text.
 * @return AST - A single node tree.
 * @deprecated silly
 */
public static AST create(ASTFactory astFactory,int type,String text){
  return astFactory.create(type,text);
}
"
"/** 
 * Get the name of a constant defined on the given class which has the given value. <p/> Note, if multiple constants have this value, the first will be returned which is known to be different on different JVM implementations.
 * @param owner The class which defines the constant
 * @param value The value of the constant.
 * @return The token type name, *or* the integer value if the name could not be found.
 * @deprecated Use #getTokenTypeName instead
 */
public static String getConstantName(Class owner,int value){
  return getTokenTypeName(owner,value);
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
@Deprecated public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return value;
  }
 else   if (clazz == Integer.class) {
    return (int)value;
  }
 else   if (clazz == Short.class) {
    return (short)value;
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
  this.serviceRegistry=createServiceRegistry(props);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @param schema
 * @param catalog
 * @param realTableName
 * @param logicalName
 * @param isAbstract
 * @param uniqueConstraints
 * @param constraints
 * @param denormalizedSuperTable
 * @param mappings
 * @return
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing"",""unchecked""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing"",""unchecked""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing"",""unchecked""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
@Deprecated public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
@Deprecated public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Support for legacy  {@link Session#load(Class,Serializable,LockMode)} and {@link Session#load(String,Serializable,LockMode)}
 * @deprecated
 */
@Deprecated public final IdentifierLoadAccessImpl<T> with(LockMode lockMode){
  if (this.lockOptions != null) {
    throw new IllegalArgumentException(""Cannot specify by LockOptions and LockMode on a single IdentifierLoadAccessImpl"");
  }
  this.lockMode=lockMode;
  return this;
}
"
"/** 
 * Support for legacy  {@link Session#load(Class,Serializable,LockMode)} and {@link Session#load(String,Serializable,LockMode)}
 * @deprecated
 */
@Deprecated public final IdentifierLoadAccessImpl<T> with(LockMode lockMode){
  this.lockOptions=new LockOptions();
  this.lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
@Deprecated public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
@Deprecated public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
@Deprecated public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
@Deprecated public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Support for legacy  {@link Session#load(Class,Serializable,LockMode)} and {@link Session#load(String,Serializable,LockMode)}
 * @deprecated
 */
@Deprecated public final IdentifierLoadAccessImpl<T> with(LockMode lockMode){
  this.lockOptions=new LockOptions();
  this.lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Support for legacy  {@link Session#load(Class,Serializable,LockMode)} and {@link Session#load(String,Serializable,LockMode)}
 * @deprecated
 */
@Deprecated public final IdentifierLoadAccessImpl<T> with(LockMode lockMode){
  this.lockOptions=new LockOptions();
  this.lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 * @noinspection JavaDoc
 */
public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,JoinType,Criterion)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,String,org.hibernate.sql.JoinType,org.hibernate.criterion.Criterion)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(Class theClass,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
@Deprecated public void lock(Object object,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
@SuppressWarnings({""JavaDoc""}) @Deprecated public void lock(String entityName,Object object,LockMode lockMode);
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public void refresh(Object object,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(Class clazz,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Support for legacy  {@link Session#load(Class,Serializable,LockMode)} and {@link Session#load(String,Serializable,LockMode)}
 * @deprecated
 */
@Deprecated public final IdentifierLoadAccessImpl<T> with(LockMode lockMode){
  this.lockOptions=new LockOptions();
  this.lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(Class theClass,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
@Deprecated public void lock(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @throws HibernateException
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
@Deprecated public void lock(String entityName,Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public void refresh(Object object,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(Class clazz,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @throws HibernateException
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(String entityName,Serializable id,LockMode lockMode) throws HibernateException ;
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Allow access to the id generator factory, though this is only needed/allowed from configuration.
 * @return Access to the identifier generator factory
 * @deprecated temporary solution 
 */
public IdentifierGeneratorFactory getIdentifierGeneratorFactory();
"
"/** 
 * Load an entity instance. If <tt>optionalObject</tt> is supplied, load the entity state into the given (uninitialized) object.
 * @deprecated use {@link #load(java.io.Serializable,Object,SessionImplementor,LockOptions)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public Object load(Serializable id,Object optionalObject,SessionImplementor session) throws HibernateException ;
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Temporary.  Needed for integration with legacy org.hibernate.mapping configuration of persisters.
 * @deprecated
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public FetchMode getFetchMode();
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Create an entity instance initialized with the given identifier.
 * @param id The identifier value for the entity to be instantiated.
 * @return The instantiated entity.
 * @throws HibernateException
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public Object instantiate(Serializable id) throws HibernateException ;
"
"/** 
 * Extract the identifier value from the given entity.
 * @param entity The entity from which to extract the identifier value.
 * @return The identifier value.
 * @throws HibernateException If the entity does not define an identifier property, or anerror occurs accessing its value.
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead.
 */
public Serializable getIdentifier(Object entity) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public void setIdentifier(Object entity,Serializable id) throws HibernateException ;
"
"/** 
 * Inject the given identifier and version into the entity, in order to ""roll back"" to their original values.
 * @param entity The entity for which to reset the id/version values
 * @param currentId The identifier value to inject into the entity.
 * @param currentVersion The version value to inject into the entity.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(Class theClass,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
@Deprecated public void lock(Object object,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
@SuppressWarnings({""JavaDoc""}) @Deprecated public void lock(String entityName,Object object,LockMode lockMode);
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public void refresh(Object object,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(Class clazz,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,JoinType,Criterion)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,String,org.hibernate.sql.JoinType,org.hibernate.criterion.Criterion)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(Class theClass,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
@Deprecated public void lock(Object object,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
@SuppressWarnings({""JavaDoc""}) @Deprecated public void lock(String entityName,Object object,LockMode lockMode);
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public void refresh(Object object,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(Class clazz,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Allow access to the id generator factory, though this is only needed/allowed from configuration.
 * @return Access to the identifier generator factory
 * @deprecated temporary solution 
 */
public IdentifierGeneratorFactory getIdentifierGeneratorFactory();
"
"/** 
 * Load an entity instance. If <tt>optionalObject</tt> is supplied, load the entity state into the given (uninitialized) object.
 * @deprecated use {@link #load(java.io.Serializable,Object,SessionImplementor,LockOptions)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public Object load(Serializable id,Object optionalObject,SessionImplementor session) throws HibernateException ;
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Temporary.  Needed for integration with legacy org.hibernate.mapping configuration of persisters.
 * @deprecated
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public FetchMode getFetchMode();
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Create an entity instance initialized with the given identifier.
 * @param id The identifier value for the entity to be instantiated.
 * @return The instantiated entity.
 * @throws HibernateException
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public Object instantiate(Serializable id) throws HibernateException ;
"
"/** 
 * Extract the identifier value from the given entity.
 * @param entity The entity from which to extract the identifier value.
 * @return The identifier value.
 * @throws HibernateException If the entity does not define an identifier property, or anerror occurs accessing its value.
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead.
 */
public Serializable getIdentifier(Object entity) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public void setIdentifier(Object entity,Serializable id) throws HibernateException ;
"
"/** 
 * Inject the given identifier and version into the entity, in order to ""roll back"" to their original values.
 * @param entity The entity for which to reset the id/version values
 * @param currentId The identifier value to inject into the entity.
 * @param currentVersion The version value to inject into the entity.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion);
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
@Deprecated public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return value;
  }
 else   if (clazz == Integer.class) {
    return (int)value;
  }
 else   if (clazz == Short.class) {
    return (short)value;
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
@Deprecated public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return value;
  }
 else   if (clazz == Integer.class) {
    return (int)value;
  }
 else   if (clazz == Short.class) {
    return (short)value;
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return new Long(value);
  }
 else   if (clazz == Integer.class) {
    return new Integer((int)value);
  }
 else   if (clazz == Short.class) {
    return new Short((short)value);
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@SuppressWarnings({""UnnecessaryBoxing"",""unchecked""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      log.warn(""Unable to interpret specified optimizer [{}], falling back to noop"",type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    log.warn(""Unable to instantiate specified optimizer [{}], falling back to noop"",type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * @deprecated Use {@link Session#byNaturalId(Class)}
 * @see Session#byNaturalId(Class)
 * @see Session#byNaturalId(String)
 * @see Session#bySimpleNaturalId(Class)
 * @see Session#bySimpleNaturalId(String)
 */
@Deprecated public static NaturalIdentifier naturalId(){
  return new NaturalIdentifier();
}
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Create an entity instance initialized with the given identifier.
 * @param id The identifier value for the entity to be instantiated.
 * @return The instantiated entity.
 * @throws HibernateException
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public Object instantiate(Serializable id) throws HibernateException ;
"
"/** 
 * Extract the identifier value from the given entity.
 * @param entity The entity from which to extract the identifier value.
 * @return The identifier value.
 * @throws HibernateException If the entity does not define an identifier property, or anerror occurs accessing its value.
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead.
 */
public Serializable getIdentifier(Object entity) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public void setIdentifier(Object entity,Serializable id) throws HibernateException ;
"
"/** 
 * Inject the given identifier and version into the entity, in order to ""roll back"" to their original values.
 * @param entity The entity for which to reset the id/version values
 * @param currentId The identifier value to inject into the entity.
 * @param currentVersion The version value to inject into the entity.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion);
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Creates a single node AST. <p/> TODO : this is silly, remove it...
 * @param astFactory The factory.
 * @param type The node type.
 * @param text The node text.
 * @return AST - A single node tree.
 * @deprecated silly
 */
public static AST create(ASTFactory astFactory,int type,String text){
  return astFactory.create(type,text);
}
"
"/** 
 * Get the name of a constant defined on the given class which has the given value. <p/> Note, if multiple constants have this value, the first will be returned which is known to be different on different JVM implementations.
 * @param owner The class which defines the constant
 * @param value The value of the constant.
 * @return The token type name, *or* the integer value if the name could not be found.
 * @deprecated Use #getTokenTypeName instead
 */
public static String getConstantName(Class owner,int value){
  return getTokenTypeName(owner,value);
}
"
"/** 
 * Get the current lock mode
 * @return LockMode
 * @deprecated Instead use getLockOptions
 */
public LockMode getLockMode(){
  return lockOptions.getLockMode();
}
"
"/** 
 * Set the lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public Select setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #renderOrderByStringTemplate(String,ColumnMapper,SessionFactoryImplementor,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(java.util.Iterator,org.hibernate.engine.spi.SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,sessionFactory,false);
}
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries() throws HibernateException ;
"
"/** 
 * @deprecated Use {@link org.hibernate.SessionFactory.SessionFactoryOptions#getCustomEntityDirtinessStrategy()}instead.
 */
@Deprecated @SuppressWarnings(""JavaDoc"") public CustomEntityDirtinessStrategy getCustomEntityDirtinessStrategy();
"
"/** 
 * @deprecated Use {@link org.hibernate.SessionFactory.SessionFactoryOptions#getCustomEntityDirtinessStrategy()}instead.
 */
@Deprecated @SuppressWarnings(""JavaDoc"") public CurrentTenantIdentifierResolver getCurrentTenantIdentifierResolver();
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(java.util.Iterator,org.hibernate.engine.spi.SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,sessionFactory,false);
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Should the session be automatically closed after transaction completion
 * @param autoClose Should the session be automatically closed
 * @return {@code this}, for method chaining
 * @deprecated Only integrations can specify autoClosing behavior of individual sessions.  See{@link org.hibernate.engine.spi.SessionOwner}
 */
@Deprecated public SessionBuilder autoClose(boolean autoClose);
"
"/** 
 * Signifies that the autoClose flag from the original session should be used to create the new session
 * @return {@code this}, for method chaining
 * @deprecated For same reasons as {@link SessionBuilder#autoClose(boolean)} was deprecated.  However, sharedsession builders can use  {@link #autoClose(boolean)} since they do not ""inherit"" the owner.
 */
@Deprecated public SharedSessionBuilder autoClose();
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(java.util.Iterator,org.hibernate.engine.spi.SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,sessionFactory,false);
}
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(java.util.Iterator,org.hibernate.engine.spi.SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,sessionFactory,false);
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #translateOrderBy} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing"",""unchecked""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * This form is used to bind named queries from Hibernate metadata, both  {@code hbm.xml} files and{@link org.hibernate.annotations.NamedQuery} annotation.
 * @param name The name under which to key/register the query
 * @param query The query string.
 * @param cacheable Is the query cacheable?
 * @param cacheRegion If cacheable, was there a specific region named?
 * @param timeout Query timeout, {@code null} indicates no timeout
 * @param fetchSize Fetch size associated with the query, {@code null} indicates no limit
 * @param flushMode Flush mode associated with query
 * @param cacheMode Cache mode associated with query
 * @param readOnly Should entities returned from this query (those not already associated with the Session anyway)be loaded as read-only?
 * @param comment SQL comment to be used in the generated SQL, {@code null} indicates none
 * @param parameterTypes (no idea, afaict this is always passed as null)
 * @deprecated Use {@link NamedQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedQueryDefinition(String name,String query,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes){
  this(name,query,cacheable,cacheRegion,timeout,LockOptions.WAIT_FOREVER,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes);
}
"
"/** 
 * This version is used to bind named queries defined via  {@link javax.persistence.NamedQuery}.
 * @param name The name under which to key/register the query
 * @param query The query string.
 * @param cacheable Is the query cacheable?
 * @param cacheRegion If cacheable, was there a specific region named?
 * @param timeout Query timeout, {@code null} indicates no timeout
 * @param lockTimeout Specifies the lock timeout for queries that apply lock modes.
 * @param fetchSize Fetch size associated with the query, {@code null} indicates no limit
 * @param flushMode Flush mode associated with query
 * @param cacheMode Cache mode associated with query
 * @param readOnly Should entities returned from this query (those not already associated with the Session anyway)be loaded as read-only?
 * @param comment SQL comment to be used in the generated SQL, {@code null} indicates none
 * @param parameterTypes (no idea, afaict this is always passed as null)
 * @deprecated Use {@link NamedQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedQueryDefinition(String name,String query,boolean cacheable,String cacheRegion,Integer timeout,Integer lockTimeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes){
  this(name,query,cacheable,cacheRegion,timeout,new LockOptions().setTimeOut(lockTimeout),fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a the result-set mapping information is not explicitly  provided in the query definition (i.e., no resultset-mapping used).
 * @param name The name of named query
 * @param query The sql query string
 * @param queryReturns The in-lined query return definitions
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,NativeSQLQueryReturn[] queryReturns,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,null,querySpaces,callable,queryReturns);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a resultset-mapping reference is used.
 * @param name The name of named query
 * @param query The sql query string
 * @param resultSetRef The resultset-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,String resultSetRef,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,resultSetRef,querySpaces,callable,null);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(java.util.Iterator,org.hibernate.engine.spi.SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,sessionFactory,false);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Use {@link org.hibernate.SessionFactory.SessionFactoryOptions#getCustomEntityDirtinessStrategy()}instead.
 */
@Deprecated @SuppressWarnings(""JavaDoc"") public CustomEntityDirtinessStrategy getCustomEntityDirtinessStrategy();
"
"/** 
 * @deprecated Use {@link org.hibernate.SessionFactory.SessionFactoryOptions#getCustomEntityDirtinessStrategy()}instead.
 */
@Deprecated @SuppressWarnings(""JavaDoc"") public CurrentTenantIdentifierResolver getCurrentTenantIdentifierResolver();
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link org.hibernate.mapping.PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(java.util.Iterator,org.hibernate.engine.spi.SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,sessionFactory,false);
}
"
"/** 
 * Specifically builds and returns a EntityManagerFactoryBuilder that leverages the new metamodel codebase. Eventually this will be the normal operation of  {@link #getEntityManagerFactoryBuilder(PersistenceUnitDescriptor,Map)}, but for now due to the incompleteness of the metamodel codebase, this is not integrated as the main way to build the EntityManagerFactoryBuilder.  This allows tests in the nor-core modules to keep running.
 * @deprecated This is a temporary method until metamodel codebase is more complete
 */
@Deprecated public static EntityManagerFactoryBuilder getEntityManagerFactoryBuilderUsingMetamodel(PersistenceUnitDescriptor persistenceUnitDescriptor,Map integration){
  return new EntityManagerFactoryBuilderUsingMetamodelImpl(persistenceUnitDescriptor,integration);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * This form is used to bind named queries from Hibernate metadata, both  {@code hbm.xml} files and{@link org.hibernate.annotations.NamedQuery} annotation.
 * @param name The name under which to key/register the query
 * @param query The query string.
 * @param cacheable Is the query cacheable?
 * @param cacheRegion If cacheable, was there a specific region named?
 * @param timeout Query timeout, {@code null} indicates no timeout
 * @param fetchSize Fetch size associated with the query, {@code null} indicates no limit
 * @param flushMode Flush mode associated with query
 * @param cacheMode Cache mode associated with query
 * @param readOnly Should entities returned from this query (those not already associated with the Session anyway)be loaded as read-only?
 * @param comment SQL comment to be used in the generated SQL, {@code null} indicates none
 * @param parameterTypes (no idea, afaict this is always passed as null)
 * @deprecated Use {@link NamedQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedQueryDefinition(String name,String query,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes){
  this(name,query,cacheable,cacheRegion,timeout,LockOptions.WAIT_FOREVER,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes);
}
"
"/** 
 * This version is used to bind named queries defined via  {@link javax.persistence.NamedQuery}.
 * @param name The name under which to key/register the query
 * @param query The query string.
 * @param cacheable Is the query cacheable?
 * @param cacheRegion If cacheable, was there a specific region named?
 * @param timeout Query timeout, {@code null} indicates no timeout
 * @param lockTimeout Specifies the lock timeout for queries that apply lock modes.
 * @param fetchSize Fetch size associated with the query, {@code null} indicates no limit
 * @param flushMode Flush mode associated with query
 * @param cacheMode Cache mode associated with query
 * @param readOnly Should entities returned from this query (those not already associated with the Session anyway)be loaded as read-only?
 * @param comment SQL comment to be used in the generated SQL, {@code null} indicates none
 * @param parameterTypes (no idea, afaict this is always passed as null)
 * @deprecated Use {@link NamedQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedQueryDefinition(String name,String query,boolean cacheable,String cacheRegion,Integer timeout,Integer lockTimeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes){
  this(name,query,cacheable,cacheRegion,timeout,new LockOptions().setTimeOut(lockTimeout),fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a the result-set mapping information is not explicitly  provided in the query definition (i.e., no resultset-mapping used).
 * @param name The name of named query
 * @param query The sql query string
 * @param queryReturns The in-lined query return definitions
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,NativeSQLQueryReturn[] queryReturns,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,null,querySpaces,callable,queryReturns);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a resultset-mapping reference is used.
 * @param name The name of named query
 * @param query The sql query string
 * @param resultSetRef The resultset-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,String resultSetRef,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,resultSetRef,querySpaces,callable,null);
}
"
"/** 
 * @deprecated Use {@link org.hibernate.SessionFactory.SessionFactoryOptions#getCustomEntityDirtinessStrategy()}instead.
 */
@Deprecated @SuppressWarnings(""JavaDoc"") public CustomEntityDirtinessStrategy getCustomEntityDirtinessStrategy();
"
"/** 
 * @deprecated Use {@link org.hibernate.SessionFactory.SessionFactoryOptions#getCustomEntityDirtinessStrategy()}instead.
 */
@Deprecated @SuppressWarnings(""JavaDoc"") public CurrentTenantIdentifierResolver getCurrentTenantIdentifierResolver();
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing"",""unchecked""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Get the current lock mode
 * @return LockMode
 * @deprecated Instead use getLockOptions
 */
public LockMode getLockMode(){
  return lockOptions.getLockMode();
}
"
"/** 
 * Set the lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public Select setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #translateOrderBy} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(java.util.Iterator,org.hibernate.engine.spi.SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,sessionFactory,false);
}
"
"/** 
 * @deprecated Use {@link #getText} instead
 */
@Deprecated public String getName(){
  return text;
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use {@link #getLoadQueryInfluencers} instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * Should the session be automatically closed after transaction completion
 * @param autoClose Should the session be automatically closed
 * @return {@code this}, for method chaining
 * @deprecated Only integrations can specify autoClosing behavior of individual sessions.  See{@link org.hibernate.engine.spi.SessionOwner}
 */
@Deprecated public SessionBuilder autoClose(boolean autoClose);
"
"/** 
 * Signifies that the autoClose flag from the original session should be used to create the new session
 * @return {@code this}, for method chaining
 * @deprecated For same reasons as {@link SessionBuilder#autoClose(boolean)} was deprecated.  However, sharedsession builders can use  {@link #autoClose(boolean)} since they do not ""inherit"" the owner.
 */
@Deprecated public SharedSessionBuilder autoClose();
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Lifecycle callback to perform any necessary initialization of the underlying cache implementation(s).  Called exactly once during the construction of a  {@link org.hibernate.internal.SessionFactoryImpl}.
 * @param settings The settings in effect.
 * @param properties The defined cfg properties
 * @throws org.hibernate.cache.CacheException Indicates problems starting the L2 cache impl;considered as a sign to stop  {@link org.hibernate.SessionFactory}building.
 * @deprecated use {@code start} to in favor of {@link org.hibernate.service.ServiceRegistry}.
 */
@Deprecated public void start(Settings settings,Properties properties) throws CacheException ;
"
"/** 
 * Close all cache regions.
 * @deprecated use @{code Stoppable#stop}.
 */
@Deprecated public void close();
"
"/** 
 * @deprecated Use {@link org.hibernate.SessionFactory.SessionFactoryOptions#getCustomEntityDirtinessStrategy()}instead.
 */
@Deprecated @SuppressWarnings(""JavaDoc"") public CustomEntityDirtinessStrategy getCustomEntityDirtinessStrategy();
"
"/** 
 * @deprecated Use {@link org.hibernate.SessionFactory.SessionFactoryOptions#getCustomEntityDirtinessStrategy()}instead.
 */
@Deprecated @SuppressWarnings(""JavaDoc"") public CurrentTenantIdentifierResolver getCurrentTenantIdentifierResolver();
"
"/** 
 * Creates a single node AST. <p/> TODO : this is silly, remove it...
 * @param astFactory The factory.
 * @param type The node type.
 * @param text The node text.
 * @return AST - A single node tree.
 * @deprecated silly
 */
public static AST create(ASTFactory astFactory,int type,String text){
  return astFactory.create(type,text);
}
"
"/** 
 * Get the name of a constant defined on the given class which has the given value. <p/> Note, if multiple constants have this value, the first will be returned which is known to be different on different JVM implementations.
 * @param owner The class which defines the constant
 * @param value The value of the constant.
 * @return The token type name, *or* the integer value if the name could not be found.
 * @deprecated Use #getTokenTypeName instead
 */
public static String getConstantName(Class owner,int value){
  return getTokenTypeName(owner,value);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Get the current lock mode
 * @return LockMode
 * @deprecated Instead use getLockOptions
 */
public LockMode getLockMode(){
  return lockOptions.getLockMode();
}
"
"/** 
 * Set the lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public Select setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #renderOrderByStringTemplate(String,ColumnMapper,SessionFactoryImplementor,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Get the current lock mode
 * @return LockMode
 * @deprecated Instead use getLockOptions
 */
public LockMode getLockMode(){
  return lockOptions.getLockMode();
}
"
"/** 
 * Set the lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public Select setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Obtain service for providing JDBC connections.
 * @return The connection provider.
 * @deprecated See deprecation notice on {@link org.hibernate.engine.spi.SessionFactoryImplementor#getConnectionProvider()}for details
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * Get the connection provider
 * @deprecated Access to connections via {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} shouldbe preferred over access via  {@link ConnectionProvider}, whenever possible. {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} is tied to the Hibernate Session toproperly account for contextual information.  See  {@link SessionImplementor#getJdbcConnectionAccess()}
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * Obtain service for providing JDBC connections.
 * @return The connection provider.
 * @deprecated See deprecation notice on {@link org.hibernate.engine.spi.SessionFactoryImplementor#getConnectionProvider()}for details
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * Get the connection provider
 * @deprecated Access to connections via {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} shouldbe preferred over access via  {@link ConnectionProvider}, whenever possible. {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} is tied to the Hibernate Session toproperly account for contextual information.  See  {@link SessionImplementor#getJdbcConnectionAccess()}
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing"",""unchecked""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing"",""unchecked""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * Obtain service for providing JDBC connections.
 * @return The connection provider.
 * @deprecated See deprecation notice on {@link org.hibernate.engine.spi.SessionFactoryImplementor#getConnectionProvider()}for details
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * Get the connection provider
 * @deprecated Access to connections via {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} shouldbe preferred over access via  {@link ConnectionProvider}, whenever possible. {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} is tied to the Hibernate Session toproperly account for contextual information.  See  {@link SessionImplementor#getJdbcConnectionAccess()}
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * @deprecated Use {@link org.hibernate.SessionFactory.SessionFactoryOptions#getCustomEntityDirtinessStrategy()}instead.
 */
@Deprecated @SuppressWarnings(""JavaDoc"") public CustomEntityDirtinessStrategy getCustomEntityDirtinessStrategy();
"
"/** 
 * @deprecated Use {@link org.hibernate.SessionFactory.SessionFactoryOptions#getCustomEntityDirtinessStrategy()}instead.
 */
@Deprecated @SuppressWarnings(""JavaDoc"") public CurrentTenantIdentifierResolver getCurrentTenantIdentifierResolver();
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing"",""unchecked""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Get the current lock mode
 * @return LockMode
 * @deprecated Instead use getLockOptions
 */
public LockMode getLockMode(){
  return lockOptions.getLockMode();
}
"
"/** 
 * Set the lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public Select setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Obtain service for providing JDBC connections.
 * @return The connection provider.
 * @deprecated See deprecation notice on {@link org.hibernate.engine.spi.SessionFactoryImplementor#getConnectionProvider()}for details
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * Get the connection provider
 * @deprecated Access to connections via {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} shouldbe preferred over access via  {@link ConnectionProvider}, whenever possible. {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} is tied to the Hibernate Session toproperly account for contextual information.  See  {@link SessionImplementor#getJdbcConnectionAccess()}
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * @deprecated Use {@link org.hibernate.SessionFactory.SessionFactoryOptions#getCustomEntityDirtinessStrategy()}instead.
 */
@Deprecated @SuppressWarnings(""JavaDoc"") public CustomEntityDirtinessStrategy getCustomEntityDirtinessStrategy();
"
"/** 
 * @deprecated Use {@link org.hibernate.SessionFactory.SessionFactoryOptions#getCustomEntityDirtinessStrategy()}instead.
 */
@Deprecated @SuppressWarnings(""JavaDoc"") public CurrentTenantIdentifierResolver getCurrentTenantIdentifierResolver();
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use {@link #getLoadQueryInfluencers} instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link org.hibernate.mapping.PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(java.util.Iterator,org.hibernate.engine.spi.SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,sessionFactory,false);
}
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries() throws HibernateException ;
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Obtain service for providing JDBC connections.
 * @return The connection provider.
 * @deprecated See deprecation notice on {@link org.hibernate.engine.spi.SessionFactoryImplementor#getConnectionProvider()}for details
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * Get the connection provider
 * @deprecated Access to connections via {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} shouldbe preferred over access via  {@link ConnectionProvider}, whenever possible. {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} is tied to the Hibernate Session toproperly account for contextual information.  See  {@link SessionImplementor#getJdbcConnectionAccess()}
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries() throws HibernateException ;
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Obtain service for providing JDBC connections.
 * @return The connection provider.
 * @deprecated See deprecation notice on {@link org.hibernate.engine.spi.SessionFactoryImplementor#getConnectionProvider()}for details
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * Get the connection provider
 * @deprecated Access to connections via {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} shouldbe preferred over access via  {@link ConnectionProvider}, whenever possible. {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} is tied to the Hibernate Session toproperly account for contextual information.  See  {@link SessionImplementor#getJdbcConnectionAccess()}
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * @deprecated Use {@link org.hibernate.SessionFactory.SessionFactoryOptions#getCustomEntityDirtinessStrategy()}instead.
 */
@Deprecated @SuppressWarnings(""JavaDoc"") public CustomEntityDirtinessStrategy getCustomEntityDirtinessStrategy();
"
"/** 
 * @deprecated Use {@link org.hibernate.SessionFactory.SessionFactoryOptions#getCustomEntityDirtinessStrategy()}instead.
 */
@Deprecated @SuppressWarnings(""JavaDoc"") public CurrentTenantIdentifierResolver getCurrentTenantIdentifierResolver();
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries() throws HibernateException ;
"
"/** 
 * Applies the specified  {@link ClassLoader} as the application class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the resource class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the Hibernate class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Obtain service for providing JDBC connections.
 * @return The connection provider.
 * @deprecated See deprecation notice on {@link org.hibernate.engine.spi.SessionFactoryImplementor#getConnectionProvider()}for details
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use {@link #getLoadQueryInfluencers} instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated Use {@link #getText} instead
 */
@Deprecated public String getName(){
  return text;
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(java.util.Iterator,org.hibernate.engine.spi.SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,sessionFactory,false);
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Load an entity instance. If <tt>optionalObject</tt> is supplied, load the entity state into the given (uninitialized) object.
 * @deprecated use {@link #load(java.io.Serializable,Object,SessionImplementor,LockOptions)} instead.
 */
@SuppressWarnings({""JavaDoc""}) @Deprecated public Object load(Serializable id,Object optionalObject,SessionImplementor session) throws HibernateException ;
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Return a string representation of this value, as it should appear in an XML document
 * @deprecated To be removed in 5.  Implement {@link org.hibernate.type.StringRepresentableType#toString(Object)}instead.  See <a href=""https://hibernate.onjira.com/browse/HHH-7776"">HHH-7776</a> for details
 */
@Deprecated public String toXMLString(Object value);
"
"/** 
 * Parse a string representation of this value, as it appears in an XML document
 * @deprecated To be removed in 5.  Implement{@link org.hibernate.type.StringRepresentableType#fromStringValue(String)} instead.See <a href=""https://hibernate.onjira.com/browse/HHH-7776"">HHH-7776</a> for details
 */
@Deprecated public Object fromXMLString(String xmlValue);
"
"/** 
 * Return a string representation of this value, as it should appear in an XML document
 * @deprecated To be removed in 5.  Implement {@link org.hibernate.type.StringRepresentableType#toString(Object)}instead.  See <a href=""https://hibernate.onjira.com/browse/HHH-7776"">HHH-7776</a> for details
 */
@Deprecated public String toXMLString(Object value);
"
"/** 
 * Parse a string representation of this value, as it appears in an XML document
 * @deprecated To be removed in 5.  Implement{@link org.hibernate.type.StringRepresentableType#fromStringValue(String)} instead.See <a href=""https://hibernate.onjira.com/browse/HHH-7776"">HHH-7776</a> for details
 */
@Deprecated public Object fromXMLString(String xmlValue);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Load an entity instance. If <tt>optionalObject</tt> is supplied, load the entity state into the given (uninitialized) object.
 * @deprecated use {@link #load(java.io.Serializable,Object,SessionImplementor,LockOptions)} instead.
 */
@SuppressWarnings({""JavaDoc""}) @Deprecated public Object load(Serializable id,Object optionalObject,SessionImplementor session) throws HibernateException ;
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated Use {@link #ArrayType(TypeFactory.TypeScope,String,String,Class)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ArrayType(TypeFactory.TypeScope typeScope,String role,String propertyRef,Class elementClass,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
  this.elementClass=elementClass;
  arrayClass=Array.newInstance(elementClass,0).getClass();
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbeddedInXML();
"
"/** 
 * @deprecated Use {@link #BagType(TypeFactory.TypeScope,String,String)}See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public BagType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * @deprecated Use {@link #CustomCollectionType(TypeFactory.TypeScope,Class,String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CustomCollectionType(TypeFactory.TypeScope typeScope,Class userTypeClass,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  super(typeScope,role,foreignKeyPropertyName,isEmbeddedInXML);
  userType=createUserCollectionType(userTypeClass);
  customLogging=LoggableUserType.class.isAssignableFrom(userTypeClass);
}
"
"/** 
 * @deprecated Use {@link #IdentifierBagType(org.hibernate.type.TypeFactory.TypeScope,String,String)}See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public IdentifierBagType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * @deprecated Use {@link #ListType(org.hibernate.type.TypeFactory.TypeScope,String,String)}See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ListType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  super(scope,referencedEntityName,uniqueKeyPropertyName,!lazy,isEmbeddedInXML,unwrapProxy);
  this.ignoreNotFound=ignoreNotFound;
  this.isLogicalOneToOne=isLogicalOneToOne;
}
"
"/** 
 * @deprecated Use {@link #MapType(TypeFactory.TypeScope,String,String) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public MapType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,String,boolean,boolean,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  super(scope,referencedEntityName,uniqueKeyPropertyName,!lazy,isEmbeddedInXML,unwrapProxy);
  this.foreignKeyType=foreignKeyType;
  this.propertyName=propertyName;
  this.entityName=entityName;
}
"
"/** 
 * Constructs a map type capable of creating ordered maps of the given role.
 * @param role The collection role name.
 * @param propertyRef The property ref name.
 * @param isEmbeddedInXML Is this collection to embed itself in xml
 * @deprecated Use {@link #OrderedMapType(TypeFactory.TypeScope,String,String)} instead.instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public OrderedMapType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * Constructs a set type capable of creating ordered sets of the given role.
 * @param typeScope The scope for this type instance.
 * @param role The collection role name.
 * @param propertyRef The property ref name.
 * @param isEmbeddedInXML Is this collection to embed itself in xml
 * @deprecated Use {@link #OrderedSetType(org.hibernate.type.TypeFactory.TypeScope,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public OrderedSetType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * @deprecated Use {@link #SetType(org.hibernate.type.TypeFactory.TypeScope,String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public SetType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * @deprecated Use {@link #SortedMapType(org.hibernate.type.TypeFactory.TypeScope,String,String,java.util.Comparator)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public SortedMapType(TypeFactory.TypeScope typeScope,String role,String propertyRef,Comparator comparator,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
  this.comparator=comparator;
}
"
"/** 
 * @deprecated Use {@link #SortedSetType(org.hibernate.type.TypeFactory.TypeScope,String,String,java.util.Comparator)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public SortedSetType(TypeFactory.TypeScope typeScope,String role,String propertyRef,Comparator comparator,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
  this.comparator=comparator;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public boolean isXMLElement();
"
"/** 
 * A representation of the value to be embedded in an XML element.
 * @param node The XML node to which to write the value
 * @param value The value to write
 * @param factory The session factory
 * @throws HibernateException An error from Hibernate
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setToXMLNode(Node node,Object value,SessionFactoryImplementor factory) throws HibernateException ;
"
"/** 
 * Parse the XML representation of an instance.
 * @param xml The XML node from which to read the value
 * @param factory The session factory
 * @return an instance of the {@link #getReturnedClass() mapped class}
 * @throws HibernateException An error from Hibernate
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public Object fromXMLNode(Node xml,Mapping factory) throws HibernateException ;
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType customCollection(String typeName,Properties typeParameters,String role,String propertyRef,boolean embedded){
  Class typeClass;
  try {
    typeClass=ReflectHelper.classForName(typeName);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new MappingException(""user collection type class not found: "" + typeName,cnfe);
  }
  CustomCollectionType result=new CustomCollectionType(typeScope,typeClass,role,propertyRef,embedded);
  if (typeParameters != null) {
    injectParameters(result.getUserType(),typeParameters);
  }
  return result;
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  return new OneToOneType(typeScope,persistentClass,foreignKeyType,uniqueKeyPropertyName,lazy,unwrapProxy,isEmbeddedInXML,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,String,boolean,boolean,boolean,boolean)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return new ManyToOneType(typeScope,persistentClass,uniqueKeyPropertyName,lazy,unwrapProxy,isEmbeddedInXML,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #array(String,String,Class)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType array(String role,String propertyRef,boolean embedded,Class elementClass){
  return new ArrayType(typeScope,role,propertyRef,elementClass,embedded);
}
"
"/** 
 * @deprecated Use {@link #list(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType list(String role,String propertyRef,boolean embedded){
  return new ListType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #bag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType bag(String role,String propertyRef,boolean embedded){
  return new BagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #idbag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType idbag(String role,String propertyRef,boolean embedded){
  return new IdentifierBagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #map(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType map(String role,String propertyRef,boolean embedded){
  return new MapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedMap(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedMap(String role,String propertyRef,boolean embedded){
  return new OrderedMapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedMap(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedMap(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedMapType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @deprecated Use {@link #set(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType set(String role,String propertyRef,boolean embedded){
  return new SetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedSet(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedSet(String role,String propertyRef,boolean embedded){
  return new OrderedSetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedSet(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedSet(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedSetType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated Use {@link #ArrayType(TypeFactory.TypeScope,String,String,Class)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ArrayType(TypeFactory.TypeScope typeScope,String role,String propertyRef,Class elementClass,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
  this.elementClass=elementClass;
  arrayClass=Array.newInstance(elementClass,0).getClass();
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbeddedInXML();
"
"/** 
 * @deprecated Use {@link #BagType(TypeFactory.TypeScope,String,String)}See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public BagType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * @deprecated Use {@link #CustomCollectionType(TypeFactory.TypeScope,Class,String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CustomCollectionType(TypeFactory.TypeScope typeScope,Class userTypeClass,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  super(typeScope,role,foreignKeyPropertyName,isEmbeddedInXML);
  userType=createUserCollectionType(userTypeClass);
  customLogging=LoggableUserType.class.isAssignableFrom(userTypeClass);
}
"
"/** 
 * @deprecated Use {@link #IdentifierBagType(org.hibernate.type.TypeFactory.TypeScope,String,String)}See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public IdentifierBagType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * @deprecated Use {@link #ListType(org.hibernate.type.TypeFactory.TypeScope,String,String)}See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ListType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  super(scope,referencedEntityName,uniqueKeyPropertyName,!lazy,isEmbeddedInXML,unwrapProxy);
  this.ignoreNotFound=ignoreNotFound;
  this.isLogicalOneToOne=isLogicalOneToOne;
}
"
"/** 
 * @deprecated Use {@link #MapType(TypeFactory.TypeScope,String,String) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public MapType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,String,boolean,boolean,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  super(scope,referencedEntityName,uniqueKeyPropertyName,!lazy,isEmbeddedInXML,unwrapProxy);
  this.foreignKeyType=foreignKeyType;
  this.propertyName=propertyName;
  this.entityName=entityName;
}
"
"/** 
 * Constructs a map type capable of creating ordered maps of the given role.
 * @param role The collection role name.
 * @param propertyRef The property ref name.
 * @param isEmbeddedInXML Is this collection to embed itself in xml
 * @deprecated Use {@link #OrderedMapType(TypeFactory.TypeScope,String,String)} instead.instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public OrderedMapType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * Constructs a set type capable of creating ordered sets of the given role.
 * @param typeScope The scope for this type instance.
 * @param role The collection role name.
 * @param propertyRef The property ref name.
 * @param isEmbeddedInXML Is this collection to embed itself in xml
 * @deprecated Use {@link #OrderedSetType(org.hibernate.type.TypeFactory.TypeScope,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public OrderedSetType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * @deprecated Use {@link #SetType(org.hibernate.type.TypeFactory.TypeScope,String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public SetType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * @deprecated Use {@link #SortedMapType(org.hibernate.type.TypeFactory.TypeScope,String,String,java.util.Comparator)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public SortedMapType(TypeFactory.TypeScope typeScope,String role,String propertyRef,Comparator comparator,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
  this.comparator=comparator;
}
"
"/** 
 * @deprecated Use {@link #SortedSetType(org.hibernate.type.TypeFactory.TypeScope,String,String,java.util.Comparator)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public SortedSetType(TypeFactory.TypeScope typeScope,String role,String propertyRef,Comparator comparator,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
  this.comparator=comparator;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public boolean isXMLElement();
"
"/** 
 * A representation of the value to be embedded in an XML element.
 * @param node The XML node to which to write the value
 * @param value The value to write
 * @param factory The session factory
 * @throws HibernateException An error from Hibernate
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setToXMLNode(Node node,Object value,SessionFactoryImplementor factory) throws HibernateException ;
"
"/** 
 * Parse the XML representation of an instance.
 * @param xml The XML node from which to read the value
 * @param factory The session factory
 * @return an instance of the {@link #getReturnedClass() mapped class}
 * @throws HibernateException An error from Hibernate
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public Object fromXMLNode(Node xml,Mapping factory) throws HibernateException ;
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType customCollection(String typeName,Properties typeParameters,String role,String propertyRef,boolean embedded){
  Class typeClass;
  try {
    typeClass=ReflectHelper.classForName(typeName);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new MappingException(""user collection type class not found: "" + typeName,cnfe);
  }
  CustomCollectionType result=new CustomCollectionType(typeScope,typeClass,role,propertyRef,embedded);
  if (typeParameters != null) {
    injectParameters(result.getUserType(),typeParameters);
  }
  return result;
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  return new OneToOneType(typeScope,persistentClass,foreignKeyType,uniqueKeyPropertyName,lazy,unwrapProxy,isEmbeddedInXML,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,String,boolean,boolean,boolean,boolean)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return new ManyToOneType(typeScope,persistentClass,uniqueKeyPropertyName,lazy,unwrapProxy,isEmbeddedInXML,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #array(String,String,Class)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType array(String role,String propertyRef,boolean embedded,Class elementClass){
  return new ArrayType(typeScope,role,propertyRef,elementClass,embedded);
}
"
"/** 
 * @deprecated Use {@link #list(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType list(String role,String propertyRef,boolean embedded){
  return new ListType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #bag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType bag(String role,String propertyRef,boolean embedded){
  return new BagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #idbag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType idbag(String role,String propertyRef,boolean embedded){
  return new IdentifierBagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #map(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType map(String role,String propertyRef,boolean embedded){
  return new MapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedMap(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedMap(String role,String propertyRef,boolean embedded){
  return new OrderedMapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedMap(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedMap(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedMapType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @deprecated Use {@link #set(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType set(String role,String propertyRef,boolean embedded){
  return new SetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedSet(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedSet(String role,String propertyRef,boolean embedded){
  return new OrderedSetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedSet(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedSet(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedSetType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * @deprecated Added to support (also deprecated) PersistenceContext.getEntityEntries method until it can be removed.  Safe to use for counts.
 */
@Deprecated public Map getEntityEntryMap(){
  return backingMap;
}
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Get the mapping from entity instance to entity entry
 * @deprecated Due to the introduction of EntityEntryContext and bytecode enhancement
 */
@Deprecated public Map getEntityEntries();
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Get the mapping from entity instance to entity entry
 * @deprecated Due to the introduction of EntityEntryContext and bytecode enhancement; only valid really forsizing, see  {@link #getNumberOfManagedEntities}.  For iterating the entity/EntityEntry combos, see {@link #reentrantSafeEntityEntries}
 */
@Deprecated public Map getEntityEntries();
"
"/** 
 * Load an entity instance. If <tt>optionalObject</tt> is supplied, load the entity state into the given (uninitialized) object.
 * @deprecated use {@link #load(java.io.Serializable,Object,SessionImplementor,LockOptions)} instead.
 */
@SuppressWarnings({""JavaDoc""}) @Deprecated public Object load(Serializable id,Object optionalObject,SessionImplementor session) throws HibernateException ;
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.<String,SQLFunction>emptyMap()));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #translateOrderBy} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Creates a single node AST. <p/> TODO : this is silly, remove it...
 * @param astFactory The factory.
 * @param type The node type.
 * @param text The node text.
 * @return AST - A single node tree.
 * @deprecated silly
 */
public static AST create(ASTFactory astFactory,int type,String text){
  return astFactory.create(type,text);
}
"
"/** 
 * Get the name of a constant defined on the given class which has the given value. <p/> Note, if multiple constants have this value, the first will be returned which is known to be different on different JVM implementations.
 * @param owner The class which defines the constant
 * @param value The value of the constant.
 * @return The token type name, *or* the integer value if the name could not be found.
 * @deprecated Use #getTokenTypeName instead
 */
public static String getConstantName(Class owner,int value){
  return getTokenTypeName(owner,value);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * @deprecated Use {@link #ArrayType(TypeFactory.TypeScope,String,String,Class)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ArrayType(TypeFactory.TypeScope typeScope,String role,String propertyRef,Class elementClass,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
  this.elementClass=elementClass;
  arrayClass=Array.newInstance(elementClass,0).getClass();
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbeddedInXML();
"
"/** 
 * @deprecated Use {@link #BagType(TypeFactory.TypeScope,String,String)}See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public BagType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * @deprecated Use {@link #CustomCollectionType(TypeFactory.TypeScope,Class,String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CustomCollectionType(TypeFactory.TypeScope typeScope,Class userTypeClass,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  super(typeScope,role,foreignKeyPropertyName,isEmbeddedInXML);
  userType=createUserCollectionType(userTypeClass);
  customLogging=LoggableUserType.class.isAssignableFrom(userTypeClass);
}
"
"/** 
 * @deprecated Use {@link #IdentifierBagType(org.hibernate.type.TypeFactory.TypeScope,String,String)}See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public IdentifierBagType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * @deprecated Use {@link #ListType(org.hibernate.type.TypeFactory.TypeScope,String,String)}See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ListType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  super(scope,referencedEntityName,uniqueKeyPropertyName,!lazy,isEmbeddedInXML,unwrapProxy);
  this.ignoreNotFound=ignoreNotFound;
  this.isLogicalOneToOne=isLogicalOneToOne;
}
"
"/** 
 * @deprecated Use {@link #MapType(TypeFactory.TypeScope,String,String) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public MapType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,String,boolean,boolean,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  super(scope,referencedEntityName,uniqueKeyPropertyName,!lazy,isEmbeddedInXML,unwrapProxy);
  this.foreignKeyType=foreignKeyType;
  this.propertyName=propertyName;
  this.entityName=entityName;
}
"
"/** 
 * Constructs a map type capable of creating ordered maps of the given role.
 * @param role The collection role name.
 * @param propertyRef The property ref name.
 * @param isEmbeddedInXML Is this collection to embed itself in xml
 * @deprecated Use {@link #OrderedMapType(TypeFactory.TypeScope,String,String)} instead.instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public OrderedMapType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * Constructs a set type capable of creating ordered sets of the given role.
 * @param typeScope The scope for this type instance.
 * @param role The collection role name.
 * @param propertyRef The property ref name.
 * @param isEmbeddedInXML Is this collection to embed itself in xml
 * @deprecated Use {@link #OrderedSetType(org.hibernate.type.TypeFactory.TypeScope,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public OrderedSetType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * @deprecated Use {@link #SetType(org.hibernate.type.TypeFactory.TypeScope,String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public SetType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * @deprecated Use {@link #SortedMapType(org.hibernate.type.TypeFactory.TypeScope,String,String,java.util.Comparator)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public SortedMapType(TypeFactory.TypeScope typeScope,String role,String propertyRef,Comparator comparator,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
  this.comparator=comparator;
}
"
"/** 
 * @deprecated Use {@link #SortedSetType(org.hibernate.type.TypeFactory.TypeScope,String,String,java.util.Comparator)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public SortedSetType(TypeFactory.TypeScope typeScope,String role,String propertyRef,Comparator comparator,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
  this.comparator=comparator;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public boolean isXMLElement();
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType customCollection(String typeName,Properties typeParameters,String role,String propertyRef,boolean embedded){
  Class typeClass;
  try {
    typeClass=ReflectHelper.classForName(typeName);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new MappingException(""user collection type class not found: "" + typeName,cnfe);
  }
  CustomCollectionType result=new CustomCollectionType(typeScope,typeClass,role,propertyRef,embedded);
  if (typeParameters != null) {
    injectParameters(result.getUserType(),typeParameters);
  }
  return result;
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  return new OneToOneType(typeScope,persistentClass,foreignKeyType,uniqueKeyPropertyName,lazy,unwrapProxy,isEmbeddedInXML,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,String,boolean,boolean,boolean,boolean)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return new ManyToOneType(typeScope,persistentClass,uniqueKeyPropertyName,lazy,unwrapProxy,isEmbeddedInXML,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #array(String,String,Class)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType array(String role,String propertyRef,boolean embedded,Class elementClass){
  return new ArrayType(typeScope,role,propertyRef,elementClass,embedded);
}
"
"/** 
 * @deprecated Use {@link #list(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType list(String role,String propertyRef,boolean embedded){
  return new ListType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #bag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType bag(String role,String propertyRef,boolean embedded){
  return new BagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #idbag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType idbag(String role,String propertyRef,boolean embedded){
  return new IdentifierBagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #map(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType map(String role,String propertyRef,boolean embedded){
  return new MapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedMap(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedMap(String role,String propertyRef,boolean embedded){
  return new OrderedMapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedMap(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedMap(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedMapType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @deprecated Use {@link #set(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType set(String role,String propertyRef,boolean embedded){
  return new SetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedSet(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedSet(String role,String propertyRef,boolean embedded){
  return new OrderedSetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedSet(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedSet(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedSetType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbeddedInXML();
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(Class theClass,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
@Deprecated public void lock(Object object,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
@SuppressWarnings({""JavaDoc""}) @Deprecated public void lock(String entityName,Object object,LockMode lockMode);
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public void refresh(Object object,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(Class clazz,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(Class theClass,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
@Deprecated public void lock(Object object,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
@SuppressWarnings({""JavaDoc""}) @Deprecated public void lock(String entityName,Object object,LockMode lockMode);
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public void refresh(Object object,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(Class clazz,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType customCollection(String typeName,Properties typeParameters,String role,String propertyRef,boolean embedded){
  Class typeClass;
  try {
    typeClass=ReflectHelper.classForName(typeName);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new MappingException(""user collection type class not found: "" + typeName,cnfe);
  }
  CustomCollectionType result=new CustomCollectionType(typeScope,typeClass,role,propertyRef,embedded);
  if (typeParameters != null) {
    injectParameters(result.getUserType(),typeParameters);
  }
  return result;
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  return new OneToOneType(typeScope,persistentClass,foreignKeyType,uniqueKeyPropertyName,lazy,unwrapProxy,isEmbeddedInXML,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,String,boolean,boolean,boolean,boolean)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return new ManyToOneType(typeScope,persistentClass,uniqueKeyPropertyName,lazy,unwrapProxy,isEmbeddedInXML,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #array(String,String,Class)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType array(String role,String propertyRef,boolean embedded,Class elementClass){
  return new ArrayType(typeScope,role,propertyRef,elementClass,embedded);
}
"
"/** 
 * @deprecated Use {@link #list(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType list(String role,String propertyRef,boolean embedded){
  return new ListType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #bag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType bag(String role,String propertyRef,boolean embedded){
  return new BagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #idbag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType idbag(String role,String propertyRef,boolean embedded){
  return new IdentifierBagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #map(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType map(String role,String propertyRef,boolean embedded){
  return new MapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedMap(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedMap(String role,String propertyRef,boolean embedded){
  return new OrderedMapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedMap(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedMap(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedMapType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @deprecated Use {@link #set(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType set(String role,String propertyRef,boolean embedded){
  return new SetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedSet(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedSet(String role,String propertyRef,boolean embedded){
  return new OrderedSetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedSet(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedSet(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedSetType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries() throws HibernateException ;
"
"/** 
 * Applies the specified  {@link ClassLoader} as the application class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the resource class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the Hibernate class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use {@link #getLoadQueryInfluencers} instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the application class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the resource class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the Hibernate class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use {@link #getLoadQueryInfluencers} instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the application class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the resource class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the Hibernate class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the application class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the resource class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the Hibernate class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the application class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the resource class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the Hibernate class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * Projection counting the values
 * @param idPropertyName Name of the identifier property
 * @deprecated Use {@link #count()}.
 */
public AuditProjection count(String idPropertyName){
  return new PropertyAuditProjection(new OriginalIdPropertyName(idPropertyName),""count"",false);
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Projection counting the values
 * @param idPropertyName Name of the identifier property
 * @deprecated Use {@link #count()}.
 */
public AuditProjection count(String idPropertyName){
  return new PropertyAuditProjection(new OriginalIdPropertyName(idPropertyName),""count"",false);
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Projection counting the values
 * @param idPropertyName Name of the identifier property
 * @deprecated Use {@link #count()}.
 */
public AuditProjection count(String idPropertyName){
  return new PropertyAuditProjection(new OriginalIdPropertyName(idPropertyName),""count"",false);
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Added to support (also deprecated) PersistenceContext.getEntityEntries method until it can be removed.  Safe to use for counts.
 */
@Deprecated public Map getEntityEntryMap(){
  return backingMap;
}
"
"/** 
 * Get the mapping from entity instance to entity entry
 * @deprecated Due to the introduction of EntityEntryContext and bytecode enhancement
 */
@Deprecated public Map getEntityEntries();
"
"/** 
 * Get the mapping from entity instance to entity entry
 * @deprecated Due to the introduction of EntityEntryContext and bytecode enhancement; only valid really forsizing, see  {@link #getNumberOfManagedEntities}.  For iterating the entity/EntityEntry combos, see {@link #reentrantSafeEntityEntries}
 */
@Deprecated public Map getEntityEntries();
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated Needed until we can remove NamedInputStream
 */
public NamedInputStream asNamedInputStream();
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Getter for property 'source'.  This is the session from which the event originated. <p/> Some of the pre-* events had previous exposed the event source using getSource() because they had not originally extended from {@link AbstractEvent}.
 * @return Value for property 'source'.
 * @deprecated Use {@link #getSession} instead
 */
public EventSource getSource(){
  return getSession();
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated Needed until we can remove NamedInputStream
 */
public NamedInputStream asNamedInputStream();
"
"/** 
 * This form is used to bind named queries from Hibernate metadata, both  {@code hbm.xml} files and{@link org.hibernate.annotations.NamedQuery} annotation.
 * @param name The name under which to key/register the query
 * @param query The query string.
 * @param cacheable Is the query cacheable?
 * @param cacheRegion If cacheable, was there a specific region named?
 * @param timeout Query timeout, {@code null} indicates no timeout
 * @param fetchSize Fetch size associated with the query, {@code null} indicates no limit
 * @param flushMode Flush mode associated with query
 * @param cacheMode Cache mode associated with query
 * @param readOnly Should entities returned from this query (those not already associated with the Session anyway)be loaded as read-only?
 * @param comment SQL comment to be used in the generated SQL, {@code null} indicates none
 * @param parameterTypes (no idea, afaict this is always passed as null)
 * @deprecated Use {@link NamedQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedQueryDefinition(String name,String query,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes){
  this(name,query,cacheable,cacheRegion,timeout,LockOptions.WAIT_FOREVER,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes);
}
"
"/** 
 * This version is used to bind named queries defined via  {@link javax.persistence.NamedQuery}.
 * @param name The name under which to key/register the query
 * @param query The query string.
 * @param cacheable Is the query cacheable?
 * @param cacheRegion If cacheable, was there a specific region named?
 * @param timeout Query timeout, {@code null} indicates no timeout
 * @param lockTimeout Specifies the lock timeout for queries that apply lock modes.
 * @param fetchSize Fetch size associated with the query, {@code null} indicates no limit
 * @param flushMode Flush mode associated with query
 * @param cacheMode Cache mode associated with query
 * @param readOnly Should entities returned from this query (those not already associated with the Session anyway)be loaded as read-only?
 * @param comment SQL comment to be used in the generated SQL, {@code null} indicates none
 * @param parameterTypes (no idea, afaict this is always passed as null)
 * @deprecated Use {@link NamedQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedQueryDefinition(String name,String query,boolean cacheable,String cacheRegion,Integer timeout,Integer lockTimeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes){
  this(name,query,cacheable,cacheRegion,timeout,new LockOptions().setTimeOut(lockTimeout),fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a the result-set mapping information is not explicitly  provided in the query definition (i.e., no resultset-mapping used).
 * @param name The name of named query
 * @param query The sql query string
 * @param queryReturns The in-lined query return definitions
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,NativeSQLQueryReturn[] queryReturns,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,null,querySpaces,callable,queryReturns);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a resultset-mapping reference is used.
 * @param name The name of named query
 * @param query The sql query string
 * @param resultSetRef The resultset-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,String resultSetRef,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,resultSetRef,querySpaces,callable,null);
}
"
"/** 
 * Get the connection provider
 * @deprecated Access to connections via {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} shouldbe preferred over access via  {@link ConnectionProvider}, whenever possible. {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} is tied to the Hibernate Session toproperly account for contextual information.  See  {@link SessionImplementor#getJdbcConnectionAccess()}
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * Applies the specified  {@link ClassLoader} as the application class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the resource class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the Hibernate class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * create a factory from a canonical version
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map properties){
  Ejb3Configuration cfg=new Ejb3Configuration();
  return cfg.createEntityManagerFactory(properties);
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(Class theClass,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
@Deprecated public void lock(Object object,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
@SuppressWarnings({""JavaDoc""}) @Deprecated public void lock(String entityName,Object object,LockMode lockMode);
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public void refresh(Object object,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(Class clazz,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries() throws HibernateException ;
"
"/** 
 * Applies the specified  {@link ClassLoader} as the application class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the resource class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the Hibernate class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(java.util.Iterator,org.hibernate.engine.spi.SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,sessionFactory,false);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(java.util.Iterator,org.hibernate.engine.spi.SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,sessionFactory,false);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Get the mapping from entity instance to entity entry
 * @deprecated Due to the introduction of EntityEntryContext and bytecode enhancement; only valid really forsizing, see  {@link #getNumberOfManagedEntities}.  For iterating the entity/EntityEntry combos, see {@link #reentrantSafeEntityEntries}
 */
@Deprecated public Map getEntityEntries();
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use {@link #getLoadQueryInfluencers} instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * Creates a single node AST. <p/> TODO : this is silly, remove it...
 * @param astFactory The factory.
 * @param type The node type.
 * @param text The node text.
 * @return AST - A single node tree.
 * @deprecated silly
 */
public static AST create(ASTFactory astFactory,int type,String text){
  return astFactory.create(type,text);
}
"
"/** 
 * Get the name of a constant defined on the given class which has the given value. <p/> Note, if multiple constants have this value, the first will be returned which is known to be different on different JVM implementations.
 * @param owner The class which defines the constant
 * @param value The value of the constant.
 * @return The token type name, *or* the integer value if the name could not be found.
 * @deprecated Use #getTokenTypeName instead
 */
public static String getConstantName(Class owner,int value){
  return getTokenTypeName(owner,value);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.<String,SQLFunction>emptyMap()));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #translateOrderBy} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * Projection counting the values
 * @param idPropertyName Name of the identifier property
 * @deprecated Use {@link #count()}.
 */
public AuditProjection count(String idPropertyName){
  return new PropertyAuditProjection(new OriginalIdPropertyName(idPropertyName),""count"",false);
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the application class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the resource class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the Hibernate class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * This form is used to bind named queries from Hibernate metadata, both  {@code hbm.xml} files and{@link org.hibernate.annotations.NamedQuery} annotation.
 * @param name The name under which to key/register the query
 * @param query The query string.
 * @param cacheable Is the query cacheable?
 * @param cacheRegion If cacheable, was there a specific region named?
 * @param timeout Query timeout, {@code null} indicates no timeout
 * @param fetchSize Fetch size associated with the query, {@code null} indicates no limit
 * @param flushMode Flush mode associated with query
 * @param cacheMode Cache mode associated with query
 * @param readOnly Should entities returned from this query (those not already associated with the Session anyway)be loaded as read-only?
 * @param comment SQL comment to be used in the generated SQL, {@code null} indicates none
 * @param parameterTypes (no idea, afaict this is always passed as null)
 * @deprecated Use {@link NamedQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedQueryDefinition(String name,String query,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes){
  this(name,query,cacheable,cacheRegion,timeout,LockOptions.WAIT_FOREVER,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes);
}
"
"/** 
 * This version is used to bind named queries defined via  {@link javax.persistence.NamedQuery}.
 * @param name The name under which to key/register the query
 * @param query The query string.
 * @param cacheable Is the query cacheable?
 * @param cacheRegion If cacheable, was there a specific region named?
 * @param timeout Query timeout, {@code null} indicates no timeout
 * @param lockTimeout Specifies the lock timeout for queries that apply lock modes.
 * @param fetchSize Fetch size associated with the query, {@code null} indicates no limit
 * @param flushMode Flush mode associated with query
 * @param cacheMode Cache mode associated with query
 * @param readOnly Should entities returned from this query (those not already associated with the Session anyway)be loaded as read-only?
 * @param comment SQL comment to be used in the generated SQL, {@code null} indicates none
 * @param parameterTypes (no idea, afaict this is always passed as null)
 * @deprecated Use {@link NamedQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedQueryDefinition(String name,String query,boolean cacheable,String cacheRegion,Integer timeout,Integer lockTimeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes){
  this(name,query,cacheable,cacheRegion,timeout,new LockOptions().setTimeOut(lockTimeout),fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a the result-set mapping information is not explicitly  provided in the query definition (i.e., no resultset-mapping used).
 * @param name The name of named query
 * @param query The sql query string
 * @param queryReturns The in-lined query return definitions
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,NativeSQLQueryReturn[] queryReturns,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,null,querySpaces,callable,queryReturns);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a resultset-mapping reference is used.
 * @param name The name of named query
 * @param query The sql query string
 * @param resultSetRef The resultset-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,String resultSetRef,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,resultSetRef,querySpaces,callable,null);
}
"
"/** 
 * Get the connection provider
 * @deprecated Access to connections via {@link org.hibernate.engine.jdbc.connections.spi.JdbcConnectionAccess} shouldbe preferred over access via  {@link ConnectionProvider}, whenever possible. {@link org.hibernate.engine.jdbc.connections.spi.JdbcConnectionAccess} is tied to the Hibernate Session toproperly account for contextual information.  See  {@link SessionImplementor#getJdbcConnectionAccess()}
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * @deprecated Use {@link org.hibernate.SessionFactory.SessionFactoryOptions#getCustomEntityDirtinessStrategy()}instead.
 */
@Deprecated @SuppressWarnings(""JavaDoc"") public CustomEntityDirtinessStrategy getCustomEntityDirtinessStrategy();
"
"/** 
 * @deprecated Use {@link org.hibernate.SessionFactory.SessionFactoryOptions#getCustomEntityDirtinessStrategy()}instead.
 */
@Deprecated @SuppressWarnings(""JavaDoc"") public CurrentTenantIdentifierResolver getCurrentTenantIdentifierResolver();
"
"/** 
 * Getter for property 'source'.  This is the session from which the event originated. <p/> Some of the pre-* events had previous exposed the event source using getSource() because they had not originally extended from {@link AbstractEvent}.
 * @return Value for property 'source'.
 * @deprecated Use {@link #getSession} instead
 */
public EventSource getSource(){
  return getSession();
}
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries() throws HibernateException ;
"
"/** 
 * Applies the specified  {@link ClassLoader} as the application class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the resource class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the Hibernate class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(java.util.Iterator,org.hibernate.engine.spi.SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,sessionFactory,false);
}
"
"/** 
 * Obtain service for providing JDBC connections.
 * @return The connection provider.
 * @deprecated See deprecation notice on {@link org.hibernate.engine.spi.SessionFactoryImplementor#getConnectionProvider()}for details
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * Get the connection provider
 * @deprecated Access to connections via {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} shouldbe preferred over access via  {@link ConnectionProvider}, whenever possible. {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} is tied to the Hibernate Session toproperly account for contextual information.  See  {@link SessionImplementor#getJdbcConnectionAccess()}
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * @deprecated Use {@link org.hibernate.SessionFactory.SessionFactoryOptions#getCustomEntityDirtinessStrategy()}instead.
 */
@Deprecated @SuppressWarnings(""JavaDoc"") public CustomEntityDirtinessStrategy getCustomEntityDirtinessStrategy();
"
"/** 
 * @deprecated Use {@link org.hibernate.SessionFactory.SessionFactoryOptions#getCustomEntityDirtinessStrategy()}instead.
 */
@Deprecated @SuppressWarnings(""JavaDoc"") public CurrentTenantIdentifierResolver getCurrentTenantIdentifierResolver();
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use {@link #getLoadQueryInfluencers} instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,JoinType,Criterion)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,String,org.hibernate.sql.JoinType,org.hibernate.criterion.Criterion)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Creates a DuplicateMappingException using the given type and name.
 * @param type The type of the duplicated thing.
 * @param name The name of the duplicated thing.
 * @deprecated Use the for taking {@link Type} instead.
 */
@Deprecated public DuplicateMappingException(String type,String name){
  this(""Duplicate "" + type + "" mapping ""+ name,type,name);
}
"
"/** 
 * Creates a DuplicateMappingException using the given customMessage, type and name.
 * @param customMessage A custom exception message explaining the exception condition
 * @param type The type of the duplicated thing.
 * @param name The name of the duplicated thing.
 * @deprecated Use the for taking {@link Type} instead.
 */
@Deprecated public DuplicateMappingException(String customMessage,String type,String name){
  super(customMessage);
  this.type=type;
  this.name=name;
}
"
"/** 
 * Checks to see if the given mode is the same as  {@link #MANUAL}
 * @param mode The mode to check
 * @return true/false
 * @deprecated Just use equality check against {@link #MANUAL}.  Legacy from before this was an enum
 */
@Deprecated public static boolean isManualFlushMode(FlushMode mode){
  return MANUAL.level == mode.level;
}
"
"/** 
 * @deprecated Use {@link #getUninstantiatableClass} instead
 */
@Deprecated public Class getPersistentClass(){
  return clazz;
}
"
"/** 
 * Checks to see if the given mode is the same as  {@link #MANUAL}.
 * @param mode The mode to check
 * @return true/false
 * @deprecated Just use equality check against {@link #MANUAL}.  Legacy from before this was an enum
 */
@Deprecated public static boolean isManualFlushMode(FlushMode mode){
  return MANUAL.level == mode.level;
}
"
"/** 
 * Returns the Class we were attempting to instantiate.
 * @deprecated Use {@link #getUninstantiatableClass} instead
 * @return The class we are unable to instantiate
 */
@Deprecated public Class getPersistentClass(){
  return clazz;
}
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(Class theClass,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
@Deprecated public void lock(Object object,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param entityName The name of the entity
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
@SuppressWarnings({""JavaDoc""}) @Deprecated public void lock(String entityName,Object object,LockMode lockMode);
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public void refresh(Object object,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(Class clazz,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Should the session be automatically closed after transaction completion.
 * @param autoClose Should the session be automatically closed
 * @return {@code this}, for method chaining
 * @deprecated Only integrations can specify autoClosing behavior of individual sessions.  See{@link org.hibernate.engine.spi.SessionOwner}
 */
@Deprecated public SessionBuilder autoClose(boolean autoClose);
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries() throws HibernateException ;
"
"/** 
 * Signifies that the autoClose flag from the original session should be used to create the new session.
 * @return {@code this}, for method chaining
 * @deprecated For same reasons as {@link SessionBuilder#autoClose(boolean)} was deprecated.  However, sharedsession builders can use  {@link #autoClose(boolean)} since they do not ""inherit"" the owner.
 */
@Deprecated public SharedSessionBuilder autoClose();
"
"/** 
 * Returns the current JDBC connection associated with this instance.<br> <br> If the session is using aggressive connection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @deprecated just missed when deprecating same method from {@link Session}
 * @return The connection associated with this stateless session
 */
@Deprecated public Connection connection();
"
"/** 
 * Applies the specified  {@link ClassLoader} as the application class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the resource class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the Hibernate class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Temporarily exposed since Configuration is still around and much code still uses Configuration.  This allows code to configure the builder and access that to configure Configuration object (used from HEM atm).
 * @return The settings map.
 * @deprecated Temporarily exposed since Configuration is still around and much code still uses Configuration.This allows code to configure the builder and access that to configure Configuration object (used from HEM atm).
 */
@Deprecated public Map getSettings(){
  return settings;
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Projection counting the values
 * @param idPropertyName Name of the identifier property
 * @deprecated Use {@link #count()}.
 */
public AuditProjection count(String idPropertyName){
  return new PropertyAuditProjection(new OriginalIdPropertyName(idPropertyName),""count"",false);
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(java.util.Iterator,org.hibernate.engine.spi.SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,sessionFactory,false);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect) throws SQLException {
  this(connection,dialect,null,true);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration,boolean)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect,boolean extras) throws SQLException {
  this(connection,dialect,null,extras);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect) throws SQLException {
  this(connection,dialect,null,true);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration,boolean)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect,boolean extras) throws SQLException {
  this(connection,dialect,null,extras);
}
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,JoinType,Criterion)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,String,org.hibernate.sql.JoinType,org.hibernate.criterion.Criterion)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Creates a DuplicateMappingException using the given type and name.
 * @param type The type of the duplicated thing.
 * @param name The name of the duplicated thing.
 * @deprecated Use the for taking {@link Type} instead.
 */
@Deprecated public DuplicateMappingException(String type,String name){
  this(""Duplicate "" + type + "" mapping ""+ name,type,name);
}
"
"/** 
 * Creates a DuplicateMappingException using the given customMessage, type and name.
 * @param customMessage A custom exception message explaining the exception condition
 * @param type The type of the duplicated thing.
 * @param name The name of the duplicated thing.
 * @deprecated Use the for taking {@link Type} instead.
 */
@Deprecated public DuplicateMappingException(String customMessage,String type,String name){
  super(customMessage);
  this.type=type;
  this.name=name;
}
"
"/** 
 * Checks to see if the given mode is the same as  {@link #MANUAL}.
 * @param mode The mode to check
 * @return true/false
 * @deprecated Just use equality check against {@link #MANUAL}.  Legacy from before this was an enum
 */
@Deprecated public static boolean isManualFlushMode(FlushMode mode){
  return MANUAL.level == mode.level;
}
"
"/** 
 * Returns the Class we were attempting to instantiate.
 * @deprecated Use {@link #getUninstantiatableClass} instead
 * @return The class we are unable to instantiate
 */
@Deprecated public Class getPersistentClass(){
  return clazz;
}
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(Class theClass,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
@Deprecated public void lock(Object object,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param entityName The name of the entity
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
@SuppressWarnings({""JavaDoc""}) @Deprecated public void lock(String entityName,Object object,LockMode lockMode);
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public void refresh(Object object,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(Class clazz,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Should the session be automatically closed after transaction completion.
 * @param autoClose Should the session be automatically closed
 * @return {@code this}, for method chaining
 * @deprecated Only integrations can specify autoClosing behavior of individual sessions.  See{@link org.hibernate.engine.spi.SessionOwner}
 */
@Deprecated public SessionBuilder autoClose(boolean autoClose);
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries() throws HibernateException ;
"
"/** 
 * Signifies that the autoClose flag from the original session should be used to create the new session.
 * @return {@code this}, for method chaining
 * @deprecated For same reasons as {@link SessionBuilder#autoClose(boolean)} was deprecated.  However, sharedsession builders can use  {@link #autoClose(boolean)} since they do not ""inherit"" the owner.
 */
@Deprecated public SharedSessionBuilder autoClose();
"
"/** 
 * Returns the current JDBC connection associated with this instance.<br> <br> If the session is using aggressive connection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @deprecated just missed when deprecating same method from {@link Session}
 * @return The connection associated with this stateless session
 */
@Deprecated public Connection connection();
"
"/** 
 * Applies the specified  {@link ClassLoader} as the application class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the resource class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the Hibernate class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Temporarily exposed since Configuration is still around and much code still uses Configuration.  This allows code to configure the builder and access that to configure Configuration object (used from HEM atm).
 * @return The settings map.
 * @deprecated Temporarily exposed since Configuration is still around and much code still uses Configuration.This allows code to configure the builder and access that to configure Configuration object (used from HEM atm).
 */
@Deprecated public Map getSettings(){
  return settings;
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Projection counting the values
 * @param idPropertyName Name of the identifier property
 * @deprecated Use {@link #count()}.
 */
public AuditProjection count(String idPropertyName){
  return new PropertyAuditProjection(new OriginalIdPropertyName(idPropertyName),""count"",false);
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,JoinType,Criterion)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,String,org.hibernate.sql.JoinType,org.hibernate.criterion.Criterion)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries() throws HibernateException ;
"
"/** 
 * Access to the delayed entity key
 * @return The delayed entity key
 * @deprecated No Hibernate code currently uses this method
 */
@Deprecated @SuppressWarnings(""UnusedDeclaration"") public EntityKey getDelayedEntityKey(){
  return delayedEntityKey;
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the application class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the resource class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the Hibernate class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,JoinType,Criterion)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,String,org.hibernate.sql.JoinType,org.hibernate.criterion.Criterion)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries() throws HibernateException ;
"
"/** 
 * Access to the delayed entity key
 * @return The delayed entity key
 * @deprecated No Hibernate code currently uses this method
 */
@Deprecated @SuppressWarnings(""UnusedDeclaration"") public EntityKey getDelayedEntityKey(){
  return delayedEntityKey;
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the application class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the resource class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the Hibernate class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * Deprecated!
 * @param associationPath The association path
 * @param alias The alias to apply to that association path
 * @param joinType The type of join to use
 * @return {@code this}, for method chaining
 * @deprecated use {@link #createAlias(String,String,JoinType)}
 */
@Deprecated public DetachedCriteria createAlias(String associationPath,String alias,int joinType){
  return createAlias(associationPath,alias,JoinType.parse(joinType));
}
"
"/** 
 * Deprecated!
 * @param associationPath The association path
 * @param alias The alias to apply to that association path
 * @param joinType The type of join to use
 * @param withClause An additional restriction on the join
 * @return {@code this}, for method chaining
 * @deprecated use {@link #createAlias(String,String,JoinType,Criterion)}
 */
@Deprecated public DetachedCriteria createAlias(String associationPath,String alias,int joinType,Criterion withClause){
  return createAlias(associationPath,alias,JoinType.parse(joinType),withClause);
}
"
"/** 
 * Deprecated!
 * @param associationPath The association path
 * @param joinType The type of join to use
 * @return the newly created, nested DetachedCriteria
 * @deprecated use {@link #createCriteria(String,JoinType)}
 */
@Deprecated public DetachedCriteria createCriteria(String associationPath,int joinType){
  return createCriteria(associationPath,JoinType.parse(joinType));
}
"
"/** 
 * Deprecated!
 * @param associationPath The association path
 * @param alias The alias
 * @param joinType The type of join to use
 * @return the newly created, nested DetachedCriteria
 * @deprecated use {@link #createCriteria(String,String,JoinType)}
 */
@Deprecated public DetachedCriteria createCriteria(String associationPath,String alias,int joinType){
  return createCriteria(associationPath,alias,JoinType.parse(joinType));
}
"
"/** 
 * Deprecated!
 * @param associationPath The association path
 * @param alias The alias to associate with this ""join"".
 * @param joinType The type of join to use
 * @param withClause The additional join restriction
 * @return the newly created, nested DetachedCriteria
 * @deprecated use {@link #createCriteria(String,String,JoinType,Criterion)}
 */
@Deprecated public DetachedCriteria createCriteria(String associationPath,String alias,int joinType,Criterion withClause){
  return createCriteria(associationPath,alias,JoinType.parse(joinType),withClause);
}
"
"/** 
 * Apply a constraint expressed in SQL, with JDBC parameters.  Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @param sql The sql
 * @param values The parameter values
 * @param types The parameter types
 * @return Criterion
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String,Object[],Type[])}
 */
@Deprecated public static Criterion sql(String sql,Object[] values,Type[] types){
  return new SQLCriterion(sql,values,types);
}
"
"/** 
 * Apply a constraint expressed in SQL, with a JDBC parameter.  Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @param sql The sql
 * @param value The parameter value
 * @param type The parameter type
 * @return Criterion
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String,Object,Type)}
 */
@Deprecated public static Criterion sql(String sql,Object value,Type type){
  return new SQLCriterion(sql,value,type);
}
"
"/** 
 * Apply a constraint expressed in SQL with no parameters.  Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @param sql The sql
 * @return Criterion
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String)}
 */
@Deprecated public static Criterion sql(String sql){
  return new SQLCriterion(sql);
}
"
"/** 
 * Lol
 * @return duh
 * @deprecated an instance factory method does not make sense
 * @see Projections#projectionList()
 */
@Deprecated public ProjectionList create(){
  return new ProjectionList();
}
"
"/** 
 * Lifecycle callback to perform any necessary initialization of the underlying cache implementation(s).  Called exactly once during the construction of a  {@link org.hibernate.internal.SessionFactoryImpl}.
 * @param settings The settings in effect.
 * @param properties The defined cfg properties
 * @throws org.hibernate.cache.CacheException Indicates problems starting the L2 cache impl;considered as a sign to stop  {@link org.hibernate.SessionFactory}building.
 * @deprecated use {@code start} to in favor of {@link org.hibernate.service.ServiceRegistry}.
 */
@Deprecated public void start(Settings settings,Properties properties) throws CacheException ;
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect) throws SQLException {
  this(connection,dialect,null,true);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration,boolean)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect,boolean extras) throws SQLException {
  this(connection,dialect,null,extras);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect) throws SQLException {
  this(connection,dialect,null,true);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration,boolean)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect,boolean extras) throws SQLException {
  this(connection,dialect,null,extras);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect) throws SQLException {
  this(connection,dialect,null,true);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration,boolean)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect,boolean extras) throws SQLException {
  this(connection,dialect,null,extras);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Get the mapping from entity instance to entity entry
 * @deprecated Due to the introduction of EntityEntryContext and bytecode enhancement; only valid really forsizing, see  {@link #getNumberOfManagedEntities}.  For iterating the entity/EntityEntry combos, see {@link #reentrantSafeEntityEntries}
 */
@Deprecated public Map getEntityEntries();
"
"/** 
 * Applies the specified  {@link ClassLoader} as the application class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the resource class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the Hibernate class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Release all resources held by this provider.
 * @throws HibernateException Indicates a problem closing the underlying pool or releasing resources
 * @deprecated Use {@link #stop} instead
 */
@Deprecated public void close() throws HibernateException {
  stop();
}
"
"/** 
 * Close the provider.
 * @deprecated Use {@link #stop} instead
 */
@Deprecated public void close(){
  stop();
}
"
"/** 
 * Cast <tt>candidate</tt> to the instance of <tt>expected</tt> type.
 * @param expected The type of instance expected to return.
 * @param candidate The candidate object to be casted.
 * @param < T > The java type of the expected return
 * @return The instance of expected type or null if this cast fail.
 * @deprecated No idea why this is exposed here...
 */
@Deprecated public <T>T cast(Class<T> expected,Object candidate);
"
"/** 
 * Close the provider.
 * @deprecated Use {@link #stop} instead
 */
@Deprecated public void close(){
  stop();
}
"
"/** 
 * Deprecated.
 * @param clob The possible NClob reference
 * @return {@code true} if the the Clob is a NClob as well
 * @deprecated ORM baselines on JDK 1.6, so optional support for NClob (JDK 1,6 addition) is no longer needed.
 */
@Deprecated public static boolean isNClob(Clob clob){
  return NClob.class.isInstance(clob);
}
"
"/** 
 * {@inheritDoc}
 * @deprecated Use {@link #getWrappedNClob()} instead
 */
@Override @Deprecated public NClob getWrappedClob();
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Not used!
 * @param jarPath The jar path
 * @return The url from the path?
 * @deprecated Not used!
 */
@Deprecated @SuppressWarnings(""UnusedDeclaration"") public URL getURLFromPath(String jarPath);
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * Projection counting the values
 * @param idPropertyName Name of the identifier property
 * @deprecated Use {@link #count()}.
 */
public AuditProjection count(String idPropertyName){
  return new PropertyAuditProjection(new OriginalIdPropertyName(idPropertyName),""count"",false);
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Close the provider.
 * @deprecated Use {@link #stop} instead
 */
@Deprecated public void close(){
  stop();
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the application class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the resource class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the Hibernate class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Deprecated!
 * @param associationPath The association path
 * @param alias The alias to apply to that association path
 * @param joinType The type of join to use
 * @return {@code this}, for method chaining
 * @deprecated use {@link #createAlias(String,String,JoinType)}
 */
@Deprecated public DetachedCriteria createAlias(String associationPath,String alias,int joinType){
  return createAlias(associationPath,alias,JoinType.parse(joinType));
}
"
"/** 
 * Deprecated!
 * @param associationPath The association path
 * @param alias The alias to apply to that association path
 * @param joinType The type of join to use
 * @param withClause An additional restriction on the join
 * @return {@code this}, for method chaining
 * @deprecated use {@link #createAlias(String,String,JoinType,Criterion)}
 */
@Deprecated public DetachedCriteria createAlias(String associationPath,String alias,int joinType,Criterion withClause){
  return createAlias(associationPath,alias,JoinType.parse(joinType),withClause);
}
"
"/** 
 * Deprecated!
 * @param associationPath The association path
 * @param joinType The type of join to use
 * @return the newly created, nested DetachedCriteria
 * @deprecated use {@link #createCriteria(String,JoinType)}
 */
@Deprecated public DetachedCriteria createCriteria(String associationPath,int joinType){
  return createCriteria(associationPath,JoinType.parse(joinType));
}
"
"/** 
 * Deprecated!
 * @param associationPath The association path
 * @param alias The alias
 * @param joinType The type of join to use
 * @return the newly created, nested DetachedCriteria
 * @deprecated use {@link #createCriteria(String,String,JoinType)}
 */
@Deprecated public DetachedCriteria createCriteria(String associationPath,String alias,int joinType){
  return createCriteria(associationPath,alias,JoinType.parse(joinType));
}
"
"/** 
 * Deprecated!
 * @param associationPath The association path
 * @param alias The alias to associate with this ""join"".
 * @param joinType The type of join to use
 * @param withClause The additional join restriction
 * @return the newly created, nested DetachedCriteria
 * @deprecated use {@link #createCriteria(String,String,JoinType,Criterion)}
 */
@Deprecated public DetachedCriteria createCriteria(String associationPath,String alias,int joinType,Criterion withClause){
  return createCriteria(associationPath,alias,JoinType.parse(joinType),withClause);
}
"
"/** 
 * Apply a constraint expressed in SQL, with JDBC parameters.  Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @param sql The sql
 * @param values The parameter values
 * @param types The parameter types
 * @return Criterion
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String,Object[],Type[])}
 */
@Deprecated public static Criterion sql(String sql,Object[] values,Type[] types){
  return new SQLCriterion(sql,values,types);
}
"
"/** 
 * Apply a constraint expressed in SQL, with a JDBC parameter.  Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @param sql The sql
 * @param value The parameter value
 * @param type The parameter type
 * @return Criterion
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String,Object,Type)}
 */
@Deprecated public static Criterion sql(String sql,Object value,Type type){
  return new SQLCriterion(sql,value,type);
}
"
"/** 
 * Apply a constraint expressed in SQL with no parameters.  Any occurrences of <tt>{alias}</tt> will be replaced by the table alias.
 * @param sql The sql
 * @return Criterion
 * @deprecated use {@link org.hibernate.criterion.Restrictions#sqlRestriction(String)}
 */
@Deprecated public static Criterion sql(String sql){
  return new SQLCriterion(sql);
}
"
"/** 
 * Lol
 * @return duh
 * @deprecated an instance factory method does not make sense
 * @see Projections#projectionList()
 */
@Deprecated public ProjectionList create(){
  return new ProjectionList();
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Close the provider.
 * @deprecated Use {@link #stop} instead
 */
@SuppressWarnings(""UnusedDeclaration"") @Deprecated public void close(){
  stop();
}
"
"/** 
 * Cast <tt>candidate</tt> to the instance of <tt>expected</tt> type.
 * @param expected The type of instance expected to return.
 * @param candidate The candidate object to be casted.
 * @param < T > The java type of the expected return
 * @return The instance of expected type or null if this cast fail.
 * @deprecated No idea why this is exposed here...
 */
@Deprecated public <T>T cast(Class<T> expected,Object candidate);
"
"/** 
 * Unsupported operation
 * @return nothing ever, this only throws!
 * @throws UnsupportedOperationException
 * @deprecated DO NOT USE, WILL ONLY THROW AT YOU!
 */
@Deprecated @SuppressWarnings(""UnusedDeclaration"") public long getDBSQLExecutionSample(){
  throw new UnsupportedOperationException(""Use getQueryExecutionCount() instead"");
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * Get the connection provider
 * @deprecated Access to connections via {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} shouldbe preferred over access via  {@link ConnectionProvider}, whenever possible. {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} is tied to the Hibernate Session toproperly account for contextual information.  See  {@link SessionImplementor#getJdbcConnectionAccess()}
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * Deprecated.
 * @param clob The possible NClob reference
 * @return {@code true} if the the Clob is a NClob as well
 * @deprecated ORM baselines on JDK 1.6, so optional support for NClob (JDK 1,6 addition) is no longer needed.
 */
@Deprecated public static boolean isNClob(Clob clob){
  return NClob.class.isInstance(clob);
}
"
"/** 
 * {@inheritDoc}
 * @deprecated Use {@link #getWrappedNClob()} instead
 */
@Override @Deprecated public NClob getWrappedClob();
"
"/** 
 * Get the mapping from entity instance to entity entry
 * @deprecated Due to the introduction of EntityEntryContext and bytecode enhancement; only valid really forsizing, see  {@link #getNumberOfManagedEntities}.  For iterating the entity/EntityEntry combos, see {@link #reentrantSafeEntityEntries}
 */
@Deprecated public Map getEntityEntries();
"
"/** 
 * Unsupported operation
 * @return nothing ever, this only throws!
 * @throws UnsupportedOperationException
 * @deprecated DO NOT USE, WILL ONLY THROW AT YOU!
 */
@Deprecated public long getDBSQLExecutionSample(){
  throw new UnsupportedOperationException(""Use getQueryExecutionCount() instead"");
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect) throws SQLException {
  this(connection,dialect,null,true);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration,boolean)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect,boolean extras) throws SQLException {
  this(connection,dialect,null,extras);
}
"
"/** 
 * Not used!
 * @param jarPath The jar path
 * @return The url from the path?
 * @deprecated Not used!
 */
@Deprecated @SuppressWarnings(""UnusedDeclaration"") public URL getURLFromPath(String jarPath);
"
"/** 
 * Projection counting the values
 * @param idPropertyName Name of the identifier property
 * @deprecated Use {@link #count()}.
 */
public AuditProjection count(String idPropertyName){
  return new PropertyAuditProjection(new OriginalIdPropertyName(idPropertyName),""count"",false);
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Release all resources held by this provider.
 * @throws HibernateException Indicates a problem closing the underlying pool or releasing resources
 * @deprecated Use {@link #stop} instead
 */
@Deprecated public void close() throws HibernateException {
  stop();
}
"
"/** 
 * Close the provider.
 * @deprecated Use {@link #stop} instead
 */
@SuppressWarnings(""UnusedDeclaration"") @Deprecated public void close(){
  stop();
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)}instead.
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #SpecialOneToOneType(org.hibernate.type.TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)} instead.
 */
@Deprecated public SpecialOneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType customCollection(String typeName,Properties typeParameters,String role,String propertyRef,boolean embedded){
  Class typeClass;
  try {
    typeClass=ReflectHelper.classForName(typeName);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new MappingException(""user collection type class not found: "" + typeName,cnfe);
  }
  CustomCollectionType result=new CustomCollectionType(typeScope,typeClass,role,propertyRef,embedded);
  if (typeParameters != null) {
    injectParameters(result.getUserType(),typeParameters);
  }
  return result;
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #specialOneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType specialOneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return specialOneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #array(String,String,Class)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType array(String role,String propertyRef,boolean embedded,Class elementClass){
  return new ArrayType(typeScope,role,propertyRef,elementClass,embedded);
}
"
"/** 
 * @deprecated Use {@link #list(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType list(String role,String propertyRef,boolean embedded){
  return new ListType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #bag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType bag(String role,String propertyRef,boolean embedded){
  return new BagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #idbag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType idbag(String role,String propertyRef,boolean embedded){
  return new IdentifierBagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #map(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType map(String role,String propertyRef,boolean embedded){
  return new MapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedMap(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedMap(String role,String propertyRef,boolean embedded){
  return new OrderedMapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedMap(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedMap(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedMapType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @deprecated Use {@link #set(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType set(String role,String propertyRef,boolean embedded){
  return new SetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedSet(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedSet(String role,String propertyRef,boolean embedded){
  return new OrderedSetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedSet(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedSet(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedSetType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * Get the connection provider
 * @deprecated Access to connections via {@link org.hibernate.engine.jdbc.connections.spi.JdbcConnectionAccess} shouldbe preferred over access via  {@link ConnectionProvider}, whenever possible. {@link org.hibernate.engine.jdbc.connections.spi.JdbcConnectionAccess} is tied to the Hibernate Session toproperly account for contextual information.  See  {@link SessionImplementor#getJdbcConnectionAccess()}
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * @deprecated Use {@link org.hibernate.SessionFactory.SessionFactoryOptions#getCustomEntityDirtinessStrategy()}instead.
 */
@Deprecated @SuppressWarnings(""JavaDoc"") public CustomEntityDirtinessStrategy getCustomEntityDirtinessStrategy();
"
"/** 
 * @deprecated Use {@link org.hibernate.SessionFactory.SessionFactoryOptions#getCustomEntityDirtinessStrategy()}instead.
 */
@Deprecated @SuppressWarnings(""JavaDoc"") public CurrentTenantIdentifierResolver getCurrentTenantIdentifierResolver();
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)}instead.
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #SpecialOneToOneType(org.hibernate.type.TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)} instead.
 */
@Deprecated public SpecialOneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType customCollection(String typeName,Properties typeParameters,String role,String propertyRef,boolean embedded){
  Class typeClass;
  try {
    typeClass=ReflectHelper.classForName(typeName);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new MappingException(""user collection type class not found: "" + typeName,cnfe);
  }
  CustomCollectionType result=new CustomCollectionType(typeScope,typeClass,role,propertyRef,embedded);
  if (typeParameters != null) {
    injectParameters(result.getUserType(),typeParameters);
  }
  return result;
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #specialOneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType specialOneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return specialOneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #array(String,String,Class)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType array(String role,String propertyRef,boolean embedded,Class elementClass){
  return new ArrayType(typeScope,role,propertyRef,elementClass,embedded);
}
"
"/** 
 * @deprecated Use {@link #list(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType list(String role,String propertyRef,boolean embedded){
  return new ListType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #bag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType bag(String role,String propertyRef,boolean embedded){
  return new BagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #idbag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType idbag(String role,String propertyRef,boolean embedded){
  return new IdentifierBagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #map(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType map(String role,String propertyRef,boolean embedded){
  return new MapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedMap(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedMap(String role,String propertyRef,boolean embedded){
  return new OrderedMapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedMap(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedMap(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedMapType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @deprecated Use {@link #set(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType set(String role,String propertyRef,boolean embedded){
  return new SetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedSet(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedSet(String role,String propertyRef,boolean embedded){
  return new OrderedSetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedSet(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedSet(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedSetType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * Unsupported operation
 * @return nothing ever, this only throws!
 * @throws UnsupportedOperationException
 * @deprecated DO NOT USE, WILL ONLY THROW AT YOU!
 */
@Deprecated @SuppressWarnings(""UnusedDeclaration"") public long getDBSQLExecutionSample(){
  throw new UnsupportedOperationException(""Use getQueryExecutionCount() instead"");
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Obtain service for providing JDBC connections.
 * @return The connection provider.
 * @deprecated See deprecation notice on {@link org.hibernate.engine.spi.SessionFactoryImplementor#getConnectionProvider()}for details
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Obtain service for providing JDBC connections.
 * @return The connection provider.
 * @deprecated See deprecation notice on {@link org.hibernate.engine.spi.SessionFactoryImplementor#getConnectionProvider()}for details
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #SpecialOneToOneType(org.hibernate.type.TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)} instead.
 */
@Deprecated public SpecialOneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #specialOneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType specialOneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return specialOneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing"",""unchecked""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    final Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #SpecialOneToOneType(org.hibernate.type.TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)} instead.
 */
@Deprecated public SpecialOneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #specialOneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType specialOneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return specialOneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The type
 * @deprecated Use {@link OrdinalParameterDescriptor#getExpectedType()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public Type getOrdinalParameterExpectedType(int position){
  return getOrdinalParameterDescriptor(position).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The source location
 * @deprecated Use {@link OrdinalParameterDescriptor#getSourceLocation()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public int getOrdinalParameterSourceLocation(int position){
  return getOrdinalParameterDescriptor(position).getSourceLocation();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getExpectedType()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public Type getNamedParameterExpectedType(String name){
  return getNamedParameterDescriptor(name).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getSourceLocations()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public int[] getNamedParameterSourceLocations(String name){
  return getNamedParameterDescriptor(name).getSourceLocations();
}
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries() throws HibernateException ;
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The type
 * @deprecated Use {@link OrdinalParameterDescriptor#getExpectedType()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public Type getOrdinalParameterExpectedType(int position){
  return getOrdinalParameterDescriptor(position).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The source location
 * @deprecated Use {@link OrdinalParameterDescriptor#getSourceLocation()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public int getOrdinalParameterSourceLocation(int position){
  return getOrdinalParameterDescriptor(position).getSourceLocation();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getExpectedType()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public Type getNamedParameterExpectedType(String name){
  return getNamedParameterDescriptor(name).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getSourceLocations()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public int[] getNamedParameterSourceLocations(String name){
  return getNamedParameterDescriptor(name).getSourceLocations();
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing"",""unchecked""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    final Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)}instead.
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #SpecialOneToOneType(org.hibernate.type.TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)} instead.
 */
@Deprecated public SpecialOneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType customCollection(String typeName,Properties typeParameters,String role,String propertyRef,boolean embedded){
  Class typeClass;
  try {
    typeClass=ReflectHelper.classForName(typeName);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new MappingException(""user collection type class not found: "" + typeName,cnfe);
  }
  CustomCollectionType result=new CustomCollectionType(typeScope,typeClass,role,propertyRef,embedded);
  if (typeParameters != null) {
    injectParameters(result.getUserType(),typeParameters);
  }
  return result;
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #specialOneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType specialOneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return specialOneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #array(String,String,Class)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType array(String role,String propertyRef,boolean embedded,Class elementClass){
  return new ArrayType(typeScope,role,propertyRef,elementClass,embedded);
}
"
"/** 
 * @deprecated Use {@link #list(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType list(String role,String propertyRef,boolean embedded){
  return new ListType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #bag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType bag(String role,String propertyRef,boolean embedded){
  return new BagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #idbag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType idbag(String role,String propertyRef,boolean embedded){
  return new IdentifierBagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #map(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType map(String role,String propertyRef,boolean embedded){
  return new MapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedMap(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedMap(String role,String propertyRef,boolean embedded){
  return new OrderedMapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedMap(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedMap(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedMapType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @deprecated Use {@link #set(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType set(String role,String propertyRef,boolean embedded){
  return new SetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedSet(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedSet(String role,String propertyRef,boolean embedded){
  return new OrderedSetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedSet(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedSet(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedSetType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Close the provider.
 * @deprecated Use {@link #stop} instead
 */
@SuppressWarnings(""UnusedDeclaration"") @Deprecated public void close(){
  stop();
}
"
"/** 
 * Allow access to the id generator factory, though this is only needed/allowed from configuration.
 * @return Access to the identifier generator factory
 * @deprecated temporary solution 
 */
@Deprecated public IdentifierGeneratorFactory getIdentifierGeneratorFactory();
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) @Deprecated public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #SpecialOneToOneType(org.hibernate.type.TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)} instead.
 */
@Deprecated public SpecialOneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #specialOneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType specialOneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return specialOneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The type
 * @deprecated Use {@link OrdinalParameterDescriptor#getExpectedType()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public Type getOrdinalParameterExpectedType(int position){
  return getOrdinalParameterDescriptor(position).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The source location
 * @deprecated Use {@link OrdinalParameterDescriptor#getSourceLocation()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public int getOrdinalParameterSourceLocation(int position){
  return getOrdinalParameterDescriptor(position).getSourceLocation();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getExpectedType()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public Type getNamedParameterExpectedType(String name){
  return getNamedParameterDescriptor(name).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getSourceLocations()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public int[] getNamedParameterSourceLocations(String name){
  return getNamedParameterDescriptor(name).getSourceLocations();
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a the result-set mapping information is not explicitly  provided in the query definition (i.e., no resultset-mapping used).
 * @param name The name of named query
 * @param query The sql query string
 * @param queryReturns The in-lined query return definitions
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,NativeSQLQueryReturn[] queryReturns,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,null,querySpaces,callable,queryReturns);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a resultset-mapping reference is used.
 * @param name The name of named query
 * @param query The sql query string
 * @param resultSetRef The resultset-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,String resultSetRef,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,resultSetRef,querySpaces,callable,null);
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #specialOneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType specialOneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return specialOneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    final Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,incrementSize);
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * Create an entity instance initialized with the given identifier.
 * @param id The identifier value for the entity to be instantiated.
 * @return The instantiated entity.
 * @throws HibernateException
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public Object instantiate(Serializable id) throws HibernateException ;
"
"/** 
 * Extract the identifier value from the given entity.
 * @param entity The entity from which to extract the identifier value.
 * @return The identifier value.
 * @throws HibernateException If the entity does not define an identifier property, or anerror occurs accessing its value.
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead.
 */
public Serializable getIdentifier(Object entity) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public void setIdentifier(Object entity,Serializable id) throws HibernateException ;
"
"/** 
 * Inject the given identifier and version into the entity, in order to ""roll back"" to their original values.
 * @param entity The entity for which to reset the id/version values
 * @param currentId The identifier value to inject into the entity.
 * @param currentVersion The version value to inject into the entity.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion);
"
"/** 
 * Close the provider.
 * @deprecated Use {@link #stop} instead
 */
@SuppressWarnings(""UnusedDeclaration"") @Deprecated public void close(){
  stop();
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The type
 * @deprecated Use {@link OrdinalParameterDescriptor#getExpectedType()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public Type getOrdinalParameterExpectedType(int position){
  return getOrdinalParameterDescriptor(position).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The source location
 * @deprecated Use {@link OrdinalParameterDescriptor#getSourceLocation()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public int getOrdinalParameterSourceLocation(int position){
  return getOrdinalParameterDescriptor(position).getSourceLocation();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getExpectedType()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public Type getNamedParameterExpectedType(String name){
  return getNamedParameterDescriptor(name).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getSourceLocations()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public int[] getNamedParameterSourceLocations(String name){
  return getNamedParameterDescriptor(name).getSourceLocations();
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a the result-set mapping information is not explicitly  provided in the query definition (i.e., no resultset-mapping used).
 * @param name The name of named query
 * @param query The sql query string
 * @param queryReturns The in-lined query return definitions
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,NativeSQLQueryReturn[] queryReturns,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,null,querySpaces,callable,queryReturns);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a resultset-mapping reference is used.
 * @param name The name of named query
 * @param query The sql query string
 * @param resultSetRef The resultset-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,String resultSetRef,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,resultSetRef,querySpaces,callable,null);
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    final Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,incrementSize);
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,JoinType,Criterion)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,String,org.hibernate.sql.JoinType,org.hibernate.criterion.Criterion)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Deprecated.
 * @param clob The possible NClob reference
 * @return {@code true} if the the Clob is a NClob as well
 * @deprecated ORM baselines on JDK 1.6, so optional support for NClob (JDK 1,6 addition) is no longer needed.
 */
@Deprecated public static boolean isNClob(Clob clob){
  return NClob.class.isInstance(clob);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
@Deprecated @Override public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @param classLoaderService ClassLoaderService
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize,ClassLoaderService classLoaderService){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type,classLoaderService);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    final Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,incrementSize);
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
@Deprecated @Override public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @param classLoaderService ClassLoaderService
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize,ClassLoaderService classLoaderService){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=classLoaderService.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    final Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,incrementSize);
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * TODO: Kept only for legacy ORM 4 callers.  Remove in ORM 5.
 * @deprecated Replace with direct use of {@link ClassLoaderService}.
 */
@Deprecated public static InputStream getResourceAsStream(String resource){
  String stripped=resource.startsWith(""/"") ? resource.substring(1) : resource;
  InputStream stream=null;
  ClassLoader classLoader=ClassLoaderHelper.getContextClassLoader();
  if (classLoader != null) {
    stream=classLoader.getResourceAsStream(stripped);
  }
  if (stream == null) {
    stream=Environment.class.getResourceAsStream(resource);
  }
  if (stream == null) {
    stream=Environment.class.getClassLoader().getResourceAsStream(stripped);
  }
  if (stream == null) {
    throw new HibernateException(resource + "" not found"");
  }
  return stream;
}
"
"/** 
 * TODO: Kept only for legacy ORM 4 callers.  Remove in ORM 5.
 * @deprecated Replace with direct use of {@link ClassLoaderService}.
 */
@Deprecated public static InputStream getUserResourceAsStream(String resource){
  boolean hasLeadingSlash=resource.startsWith(""/"");
  String stripped=hasLeadingSlash ? resource.substring(1) : resource;
  InputStream stream=null;
  ClassLoader classLoader=ClassLoaderHelper.getContextClassLoader();
  if (classLoader != null) {
    stream=classLoader.getResourceAsStream(resource);
    if (stream == null && hasLeadingSlash) {
      stream=classLoader.getResourceAsStream(stripped);
    }
  }
  if (stream == null) {
    stream=Environment.class.getClassLoader().getResourceAsStream(resource);
  }
  if (stream == null && hasLeadingSlash) {
    stream=Environment.class.getClassLoader().getResourceAsStream(stripped);
  }
  if (stream == null) {
    throw new HibernateException(resource + "" not found"");
  }
  return stream;
}
"
"/** 
 * TODO: Kept only for legacy ORM 4 callers.  Remove in ORM 5.
 * @deprecated Replace with direct use of {@link ClassLoaderService}.
 */
@Deprecated public static Class classForName(String name,Class caller) throws ClassNotFoundException {
  try {
    return new ClassLoaderServiceImpl().classForName(name);
  }
 catch (  Throwable ignore) {
  }
  if (caller != null) {
    return Class.forName(name,true,caller.getClassLoader());
  }
 else {
    return Class.forName(name);
  }
}
"
"/** 
 * TODO: Kept only for legacy ORM 4 callers.  Remove in ORM 5.
 * @deprecated Replace with direct use of {@link ClassLoaderService}.
 */
@Deprecated public static Class classForName(String name) throws ClassNotFoundException {
  try {
    return new ClassLoaderServiceImpl().classForName(name);
  }
 catch (  Throwable ignore) {
  }
  return Class.forName(name);
}
"
"/** 
 * TODO: Kept only for legacy ORM 4 callers.  Remove in ORM 5.
 * @deprecated Replace with direct use of {@link ClassLoaderService}.
 */
@Deprecated public static Class reflectedPropertyClass(String className,String name) throws MappingException {
  try {
    Class clazz=classForName(className);
    return getter(clazz,name).getReturnType();
  }
 catch (  ClassNotFoundException cnfe) {
    throw new MappingException(""class "" + className + "" not found while looking for property: ""+ name,cnfe);
  }
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.classLoaderService=new ClassLoaderServiceImpl();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.classLoaderService=new ClassLoaderServiceImpl();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * Release all resources held by this provider.
 * @throws HibernateException Indicates a problem closing the underlying pool or releasing resources
 * @deprecated Use {@link #stop} instead
 */
@Deprecated public void close() throws HibernateException {
  stop();
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
@Deprecated @Override public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
@Deprecated @Override public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
@Deprecated @Override public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
@Deprecated @Override public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use {@link #getLoadQueryInfluencers} instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(Iterator,Set,SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,Collections.<MappedSuperclass>emptySet(),sessionFactory,false);
}
"
"/** 
 * Deprecated as this is badly named for its use.
 * @deprecated Use {@link #getExplicitTableName} instead
 */
@Deprecated public String getSecondaryTableName(){
  return explicitTableName;
}
"
"/** 
 * Deprecated as this is badly named for its use.
 * @deprecated Use {@link #setExplicitTableName} instead
 */
@Deprecated public void setSecondaryTableName(String explicitTableName){
  setExplicitTableName(explicitTableName);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Get the connection provider
 * @deprecated Access to connections via {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} shouldbe preferred over access via  {@link ConnectionProvider}, whenever possible. {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} is tied to the Hibernate Session toproperly account for contextual information.  See  {@link SessionImplementor#getJdbcConnectionAccess()}
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType customCollection(String typeName,Properties typeParameters,String role,String propertyRef,boolean embedded){
  Class typeClass;
  try {
    typeClass=ReflectHelper.classForName(typeName);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new MappingException(""user collection type class not found: "" + typeName,cnfe);
  }
  CustomCollectionType result=new CustomCollectionType(typeScope,typeClass,role,propertyRef,embedded);
  if (typeParameters != null) {
    injectParameters(result.getUserType(),typeParameters);
  }
  return result;
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #specialOneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType specialOneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return specialOneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #array(String,String,Class)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType array(String role,String propertyRef,boolean embedded,Class elementClass){
  return new ArrayType(typeScope,role,propertyRef,elementClass,embedded);
}
"
"/** 
 * @deprecated Use {@link #list(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType list(String role,String propertyRef,boolean embedded){
  return new ListType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #bag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType bag(String role,String propertyRef,boolean embedded){
  return new BagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #idbag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType idbag(String role,String propertyRef,boolean embedded){
  return new IdentifierBagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #map(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType map(String role,String propertyRef,boolean embedded){
  return new MapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedMap(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedMap(String role,String propertyRef,boolean embedded){
  return new OrderedMapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedMap(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedMap(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedMapType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @deprecated Use {@link #set(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType set(String role,String propertyRef,boolean embedded){
  return new SetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedSet(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedSet(String role,String propertyRef,boolean embedded){
  return new OrderedSetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedSet(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedSet(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedSetType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * Make this go somewhere else.  These aren't really linked this way anymore.  ScrollableResultSetProcessor is not tied in yet, so not sure yet exactly how that will play out.
 * @deprecated Going away!
 */
@Deprecated public ScrollableResultSetProcessor toOnDemandForm();
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Access to the delayed entity key
 * @return The delayed entity key
 * @deprecated No Hibernate code currently uses this method
 */
@Deprecated @SuppressWarnings(""UnusedDeclaration"") public EntityKey getDelayedEntityKey(){
  return delayedEntityKey;
}
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Deprecated as this is badly named for its use.
 * @deprecated Use {@link #getExplicitTableName} instead
 */
@Deprecated public String getSecondaryTableName(){
  return explicitTableName;
}
"
"/** 
 * Deprecated as this is badly named for its use.
 * @deprecated Use {@link #setExplicitTableName} instead
 */
@Deprecated public void setSecondaryTableName(String explicitTableName){
  setExplicitTableName(explicitTableName);
}
"
"/** 
 * Which of the properties of this class are database generated values on insert?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions();
"
"/** 
 * Which of the properties of this class are database generated values on update?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions();
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Which of the properties of this class are database generated values on insert?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions();
"
"/** 
 * Which of the properties of this class are database generated values on update?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions();
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(Iterator,Set,SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,Collections.<MappedSuperclass>emptySet(),sessionFactory,false);
}
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(Iterator,Set,SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,Collections.<MappedSuperclass>emptySet(),sessionFactory,false);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbeddedInXML();
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(Class theClass,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
@Deprecated public void lock(Object object,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param entityName The name of the entity
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
@SuppressWarnings({""JavaDoc""}) @Deprecated public void lock(String entityName,Object object,LockMode lockMode);
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public void refresh(Object object,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(Class clazz,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Should the session be automatically closed after transaction completion.
 * @param autoClose Should the session be automatically closed
 * @return {@code this}, for method chaining
 * @deprecated Only integrations can specify autoClosing behavior of individual sessions.  See{@link org.hibernate.engine.spi.SessionOwner}
 */
@Deprecated public SessionBuilder autoClose(boolean autoClose);
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use {@link #getLoadQueryInfluencers} instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(Class theClass,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
@Deprecated public void lock(Object object,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
@SuppressWarnings({""JavaDoc""}) @Deprecated public void lock(String entityName,Object object,LockMode lockMode);
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public void refresh(Object object,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(Class clazz,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Should the session be automatically closed after transaction completion
 * @param autoClose Should the session be automatically closed
 * @return {@code this}, for method chaining
 * @deprecated Only integrations can specify autoClosing behavior of individual sessions.  See{@link org.hibernate.engine.spi.SessionOwner}
 */
@Deprecated public SessionBuilder autoClose(boolean autoClose);
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use {@link #getLoadQueryInfluencers} instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(Class theClass,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
@Deprecated public void lock(Object object,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param entityName The name of the entity
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
@SuppressWarnings({""JavaDoc""}) @Deprecated public void lock(String entityName,Object object,LockMode lockMode);
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public void refresh(Object object,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(Class clazz,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Should the session be automatically closed after transaction completion.
 * @param autoClose Should the session be automatically closed
 * @return {@code this}, for method chaining
 * @deprecated Only integrations can specify autoClosing behavior of individual sessions.  See{@link org.hibernate.engine.spi.SessionOwner}
 */
@Deprecated public SessionBuilder autoClose(boolean autoClose);
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use {@link #getLoadQueryInfluencers} instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(Class theClass,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
@Deprecated public void lock(Object object,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
@SuppressWarnings({""JavaDoc""}) @Deprecated public void lock(String entityName,Object object,LockMode lockMode);
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public void refresh(Object object,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(Class clazz,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Should the session be automatically closed after transaction completion
 * @param autoClose Should the session be automatically closed
 * @return {@code this}, for method chaining
 * @deprecated Only integrations can specify autoClosing behavior of individual sessions.  See{@link org.hibernate.engine.spi.SessionOwner}
 */
@Deprecated public SessionBuilder autoClose(boolean autoClose);
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use {@link #getLoadQueryInfluencers} instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Which of the properties of this class are database generated values on insert?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions();
"
"/** 
 * Which of the properties of this class are database generated values on update?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions();
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing"",""unchecked""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use {@link #getLoadQueryInfluencers} instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Which of the properties of this class are database generated values on insert?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions();
"
"/** 
 * Which of the properties of this class are database generated values on update?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions();
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Which of the properties of this class are database generated values on insert?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions();
"
"/** 
 * Which of the properties of this class are database generated values on update?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions();
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retreive the type for a given filter parrameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use {@link #getLoadQueryInfluencers} instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Make this go somewhere else.  These aren't really linked this way anymore.  ScrollableResultSetProcessor is not tied in yet, so not sure yet exactly how that will play out.
 * @deprecated Going away!
 */
@Deprecated public ScrollableResultSetProcessor toOnDemandForm();
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,JoinType,Criterion)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-seperated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,String,org.hibernate.sql.JoinType,org.hibernate.criterion.Criterion)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Get the connection provider
 * @deprecated Access to connections via {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} shouldbe preferred over access via  {@link ConnectionProvider}, whenever possible. {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} is tied to the Hibernate Session toproperly account for contextual information.  See  {@link SessionImplementor#getJdbcConnectionAccess()}
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Close the provider.
 * @deprecated Use {@link #stop} instead
 */
@SuppressWarnings(""UnusedDeclaration"") @Deprecated public void close(){
  stop();
}
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries() throws HibernateException ;
"
"/** 
 * Projection counting the values
 * @param idPropertyName Name of the identifier property
 * @deprecated Use {@link #count()}.
 */
public AuditProjection count(String idPropertyName){
  return new PropertyAuditProjection(new OriginalIdPropertyName(idPropertyName),""count"",false);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Allow access to the id generator factory, though this is only needed/allowed from configuration.
 * @return Access to the identifier generator factory
 * @deprecated temporary solution 
 */
@Deprecated public IdentifierGeneratorFactory getIdentifierGeneratorFactory();
"
"/** 
 * @deprecated explicit entity mode support is deprecated
 */
@Deprecated public TypedValue(Type type,Object value,EntityMode entityMode){
  this(type,value);
}
"
"/** 
 * Getter for property 'source'.  This is the session from which the event originated. <p/> Some of the pre-* events had previous exposed the event source using getSource() because they had not originally extended from {@link AbstractEvent}.
 * @return Value for property 'source'.
 * @deprecated Use {@link #getSession} instead
 */
@Deprecated public EventSource getSource(){
  return getSession();
}
"
"/** 
 * Deprecated as this is badly named for its use.
 * @deprecated Use {@link #getExplicitTableName} instead
 */
@Deprecated public String getSecondaryTableName(){
  return explicitTableName;
}
"
"/** 
 * Deprecated as this is badly named for its use.
 * @deprecated Use {@link #setExplicitTableName} instead
 */
@Deprecated public void setSecondaryTableName(String explicitTableName){
  setExplicitTableName(explicitTableName);
}
"
"/** 
 * Creates a single node AST. <p/> TODO : this is silly, remove it...
 * @param astFactory The factory.
 * @param type The node type.
 * @param text The node text.
 * @return AST - A single node tree.
 * @deprecated silly
 */
@Deprecated public static AST create(ASTFactory astFactory,int type,String text){
  return astFactory.create(type,text);
}
"
"/** 
 * Get the name of a constant defined on the given class which has the given value. <p/> Note, if multiple constants have this value, the first will be returned which is known to be different on different JVM implementations.
 * @param owner The class which defines the constant
 * @param value The value of the constant.
 * @return The token type name, *or* the integer value if the name could not be found.
 * @deprecated Use #getTokenTypeName instead
 */
@Deprecated public static String getConstantName(Class owner,int value){
  return getTokenTypeName(owner,value);
}
"
"/** 
 * Allow injection of the dialect to use.
 * @param dialect The dialect
 * @deprecated The intention is that Dialect should be required to be specified up-front and it would then getctor injected.
 */
@Deprecated public void setDialect(Dialect dialect);
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * Get the connection provider
 * @deprecated Access to connections via {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} shouldbe preferred over access via  {@link ConnectionProvider}, whenever possible. {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} is tied to the Hibernate Session toproperly account for contextual information.  See  {@link SessionImplementor#getJdbcConnectionAccess()}
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retrieve the type for a given filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use {@link #getLoadQueryInfluencers} instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
@Deprecated @Override public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * Obtain service for providing JDBC connections.
 * @return The connection provider.
 * @deprecated See deprecation notice on {@link org.hibernate.engine.spi.SessionFactoryImplementor#getConnectionProvider()}for details
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
@Deprecated @Override public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * Constructs a map type capable of creating ordered maps of the given role.
 * @param role The collection role name.
 * @param propertyRef The property ref name.
 * @param isEmbeddedInXML Is this collection to embed itself in xml
 * @deprecated Use {@link #OrderedMapType(TypeFactory.TypeScope,String,String)} instead.instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public OrderedMapType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * Constructs a set type capable of creating ordered sets of the given role.
 * @param typeScope The scope for this type instance.
 * @param role The collection role name.
 * @param propertyRef The property ref name.
 * @param isEmbeddedInXML Is this collection to embed itself in xml
 * @deprecated Use {@link #OrderedSetType(org.hibernate.type.TypeFactory.TypeScope,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public OrderedSetType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
@Deprecated public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return value;
  }
 else   if (clazz == Integer.class) {
    return (int)value;
  }
 else   if (clazz == Short.class) {
    return (short)value;
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    final Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,incrementSize);
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * Creates a single node AST. <p/> TODO : this is silly, remove it...
 * @param astFactory The factory.
 * @param type The node type.
 * @param text The node text.
 * @return AST - A single node tree.
 * @deprecated silly
 */
@Deprecated public static AST create(ASTFactory astFactory,int type,String text){
  return astFactory.create(type,text);
}
"
"/** 
 * Get the name of a constant defined on the given class which has the given value. <p/> Note, if multiple constants have this value, the first will be returned which is known to be different on different JVM implementations.
 * @param owner The class which defines the constant
 * @param value The value of the constant.
 * @return The token type name, *or* the integer value if the name could not be found.
 * @deprecated Use #getTokenTypeName instead
 */
@Deprecated public static String getConstantName(Class owner,int value){
  return getTokenTypeName(owner,value);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect) throws SQLException {
  this(connection,dialect,null,true);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration,boolean)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect,boolean extras) throws SQLException {
  this(connection,dialect,null,extras);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public boolean isXMLElement();
"
"/** 
 * A representation of the value to be embedded in an XML element.
 * @param node The XML node to which to write the value
 * @param value The value to write
 * @param factory The session factory
 * @throws HibernateException An error from Hibernate
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setToXMLNode(Node node,Object value,SessionFactoryImplementor factory) throws HibernateException ;
"
"/** 
 * Parse the XML representation of an instance.
 * @param xml The XML node from which to read the value
 * @param factory The session factory
 * @return an instance of the {@link #getReturnedClass() mapped class}
 * @throws HibernateException An error from Hibernate
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public Object fromXMLNode(Node xml,Mapping factory) throws HibernateException ;
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType customCollection(String typeName,Properties typeParameters,String role,String propertyRef,boolean embedded){
  Class typeClass;
  try {
    typeClass=ReflectHelper.classForName(typeName);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new MappingException(""user collection type class not found: "" + typeName,cnfe);
  }
  CustomCollectionType result=new CustomCollectionType(typeScope,typeClass,role,propertyRef,embedded);
  if (typeParameters != null) {
    injectParameters(result.getUserType(),typeParameters);
  }
  return result;
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #specialOneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType specialOneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return specialOneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #array(String,String,Class)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType array(String role,String propertyRef,boolean embedded,Class elementClass){
  return new ArrayType(typeScope,role,propertyRef,elementClass,embedded);
}
"
"/** 
 * @deprecated Use {@link #list(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType list(String role,String propertyRef,boolean embedded){
  return new ListType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #bag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType bag(String role,String propertyRef,boolean embedded){
  return new BagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #idbag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType idbag(String role,String propertyRef,boolean embedded){
  return new IdentifierBagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #map(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType map(String role,String propertyRef,boolean embedded){
  return new MapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedMap(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedMap(String role,String propertyRef,boolean embedded){
  return new OrderedMapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedMap(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedMap(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedMapType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @deprecated Use {@link #set(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType set(String role,String propertyRef,boolean embedded){
  return new SetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedSet(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedSet(String role,String propertyRef,boolean embedded){
  return new OrderedSetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedSet(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedSet(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedSetType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * Unsupported operation
 * @return nothing ever, this only throws!
 * @throws UnsupportedOperationException
 * @deprecated DO NOT USE, WILL ONLY THROW AT YOU!
 */
@Deprecated @SuppressWarnings(""UnusedDeclaration"") public long getDBSQLExecutionSample(){
  throw new UnsupportedOperationException(""Use getQueryExecutionCount() instead"");
}
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(Iterator,Set,SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,Collections.<MappedSuperclass>emptySet(),sessionFactory,false);
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Release all resources held by this provider.
 * @throws HibernateException Indicates a problem closing the underlying pool or releasing resources
 * @deprecated Use {@link #stop} instead
 */
@Deprecated public void close() throws HibernateException {
  stop();
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect) throws SQLException {
  this(connection,dialect,null,true);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration,boolean)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect,boolean extras) throws SQLException {
  this(connection,dialect,null,extras);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect) throws SQLException {
  this(connection,dialect,null,true);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration,boolean)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect,boolean extras) throws SQLException {
  this(connection,dialect,null,extras);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.<String,SQLFunction>emptyMap()));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #translateOrderBy} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.EMPTY_MAP));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #translateOrderBy} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.<String,SQLFunction>emptyMap()));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #translateOrderBy} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries() throws HibernateException ;
"
"/** 
 * Temporarily exposed since Configuration is still around and much code still uses Configuration.  This allows code to configure the builder and access that to configure Configuration object (used from HEM atm).
 * @return The settings map.
 * @deprecated Temporarily exposed since Configuration is still around and much code still uses Configuration.This allows code to configure the builder and access that to configure Configuration object (used from HEM atm).
 */
@Deprecated public Map getSettings(){
  return settings;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Obtain service for providing JDBC connections.
 * @return The connection provider.
 * @deprecated See deprecation notice on {@link org.hibernate.engine.spi.SessionFactoryImplementor#getConnectionProvider()}for details
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * @deprecated explicit entity mode support is deprecated
 */
@Deprecated public TypedValue(Type type,Object value,EntityMode entityMode){
  this(type,value);
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @param classLoaderService ClassLoaderService
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize,ClassLoaderService classLoaderService){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=classLoaderService.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    final Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,incrementSize);
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * @deprecated explicit entity mode support is deprecated
 */
@Deprecated public TypedValue(Type type,Object value,EntityMode entityMode){
  this(type,value);
}
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link org.hibernate.mapping.PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(java.util.Iterator,org.hibernate.engine.spi.SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,sessionFactory,false);
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * Temporarily exposed since Configuration is still around and much code still uses Configuration.  This allows code to configure the builder and access that to configure Configuration object (used from HEM atm).
 * @return The settings map.
 * @deprecated Temporarily exposed since Configuration is still around and much code still uses Configuration.This allows code to configure the builder and access that to configure Configuration object (used from HEM atm).
 */
@Deprecated public Map getSettings(){
  return settings;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
  return this;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public void add(XmlDocument metadataXml){
}
"
"/** 
 * @deprecated No longer supported
 */
@Deprecated public Configuration addXML(String xml) throws MappingException {
  return this;
}
"
"/** 
 * @deprecated This form (accepting a ClassLoader) is no longer supported.  Instead, add the ClassLoaderto the ClassLoaderService on the ServiceRegistry associated with this Configuration
 */
@Deprecated public Configuration addResource(String resourceName,ClassLoader classLoader) throws MappingException {
  return addResource(resourceName);
}
"
"/** 
 * @deprecated Does nothing
 */
@Deprecated public void buildMappings(){
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated Use {@link #getText} instead
 */
@Deprecated public String getName(){
  return text;
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.classLoaderService=new ClassLoaderServiceImpl();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Create an entity instance initialized with the given identifier.
 * @param id The identifier value for the entity to be instantiated.
 * @return The instantiated entity.
 * @throws HibernateException
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public Object instantiate(Serializable id) throws HibernateException ;
"
"/** 
 * Extract the identifier value from the given entity.
 * @param entity The entity from which to extract the identifier value.
 * @return The identifier value.
 * @throws HibernateException If the entity does not define an identifier property, or anerror occurs accessing its value.
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead.
 */
public Serializable getIdentifier(Object entity) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public void setIdentifier(Object entity,Serializable id) throws HibernateException ;
"
"/** 
 * Inject the given identifier and version into the entity, in order to ""roll back"" to their original values.
 * @param entity The entity for which to reset the id/version values
 * @param currentId The identifier value to inject into the entity.
 * @param currentVersion The version value to inject into the entity.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion);
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)}instead.
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #SpecialOneToOneType(org.hibernate.type.TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)} instead.
 */
@Deprecated public SpecialOneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public boolean isXMLElement();
"
"/** 
 * A representation of the value to be embedded in an XML element.
 * @param node The XML node to which to write the value
 * @param value The value to write
 * @param factory The session factory
 * @throws HibernateException An error from Hibernate
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setToXMLNode(Node node,Object value,SessionFactoryImplementor factory) throws HibernateException ;
"
"/** 
 * Parse the XML representation of an instance.
 * @param xml The XML node from which to read the value
 * @param factory The session factory
 * @return an instance of the {@link #getReturnedClass() mapped class}
 * @throws HibernateException An error from Hibernate
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public Object fromXMLNode(Node xml,Mapping factory) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries() throws HibernateException ;
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
  return this;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public void add(XmlDocument metadataXml){
}
"
"/** 
 * @deprecated No longer supported
 */
@Deprecated public Configuration addXML(String xml) throws MappingException {
  return this;
}
"
"/** 
 * @deprecated This form (accepting a ClassLoader) is no longer supported.  Instead, add the ClassLoaderto the ClassLoaderService on the ServiceRegistry associated with this Configuration
 */
@Deprecated public Configuration addResource(String resourceName,ClassLoader classLoader) throws MappingException {
  return addResource(resourceName);
}
"
"/** 
 * @deprecated Does nothing
 */
@Deprecated public void buildMappings(){
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * Read a mapping as an application resource using the convention that a class named  {@code foo.bar.Foo} ismapped by a file named  {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 * @param entityClass The mapped class. Cannot be {@code null} null.
 * @return this (for method chaining purposes)
 * @deprecated hbm.xml is a legacy mapping format now considered deprecated.
 */
@Deprecated public MetadataSources addClass(Class entityClass){
  if (entityClass == null) {
    throw new IllegalArgumentException(""The specified class cannot be null"");
  }
  LOG.debugf(""adding resource mappings from class convention : %s"",entityClass.getName());
  final String mappingResourceName=entityClass.getName().replace('.','/') + "".hbm.xml"";
  addResource(mappingResourceName);
  return this;
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Checks to see if the given mode is the same as  {@link #MANUAL}.
 * @param mode The mode to check
 * @return true/false
 * @deprecated Just use equality check against {@link #MANUAL}.  Legacy from before this was an enum
 */
@Deprecated public static boolean isManualFlushMode(FlushMode mode){
  return MANUAL.level == mode.level;
}
"
"/** 
 * Read a mapping as an application resource using the convention that a class named  {@code foo.bar.Foo} ismapped by a file named  {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 * @param entityClass The mapped class. Cannot be {@code null} null.
 * @return this (for method chaining purposes)
 * @deprecated hbm.xml is a legacy mapping format now considered deprecated.
 */
@Deprecated public MetadataSources addClass(Class entityClass){
  if (entityClass == null) {
    throw new IllegalArgumentException(""The specified class cannot be null"");
  }
  LOG.debugf(""adding resource mappings from class convention : %s"",entityClass.getName());
  final String mappingResourceName=entityClass.getName().replace('.','/') + "".hbm.xml"";
  addResource(mappingResourceName);
  return this;
}
"
"/** 
 * Get the Class of the  {@link javax.persistence.IdClass} associated with the entity, if one.
 * @deprecated Use {@link #getLookupClassBinding()} instead
 */
@Deprecated public Class getIdClassClass(){
  ensureBound();
  return getLookupClassBinding().getIdClassType();
}
"
"/** 
 * @deprecated Use {@link #getLookupClassBinding()} instead
 */
@Deprecated public String getIdClassPropertyAccessorName(){
  ensureBound();
  return getLookupClassBinding().getAccessStrategy();
}
"
"/** 
 * @deprecated Use {@link #getLookupClassBinding()} instead
 */
@Deprecated public boolean isIdentifierMapper(){
  ensureBound();
  return isNonAggregatedComposite() && getLookupClassBinding().getIdClassType() != null;
}
"
"/** 
 * Read a mapping as an application resource using the convention that a class named  {@code foo.bar.Foo} ismapped by a file named  {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 * @param entityClass The mapped class. Cannot be {@code null} null.
 * @return this (for method chaining purposes)
 * @deprecated hbm.xml is a legacy mapping format now considered deprecated.
 */
@Deprecated public MetadataSources addClass(Class entityClass){
  if (entityClass == null) {
    throw new IllegalArgumentException(""The specified class cannot be null"");
  }
  LOG.debugf(""adding resource mappings from class convention : %s"",entityClass.getName());
  final String mappingResourceName=entityClass.getName().replace('.','/') + "".hbm.xml"";
  addResource(mappingResourceName);
  return this;
}
"
"/** 
 * Get the Class of the  {@link javax.persistence.IdClass} associated with the entity, if one.
 * @deprecated Use {@link #getLookupClassBinding()} instead
 */
@Deprecated public Class getIdClassClass(){
  ensureBound();
  return getLookupClassBinding().getIdClassType();
}
"
"/** 
 * @deprecated Use {@link #getLookupClassBinding()} instead
 */
@Deprecated public String getIdClassPropertyAccessorName(){
  ensureBound();
  return getLookupClassBinding().getAccessStrategy();
}
"
"/** 
 * @deprecated Use {@link #getLookupClassBinding()} instead
 */
@Deprecated public boolean isIdentifierMapper(){
  ensureBound();
  return isNonAggregatedComposite() && getLookupClassBinding().getIdClassType() != null;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
  return this;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public void add(XmlDocument metadataXml){
}
"
"/** 
 * @deprecated No longer supported
 */
@Deprecated public Configuration addXML(String xml) throws MappingException {
  return this;
}
"
"/** 
 * @deprecated This form (accepting a ClassLoader) is no longer supported.  Instead, add the ClassLoaderto the ClassLoaderService on the ServiceRegistry associated with this Configuration
 */
@Deprecated public Configuration addResource(String resourceName,ClassLoader classLoader) throws MappingException {
  return addResource(resourceName);
}
"
"/** 
 * @deprecated Does nothing
 */
@Deprecated public void buildMappings(){
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Get the UniqueDelegate supported by this dialect
 * @return The UniqueDelegate
 * @deprecated
 */
@Deprecated public UniqueDelegate getUniqueDelegate(){
  return uniqueDelegate;
}
"
"/** 
 * Deprecated as this is badly named for its use.
 * @deprecated Use {@link #getExplicitTableName} instead
 */
@Deprecated public String getSecondaryTableName(){
  return explicitTableName;
}
"
"/** 
 * Deprecated as this is badly named for its use.
 * @deprecated Use {@link #setExplicitTableName} instead
 */
@Deprecated public void setSecondaryTableName(String explicitTableName){
  setExplicitTableName(explicitTableName);
}
"
"/** 
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * @deprecated use the Repository instead, available from {@link #getRefliteRepository}
 */
@Deprecated public <T>Class<T> locateClassByName(String name);
"
"/** 
 * todo : maybe a `Type makeDomainType(TypeDescriptor)` method instead?
 * @deprecated use the Repository instead, available from {@link #getRefliteRepository}
 */
@Deprecated public Type makeDomainType(String className);
"
"/** 
 * @deprecated use the Repository instead, available from {@link #getRefliteRepository}
 */
@Deprecated public JavaClassReference makeJavaClassReference(String className);
"
"/** 
 * @deprecated use the Repository instead, available from {@link #getRefliteRepository}
 */
@Deprecated public JavaClassReference makeJavaClassReference(Class<?> clazz);
"
"/** 
 * @deprecated use the Repository instead, available from {@link #getRefliteRepository}
 */
@Deprecated public JavaClassReference makeJavaPropertyClassReference(JavaClassReference propertyContainerClassReference,String propertyName);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Get the UniqueDelegate supported by this dialect
 * @return The UniqueDelegate
 * @deprecated
 */
@Deprecated public UniqueDelegate getUniqueDelegate(){
  return uniqueDelegate;
}
"
"/** 
 * @deprecated Use {@link #getText} instead
 */
@Deprecated public String getName(){
  return text;
}
"
"/** 
 * @deprecated use the JavaTypeDescriptorRepository instead, available from {@link #getRefliteRepository}
 */
@Deprecated public <T>Class<T> locateClassByName(String name);
"
"/** 
 * todo : maybe a `Type makeDomainType(JavaTypeDescriptor)` method instead?
 * @deprecated use the JavaTypeDescriptorRepository instead, available from {@link #getRefliteRepository}
 */
@Deprecated public Type makeDomainType(String className);
"
"/** 
 * @deprecated use the JavaTypeDescriptorRepository instead, available from {@link #getRefliteRepository}
 */
@Deprecated public JavaClassReference makeJavaClassReference(String className);
"
"/** 
 * @deprecated use the JavaTypeDescriptorRepository instead, available from {@link #getRefliteRepository}
 */
@Deprecated public JavaClassReference makeJavaClassReference(Class<?> clazz);
"
"/** 
 * @deprecated use the JavaTypeDescriptorRepository instead, available from {@link #getRefliteRepository}
 */
@Deprecated public JavaClassReference makeJavaPropertyClassReference(JavaClassReference propertyContainerClassReference,String propertyName);
"
"/** 
 * @deprecated This belongs on the attribute, not on its type.
 */
@Deprecated public boolean isAssociation();
"
"/** 
 * Create an entity instance initialized with the given identifier.
 * @param id The identifier value for the entity to be instantiated.
 * @return The instantiated entity.
 * @throws HibernateException
 * @deprecated Use {@link #instantiate(Serializable,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public Object instantiate(Serializable id) throws HibernateException ;
"
"/** 
 * Extract the identifier value from the given entity.
 * @param entity The entity from which to extract the identifier value.
 * @return The identifier value.
 * @throws HibernateException If the entity does not define an identifier property, or anerror occurs accessing its value.
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead.
 */
public Serializable getIdentifier(Object entity) throws HibernateException ;
"
"/** 
 * Inject the identifier value into the given entity. </p> Has no effect if the entity does not define an identifier property
 * @param entity The entity to inject with the identifier value.
 * @param id The value to be injected as the identifier.
 * @deprecated Use {@link #setIdentifier(Object,Serializable,SessionImplementor)} instead.
 */
@SuppressWarnings({""JavaDoc""}) public void setIdentifier(Object entity,Serializable id) throws HibernateException ;
"
"/** 
 * Inject the given identifier and version into the entity, in order to ""roll back"" to their original values.
 * @param entity The entity for which to reset the id/version values
 * @param currentId The identifier value to inject into the entity.
 * @param currentVersion The version value to inject into the entity.
 * @deprecated Use {@link #resetIdentifier(Object,Serializable,Object,SessionImplementor)} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) public void resetIdentifier(Object entity,Serializable currentId,Object currentVersion);
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public EntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,persistenceContext);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public EntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,persistenceContext);
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing"",""unchecked""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    final Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,incrementSize);
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing"",""unchecked""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * @deprecated explicit entity mode support is deprecated
 */
@Deprecated public TypedValue(Type type,Object value,EntityMode entityMode){
  this(type,value);
}
"
"/** 
 * @deprecated explicit entity mode support is deprecated
 */
@Deprecated public TypedValue(Type type,Object value,EntityMode entityMode){
  this(type,value);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Read a mapping as an application resource using the convention that a class named  {@code foo.bar.Foo} ismapped by a file named  {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 * @param entityClass The mapped class. Cannot be {@code null} null.
 * @return this (for method chaining purposes)
 * @deprecated hbm.xml is a legacy mapping format now considered deprecated.
 */
@Deprecated public MetadataSources addClass(Class entityClass){
  if (entityClass == null) {
    throw new IllegalArgumentException(""The specified class cannot be null"");
  }
  LOG.debugf(""adding resource mappings from class convention : %s"",entityClass.getName());
  final String mappingResourceName=entityClass.getName().replace('.','/') + "".hbm.xml"";
  addResource(mappingResourceName);
  return this;
}
"
"/** 
 * Access to the delayed entity key
 * @return The delayed entity key
 * @deprecated No Hibernate code currently uses this method
 */
@Deprecated @SuppressWarnings(""UnusedDeclaration"") public EntityKey getDelayedEntityKey(){
  return delayedEntityKey;
}
"
"/** 
 * Access to the delayed entity key
 * @return The delayed entity key
 * @deprecated No Hibernate code currently uses this method
 */
@Deprecated @SuppressWarnings(""UnusedDeclaration"") public EntityKey getDelayedEntityKey(){
  return delayedEntityKey;
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
@Deprecated public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return value;
  }
 else   if (clazz == Integer.class) {
    return (int)value;
  }
 else   if (clazz == Short.class) {
    return (short)value;
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
@Deprecated public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return value;
  }
 else   if (clazz == Integer.class) {
    return (int)value;
  }
 else   if (clazz == Short.class) {
    return (short)value;
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * @deprecated use the JavaTypeDescriptorRepository instead, available from {@link #getJavaTypeDescriptorRepository}
 */
@Deprecated public <T>Class<T> locateClassByName(String name);
"
"/** 
 * todo : maybe a `Type makeDomainType(JavaTypeDescriptor)` method instead?
 * @deprecated use the JavaTypeDescriptorRepository instead, available from {@link #getJavaTypeDescriptorRepository}
 */
@Deprecated public Type makeDomainType(String className);
"
"/** 
 * @deprecated use the JavaTypeDescriptorRepository instead, available from {@link #getJavaTypeDescriptorRepository}
 */
@Deprecated public JavaClassReference makeJavaClassReference(String className);
"
"/** 
 * @deprecated use the JavaTypeDescriptorRepository instead, available from {@link #getJavaTypeDescriptorRepository}
 */
@Deprecated public JavaClassReference makeJavaClassReference(Class<?> clazz);
"
"/** 
 * @deprecated use the JavaTypeDescriptorRepository instead, available from {@link #getJavaTypeDescriptorRepository}
 */
@Deprecated public JavaClassReference makeJavaPropertyClassReference(JavaClassReference propertyContainerClassReference,String propertyName);
"
"/** 
 * Get the Class of the  {@link javax.persistence.IdClass} associated with the entity, if one.
 * @deprecated Use {@link #getLookupClassBinding()} instead
 */
@Deprecated public Class getIdClassClass(){
  ensureBound();
  return getLookupClassBinding().getIdClassType();
}
"
"/** 
 * @deprecated Use {@link #getLookupClassBinding()} instead
 */
@Deprecated public String getIdClassPropertyAccessorName(){
  ensureBound();
  return getLookupClassBinding().getAccessStrategy();
}
"
"/** 
 * @deprecated Use {@link #getLookupClassBinding()} instead
 */
@Deprecated public boolean isIdentifierMapper(){
  ensureBound();
  return isNonAggregatedComposite() && getLookupClassBinding().getIdClassType() != null;
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect) throws SQLException {
  this(connection,dialect,null,true);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration,boolean)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect,boolean extras) throws SQLException {
  this(connection,dialect,null,extras);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType customCollection(String typeName,Properties typeParameters,String role,String propertyRef,boolean embedded){
  Class typeClass;
  try {
    typeClass=ReflectHelper.classForName(typeName);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new MappingException(""user collection type class not found: "" + typeName,cnfe);
  }
  CustomCollectionType result=new CustomCollectionType(typeScope,typeClass,role,propertyRef,embedded);
  if (typeParameters != null) {
    injectParameters(result.getUserType(),typeParameters);
  }
  return result;
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #specialOneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType specialOneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return specialOneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #array(String,String,Class)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType array(String role,String propertyRef,boolean embedded,Class elementClass){
  return new ArrayType(typeScope,role,propertyRef,elementClass,embedded);
}
"
"/** 
 * @deprecated Use {@link #list(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType list(String role,String propertyRef,boolean embedded){
  return new ListType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #bag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType bag(String role,String propertyRef,boolean embedded){
  return new BagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #idbag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType idbag(String role,String propertyRef,boolean embedded){
  return new IdentifierBagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #map(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType map(String role,String propertyRef,boolean embedded){
  return new MapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedMap(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedMap(String role,String propertyRef,boolean embedded){
  return new OrderedMapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedMap(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedMap(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedMapType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @deprecated Use {@link #set(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType set(String role,String propertyRef,boolean embedded){
  return new SetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedSet(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedSet(String role,String propertyRef,boolean embedded){
  return new OrderedSetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedSet(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedSet(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedSetType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * Read a mapping as an application resource using the convention that a class named  {@code foo.bar.Foo} ismapped by a file named  {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 * @param entityClass The mapped class. Cannot be {@code null} null.
 * @return this (for method chaining purposes)
 * @deprecated hbm.xml is a legacy mapping format now considered deprecated.
 */
@Deprecated public MetadataSources addClass(Class entityClass){
  if (entityClass == null) {
    throw new IllegalArgumentException(""The specified class cannot be null"");
  }
  LOG.debugf(""adding resource mappings from class convention : %s"",entityClass.getName());
  final String mappingResourceName=entityClass.getName().replace('.','/') + "".hbm.xml"";
  addResource(mappingResourceName);
  return this;
}
"
"/** 
 * todo : maybe a `Type makeDomainType(JavaTypeDescriptor)` method instead?
 * @deprecated use the JavaTypeDescriptorRepository instead, available from {@link #getJavaTypeDescriptorRepository}
 */
@Deprecated public Type makeDomainType(String className);
"
"/** 
 * @deprecated Use {@link #getText} instead
 */
@Deprecated public String getName(){
  return text;
}
"
"/** 
 * Gets the metadata.
 * @return the metadata.
 * @deprecated This should only be needed for testing and should ultimately be removed.
 */
public MetadataImplementor getMetadata(){
  return metadata;
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the application class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the resource class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the Hibernate class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Temporarily exposed since Configuration is still around and much code still uses Configuration.  This allows code to configure the builder and access that to configure Configuration object (used from HEM atm).
 * @return The settings map.
 * @deprecated Temporarily exposed since Configuration is still around and much code still uses Configuration.This allows code to configure the builder and access that to configure Configuration object (used from HEM atm).
 */
@Deprecated public Map getSettings(){
  return settings;
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the application class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the resource class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the Hibernate class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry.
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Temporarily exposed since Configuration is still around and much code still uses Configuration.  This allows code to configure the builder and access that to configure Configuration object (used from HEM atm).
 * @return The settings map.
 * @deprecated Temporarily exposed since Configuration is still around and much code still uses Configuration.This allows code to configure the builder and access that to configure Configuration object (used from HEM atm).
 */
@Deprecated public Map getSettings(){
  return settings;
}
"
"/** 
 * Get the Class of the  {@link javax.persistence.IdClass} associated with the entity, if one.
 * @deprecated Use {@link #getLookupClassBinding()} instead
 */
@Deprecated public Class getIdClassClass(){
  ensureBound();
  return getLookupClassBinding().getIdClassType();
}
"
"/** 
 * @deprecated Use {@link #getLookupClassBinding()} instead
 */
@Deprecated public String getIdClassPropertyAccessorName(){
  ensureBound();
  return getLookupClassBinding().getAccessStrategy();
}
"
"/** 
 * @deprecated Use {@link #getLookupClassBinding()} instead
 */
@Deprecated public boolean isIdentifierMapper(){
  ensureBound();
  return isNonAggregatedComposite() && getLookupClassBinding().getIdClassType() != null;
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the application class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the resource class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration""}) public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the Hibernate class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Applies the specified  {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry
 * @param classLoader The class loader to use
 * @return {@code this}, for method chaining
 * @deprecated Use {@link #with(ClassLoader)} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader){
  return with(classLoader);
}
"
"/** 
 * Get the Class of the  {@link javax.persistence.IdClass} associated with the entity, if one.
 * @deprecated Use {@link #getLookupClassBinding()} instead
 */
@Deprecated public Class getIdClassClass(){
  ensureBound();
  return getLookupClassBinding().getIdClassType();
}
"
"/** 
 * @deprecated Use {@link #getLookupClassBinding()} instead
 */
@Deprecated public String getIdClassPropertyAccessorName(){
  ensureBound();
  return getLookupClassBinding().getAccessStrategy();
}
"
"/** 
 * @deprecated Use {@link #getLookupClassBinding()} instead
 */
@Deprecated public boolean isIdentifierMapper(){
  ensureBound();
  return isNonAggregatedComposite() && getLookupClassBinding().getIdClassType() != null;
}
"
"/** 
 * Temporarily exposed since Configuration is still around and much code still uses Configuration.  This allows code to configure the builder and access that to configure Configuration object (used from HEM atm).
 * @return The settings map.
 * @deprecated Temporarily exposed since Configuration is still around and much code still uses Configuration.This allows code to configure the builder and access that to configure Configuration object (used from HEM atm).
 */
@Deprecated public Map getSettings(){
  return settings;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
  return this;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public void add(XmlDocument metadataXml){
}
"
"/** 
 * @deprecated No longer supported
 */
@Deprecated public Configuration addXML(String xml) throws MappingException {
  return this;
}
"
"/** 
 * @deprecated This form (accepting a ClassLoader) is no longer supported.  Instead, add the ClassLoaderto the ClassLoaderService on the ServiceRegistry associated with this Configuration
 */
@Deprecated public Configuration addResource(String resourceName,ClassLoader classLoader) throws MappingException {
  return addResource(resourceName);
}
"
"/** 
 * @deprecated Does nothing
 */
@Deprecated public void buildMappings(){
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect) throws SQLException {
  this(connection,dialect,null,true);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration,boolean)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect,boolean extras) throws SQLException {
  this(connection,dialect,null,extras);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect) throws SQLException {
  this(connection,dialect,null,true);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration,boolean)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect,boolean extras) throws SQLException {
  this(connection,dialect,null,extras);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect) throws SQLException {
  this(connection,dialect,null,true);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration,boolean)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect,boolean extras) throws SQLException {
  this(connection,dialect,null,extras);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * Gets the metadata.
 * @return the metadata.
 * @deprecated This should only be needed for testing and should ultimately be removed.
 */
public MetadataImplementor getMetadata(){
  return metadata;
}
"
"/** 
 * Get the Class of the  {@link javax.persistence.IdClass} associated with the entity, if one.
 * @deprecated Use {@link #getLookupClassBinding()} instead
 */
@Deprecated public Class getIdClassClass(){
  ensureBound();
  return getLookupClassBinding().getIdClassType();
}
"
"/** 
 * Gets the metadata.
 * @return the metadata.
 * @deprecated This should only be needed for testing and should ultimately be removed.
 */
public MetadataImplementor getMetadata(){
  return metadata;
}
"
"/** 
 * @deprecated Use {@link #getLookupClassBinding()} instead
 */
@Deprecated public String getIdClassPropertyAccessorName(){
  ensureBound();
  return getLookupClassBinding().getAccessStrategy();
}
"
"/** 
 * @deprecated Use {@link #getLookupClassBinding()} instead
 */
@Deprecated public boolean isIdentifierMapper(){
  ensureBound();
  return isNonAggregatedComposite() && getLookupClassBinding().getIdClassType() != null;
}
"
"/** 
 * @deprecated Added temporarily to support legacy{@link org.hibernate.jpa.boot.archive.spi.ArchiveContext#getPersistenceUnitDescriptor()}calls
 */
@Deprecated public PersistenceUnitDescriptor getPersistenceUnitDescriptor();
"
"/** 
 * Is detection of Hibernate Mapping files allowed?
 * @return Whether detection of Mapping files is allowed.
 * @deprecated With move to unified schema, this setting is now deprecated and willbe removed once support for reading  {@code hbm.xml} files is fully removed.
 */
@Deprecated public boolean canDetectHibernateMappingFiles();
"
"/** 
 * todo : maybe a `Type makeDomainType(JavaTypeDescriptor)` method instead?
 * @deprecated use the JavaTypeDescriptorRepository instead, available from {@link #getJavaTypeDescriptorRepository}
 */
@Deprecated public Type makeDomainType(String className);
"
"/** 
 * @deprecated Use {@link #getEntityIdentifierBinding()} instead
 */
@Deprecated public int getColumnCount(){
  ensureBound();
  return identifierBinding.getColumnCount();
}
"
"/** 
 * Read a mapping as an application resource using the convention that a class named  {@code foo.bar.Foo} ismapped by a file named  {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 * @param entityClass The mapped class. Cannot be {@code null} null.
 * @return this (for method chaining purposes)
 * @deprecated hbm.xml is a legacy mapping format now considered deprecated.
 */
@Deprecated public MetadataSources addClass(Class entityClass){
  if (entityClass == null) {
    throw new IllegalArgumentException(""The specified class cannot be null"");
  }
  LOG.debugf(""adding resource mappings from class convention : %s"",entityClass.getName());
  final String mappingResourceName=entityClass.getName().replace('.','/') + "".hbm.xml"";
  addResource(mappingResourceName);
  return this;
}
"
"/** 
 * @deprecated Use {@link #indexKnownClasses} instead
 */
@Deprecated public IndexView buildJandexView(){
  return buildJandexView(false);
}
"
"/** 
 * Create a Jandex IndexView from scratch given the sources information contained here.
 * @param autoIndexMemberTypes Should the types of class members automatically be added to the built index?
 * @return The built Jandex Index
 * @deprecated Use {@link #indexKnownClasses} instead
 */
@Deprecated public IndexView buildJandexView(boolean autoIndexMemberTypes){
  JandexInitManager jandexInitManager=new JandexInitManager(null,new ClassLoaderAccessImpl(null,getServiceRegistry().getService(ClassLoaderService.class)),autoIndexMemberTypes);
  JandexIndexBuilder.process(jandexInitManager,this);
  return jandexInitManager.buildIndex();
}
"
"/** 
 * Is detection of Hibernate Mapping files allowed?
 * @return Whether detection of Mapping files is allowed.
 * @deprecated With move to unified schema, this setting is now deprecated and willbe removed once support for reading  {@code hbm.xml} files is fully removed.
 */
@Deprecated public boolean canDetectHibernateMappingFiles();
"
"/** 
 * Not used!
 * @param jarPath The jar path
 * @return The url from the path?
 * @deprecated Not used!
 */
@Deprecated @SuppressWarnings(""UnusedDeclaration"") public URL getURLFromPath(String jarPath);
"
"/** 
 * Gets the metadata.
 * @return the metadata.
 * @deprecated This should only be needed for testing and should ultimately be removed.
 */
public MetadataImplementor getMetadata(){
  return metadata;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
  return this;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public void add(XmlDocument metadataXml){
}
"
"/** 
 * @deprecated No longer supported
 */
@Deprecated public Configuration addXML(String xml) throws MappingException {
  return this;
}
"
"/** 
 * Read mappings from a DOM <tt>Document</tt>
 * @param doc The DOM document
 * @return this (for method chaining purposes)
 * @throws MappingException Indicates problems reading the DOM or processingthe mapping document.
 * @deprecated Use addURL, addResource, addFile, etc. instead
 */
@Deprecated public Configuration addDocument(org.w3c.dom.Document doc) throws MappingException {
  metadataSources.addDocument(doc);
  return this;
}
"
"/** 
 * @deprecated This form (accepting a ClassLoader) is no longer supported.  Instead, add the ClassLoaderto the ClassLoaderService on the ServiceRegistry associated with this Configuration
 */
@Deprecated public Configuration addResource(String resourceName,ClassLoader classLoader) throws MappingException {
  return addResource(resourceName);
}
"
"/** 
 * @deprecated Does nothing
 */
@Deprecated public void buildMappings(){
}
"
"/** 
 * Read a mapping as an application resource using the convention that a class named  {@code foo.bar.Foo} ismapped by a file named  {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 * @param entityClass The mapped class. Cannot be {@code null} null.
 * @return this (for method chaining purposes)
 * @deprecated hbm.xml is a legacy mapping format now considered deprecated.
 */
@Deprecated public MetadataSources addClass(Class entityClass){
  if (entityClass == null) {
    throw new IllegalArgumentException(""The specified class cannot be null"");
  }
  LOG.debugf(""adding resource mappings from class convention : %s"",entityClass.getName());
  final String mappingResourceName=entityClass.getName().replace('.','/') + "".hbm.xml"";
  addResource(mappingResourceName);
  return this;
}
"
"/** 
 * @deprecated Use {@link #indexKnownClasses} instead
 */
@Deprecated public IndexView buildJandexView(){
  return buildJandexView(false);
}
"
"/** 
 * Create a Jandex IndexView from scratch given the sources information contained here.
 * @param autoIndexMemberTypes Should the types of class members automatically be added to the built index?
 * @return The built Jandex Index
 * @deprecated Use {@link #indexKnownClasses} instead
 */
@Deprecated public IndexView buildJandexView(boolean autoIndexMemberTypes){
  JandexInitManager jandexInitManager=new JandexInitManager(null,new ClassLoaderAccessImpl(null,getServiceRegistry().getService(ClassLoaderService.class)),autoIndexMemberTypes);
  JandexIndexBuilder.process(jandexInitManager,this);
  return jandexInitManager.buildIndex();
}
"
"/** 
 * Read a mapping as an application resource using the convention that a class named  {@code foo.bar.Foo} ismapped by a file named  {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 * @param entityClass The mapped class. Cannot be {@code null} null.
 * @return this (for method chaining purposes)
 * @deprecated hbm.xml is a legacy mapping format now considered deprecated.
 */
@Deprecated public MetadataSources addClass(Class entityClass){
  if (entityClass == null) {
    throw new IllegalArgumentException(""The specified class cannot be null"");
  }
  LOG.debugf(""adding resource mappings from class convention : %s"",entityClass.getName());
  final String mappingResourceName=entityClass.getName().replace('.','/') + "".hbm.xml"";
  addResource(mappingResourceName);
  return this;
}
"
"/** 
 * @deprecated Use {@link #indexKnownClasses} instead
 */
@Deprecated public IndexView buildJandexView(){
  return buildJandexView(false);
}
"
"/** 
 * Create a Jandex IndexView from scratch given the sources information contained here.
 * @param autoIndexMemberTypes Should the types of class members automatically be added to the built index?
 * @return The built Jandex Index
 * @deprecated Use {@link #indexKnownClasses} instead
 */
@Deprecated public IndexView buildJandexView(boolean autoIndexMemberTypes){
  JandexInitManager jandexInitManager=new JandexInitManager(null,new ClassLoaderAccessImpl(null,getServiceRegistry().getService(ClassLoaderService.class)),autoIndexMemberTypes);
  JandexIndexBuilder.process(jandexInitManager,this);
  return jandexInitManager.buildIndex();
}
"
"/** 
 * Read a mapping as an application resource using the convention that a class named  {@code foo.bar.Foo} ismapped by a file named  {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 * @param entityClass The mapped class. Cannot be {@code null} null.
 * @return this (for method chaining purposes)
 * @deprecated hbm.xml is a legacy mapping format now considered deprecated.
 */
@Deprecated public MetadataSources addClass(Class entityClass){
  if (entityClass == null) {
    throw new IllegalArgumentException(""The specified class cannot be null"");
  }
  LOG.debugf(""adding resource mappings from class convention : %s"",entityClass.getName());
  final String mappingResourceName=entityClass.getName().replace('.','/') + "".hbm.xml"";
  addResource(mappingResourceName);
  return this;
}
"
"/** 
 * @deprecated Use {@link #indexKnownClasses} instead
 */
@Deprecated public IndexView buildJandexView(){
  return buildJandexView(false);
}
"
"/** 
 * Create a Jandex IndexView from scratch given the sources information contained here.
 * @param autoIndexMemberTypes Should the types of class members automatically be added to the built index?
 * @return The built Jandex Index
 * @deprecated Use {@link #indexKnownClasses} instead
 */
@Deprecated public IndexView buildJandexView(boolean autoIndexMemberTypes){
  JandexInitManager jandexInitManager=new JandexInitManager(null,new ClassLoaderAccessImpl(null,getServiceRegistry().getService(ClassLoaderService.class)),autoIndexMemberTypes);
  JandexIndexBuilder.process(jandexInitManager,this);
  return jandexInitManager.buildIndex();
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated @SuppressWarnings({""UnnecessaryBoxing"",""unchecked""}) public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,Integer.valueOf(incrementSize));
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public EntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,persistenceContext);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public EntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,persistenceContext);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public EntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,persistenceContext);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Get the current naming strategy.
 * @return The current naming strategy.
 * @deprecated Use {@link #getNamingStrategyDelegator()} instead.
 */
@Deprecated public NamingStrategy getNamingStrategy();
"
"/** 
 * Set the current naming strategy. An instance of  {@link org.hibernate.cfg.naming.LegacyNamingStrategyDelegator}will be constructed with the specified naming strategy.
 * @param namingStrategy the {@link NamingStrategy} to set; must be non-null.
 * @deprecated Use {@link #setNamingStrategyDelegator(org.hibernate.cfg.naming.NamingStrategyDelegator)} instead.
 * @see org.hibernate.cfg.naming.LegacyNamingStrategyDelegator#LegacyNamingStrategyDelegator(NamingStrategy)
 */
@Deprecated public void setNamingStrategy(NamingStrategy namingStrategy);
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * Called when the user supplied no explicit name/identifier for the given database object.
 * @param strategy The naming strategy in effect
 * @return The implicit name* @deprecated Replaced by  {@link #determineImplicitName(org.hibernate.cfg.naming.NamingStrategyDelegator)}.
 */
@Deprecated public String determineImplicitName(NamingStrategy strategy);
"
"/** 
 * Called when the user has supplied an explicit name for the database object.
 * @param strategy The naming strategy in effect
 * @param name The {@link ObjectNameNormalizer#normalizeIdentifierQuoting normalized} explicit object name.
 * @return The strategy-handled name.
 * @deprecated Replaced by {@link #determineImplicitName(org.hibernate.cfg.naming.NamingStrategyDelegator)}.
 */
@Deprecated public String handleExplicitName(NamingStrategy strategy,String name);
"
"/** 
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Deprecated as this is badly named for its use.
 * @deprecated Use {@link #getExplicitTableName} instead
 */
@Deprecated public String getSecondaryTableName(){
  return explicitTableName;
}
"
"/** 
 * Deprecated as this is badly named for its use.
 * @deprecated Use {@link #setExplicitTableName} instead
 */
@Deprecated public void setSecondaryTableName(String explicitTableName){
  setExplicitTableName(explicitTableName);
}
"
"/** 
 * create a factory from a list of properties and HibernatePersistence.CLASS_NAMES -> Collection<String> (use to list the classes from config files HibernatePersistence.PACKAGE_NAMES -> Collection<String> (use to list the mappings from config files HibernatePersistence.HBXML_FILES -> Collection<InputStream> (input streams of hbm files) HibernatePersistence.LOADED_CLASSES -> Collection<Class> (list of loaded classes) <p/> <b>Used by JBoss AS only</b>
 * @deprecated use the Java Persistence API
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(Map workingVars){
  configure(workingVars);
  return buildEntityManagerFactory();
}
"
"/** 
 * Process configuration and build an EntityManagerFactory <b>when</b> the configuration is ready
 * @deprecated
 */
@Deprecated public EntityManagerFactory createEntityManagerFactory(){
  configure(cfg.getProperties(),new HashMap());
  return buildEntityManagerFactory();
}
"
"/** 
 * Get the current naming strategy.
 * @return The current naming strategy.
 * @deprecated Use {@link #getNamingStrategyDelegator()} instead.
 */
@Deprecated public NamingStrategy getNamingStrategy();
"
"/** 
 * Set the current naming strategy. An instance of  {@link org.hibernate.cfg.naming.LegacyNamingStrategyDelegator}will be constructed with the specified naming strategy.
 * @param namingStrategy the {@link NamingStrategy} to set; must be non-null.
 * @deprecated Use {@link #setNamingStrategyDelegator(org.hibernate.cfg.naming.NamingStrategyDelegator)} instead.
 * @see org.hibernate.cfg.naming.LegacyNamingStrategyDelegator#LegacyNamingStrategyDelegator(NamingStrategy)
 */
@Deprecated public void setNamingStrategy(NamingStrategy namingStrategy);
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjects} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects();
"
"/** 
 * @deprecated To fix misspelling; use {@link #iterateAuxiliaryDatabaseObjectsInReverse} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse();
"
"/** 
 * @deprecated Use {@link #getUniqueConstraintHoldersByTable} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Map<Table,List<String[]>> getTableUniqueConstraints();
"
"/** 
 * @deprecated Use {@link #addUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public void addUniqueConstraints(Table table,List uniqueConstraints);
"
"/** 
 * Called when the user supplied no explicit name/identifier for the given database object.
 * @param strategy The naming strategy in effect
 * @return The implicit name* @deprecated Replaced by  {@link #determineImplicitName(org.hibernate.cfg.naming.NamingStrategyDelegator)}.
 */
@Deprecated public String determineImplicitName(NamingStrategy strategy);
"
"/** 
 * Called when the user has supplied an explicit name for the database object.
 * @param strategy The naming strategy in effect
 * @param name The {@link ObjectNameNormalizer#normalizeIdentifierQuoting normalized} explicit object name.
 * @return The strategy-handled name.
 * @deprecated Replaced by {@link #determineImplicitName(org.hibernate.cfg.naming.NamingStrategyDelegator)}.
 */
@Deprecated public String handleExplicitName(NamingStrategy strategy,String name);
"
"/** 
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Deprecated as this is badly named for its use.
 * @deprecated Use {@link #getExplicitTableName} instead
 */
@Deprecated public String getSecondaryTableName(){
  return explicitTableName;
}
"
"/** 
 * Deprecated as this is badly named for its use.
 * @deprecated Use {@link #setExplicitTableName} instead
 */
@Deprecated public void setSecondaryTableName(String explicitTableName){
  setExplicitTableName(explicitTableName);
}
"
"/** 
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * @deprecated Use {@link #buildAndFillTable} instead.
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static Table fillTable(String schema,String catalog,String realTableName,String logicalName,boolean isAbstract,List uniqueConstraints,String constraints,Table denormalizedSuperTable,Mappings mappings){
  schema=BinderHelper.isEmptyAnnotationValue(schema) ? mappings.getSchemaName() : schema;
  catalog=BinderHelper.isEmptyAnnotationValue(catalog) ? mappings.getCatalogName() : catalog;
  Table table;
  if (denormalizedSuperTable != null) {
    table=mappings.addDenormalizedTable(schema,catalog,realTableName,isAbstract,null,denormalizedSuperTable);
  }
 else {
    table=mappings.addTable(schema,catalog,realTableName,null,isAbstract);
  }
  if (uniqueConstraints != null && uniqueConstraints.size() > 0) {
    mappings.addUniqueConstraints(table,uniqueConstraints);
  }
  if (constraints != null)   table.addCheckConstraint(constraints);
  if (logicalName != null) {
    mappings.addTableBinding(schema,catalog,logicalName,realTableName,denormalizedSuperTable);
  }
  return table;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * Is detection of Hibernate Mapping files allowed?
 * @return Whether detection of Mapping files is allowed.
 * @deprecated With move to unified schema, this setting is now deprecated and willbe removed once support for reading  {@code hbm.xml} files is fully removed.
 */
@Deprecated public boolean canDetectHibernateMappingFiles();
"
"/** 
 * Not used!
 * @param jarPath The jar path
 * @return The url from the path?
 * @deprecated Not used!
 */
@Deprecated @SuppressWarnings(""UnusedDeclaration"") public URL getURLFromPath(String jarPath);
"
"/** 
 * Close the provider.
 * @deprecated Use {@link #stop} instead
 */
@SuppressWarnings(""UnusedDeclaration"") @Deprecated public void close(){
  stop();
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(properties).build();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Close the provider.
 * @deprecated Use {@link #stop} instead
 */
@SuppressWarnings(""UnusedDeclaration"") @Deprecated public void close(){
  stop();
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)}instead.
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #SpecialOneToOneType(org.hibernate.type.TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)} instead.
 */
@Deprecated public SpecialOneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public boolean isXMLElement();
"
"/** 
 * A representation of the value to be embedded in an XML element.
 * @param node The XML node to which to write the value
 * @param value The value to write
 * @param factory The session factory
 * @throws HibernateException An error from Hibernate
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setToXMLNode(Node node,Object value,SessionFactoryImplementor factory) throws HibernateException ;
"
"/** 
 * Parse the XML representation of an instance.
 * @param xml The XML node from which to read the value
 * @param factory The session factory
 * @return an instance of the {@link #getReturnedClass() mapped class}
 * @throws HibernateException An error from Hibernate
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public Object fromXMLNode(Node xml,Mapping factory) throws HibernateException ;
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * Create a schema exporter for the given Configuration, with the given database connection properties.
 * @param configuration The configuration from which to build a schema export.
 * @param properties The properties from which to configure connectivity etc.
 * @throws HibernateException Indicates problem preparing for schema export.
 * @deprecated properties may be specified via the Configuration object
 */
@Deprecated public SchemaExport(Configuration configuration,Properties properties) throws HibernateException {
  final Dialect dialect=Dialect.getDialect(properties);
  Properties props=new Properties();
  props.putAll(dialect.getDefaultProperties());
  props.putAll(properties);
  this.connectionHelper=new ManagedProviderConnectionHelper(props);
  this.sqlStatementLogger=new SqlStatementLogger(false,true);
  this.formatter=FormatStyle.DDL.getFormatter();
  this.sqlExceptionHelper=new SqlExceptionHelper();
  this.importFiles=ConfigurationHelper.getString(AvailableSettings.HBM2DDL_IMPORT_FILES,properties,DEFAULT_IMPORT_FILE);
  this.dropSQL=configuration.generateDropSchemaScript(dialect);
  this.createSQL=configuration.generateSchemaCreationScript(dialect);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
@Deprecated public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return value;
  }
 else   if (clazz == Integer.class) {
    return (int)value;
  }
 else   if (clazz == Short.class) {
    return (short)value;
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
@Deprecated public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return value;
  }
 else   if (clazz == Integer.class) {
    return (int)value;
  }
 else   if (clazz == Short.class) {
    return (short)value;
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * Creates a DuplicateMappingException using the given type and name.
 * @param type The type of the duplicated thing.
 * @param name The name of the duplicated thing.
 * @deprecated Use the for taking {@link Type} instead.
 */
@Deprecated public DuplicateMappingException(String type,String name){
  this(""Duplicate "" + type + "" mapping ""+ name,type,name);
}
"
"/** 
 * Creates a DuplicateMappingException using the given customMessage, type and name.
 * @param customMessage A custom exception message explaining the exception condition
 * @param type The type of the duplicated thing.
 * @param name The name of the duplicated thing.
 * @deprecated Use the for taking {@link Type} instead.
 */
@Deprecated public DuplicateMappingException(String customMessage,String type,String name){
  super(customMessage);
  this.type=type;
  this.name=name;
}
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries() throws HibernateException ;
"
"/** 
 * Defines the Hibernate Commons Annotations ReflectionManager to use
 * @param reflectionManager The ReflectionManager to use.
 * @return {@code this}, for method chaining
 * @deprecated Deprecated (with no current replacement) to indicate that this willgo away as we migrate away from Hibernate Commons Annotations to Jandex for annotation handling and XMl->annotation merging.
 */
@Deprecated public MetadataBuilder with(ReflectionManager reflectionManager);
"
"/** 
 * Read a mapping as an application resource using the convention that a class named  {@code foo.bar.Foo} ismapped by a file named  {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 * @param entityClass The mapped class. Cannot be {@code null} null.
 * @return this (for method chaining purposes)
 * @deprecated hbm.xml is a legacy mapping format now considered deprecated.
 */
@Deprecated public MetadataSources addClass(Class entityClass){
  if (entityClass == null) {
    throw new IllegalArgumentException(""The specified class cannot be null"");
  }
  LOG.debugf(""adding resource mappings from class convention : %s"",entityClass.getName());
  final String mappingResourceName=entityClass.getName().replace('.','/') + "".hbm.xml"";
  addResource(mappingResourceName);
  return this;
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
  return this;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public void add(XmlDocument metadataXml){
}
"
"/** 
 * @deprecated No longer supported
 */
@Deprecated public Configuration addXML(String xml) throws MappingException {
  return this;
}
"
"/** 
 * Read mappings from a DOM <tt>Document</tt>
 * @param doc The DOM document
 * @return this (for method chaining purposes)
 * @throws MappingException Indicates problems reading the DOM or processingthe mapping document.
 * @deprecated Use addURL, addResource, addFile, etc. instead
 */
@Deprecated public Configuration addDocument(org.w3c.dom.Document doc) throws MappingException {
  metadataSources.addDocument(doc);
  return this;
}
"
"/** 
 * @deprecated This form (accepting a ClassLoader) is no longer supported.  Instead, add the ClassLoaderto the ClassLoaderService on the ServiceRegistry associated with this Configuration
 */
@Deprecated public Configuration addResource(String resourceName,ClassLoader classLoader) throws MappingException {
  return addResource(resourceName);
}
"
"/** 
 * @deprecated Does nothing
 */
@Deprecated public void buildMappings(){
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Temporarily exposed since Configuration is still around and much code still uses Configuration.  This allows code to configure the builder and access that to configure Configuration object (used from HEM atm).
 * @return The settings map.
 * @deprecated Temporarily exposed since Configuration is still around and much code still uses Configuration.This allows code to configure the builder and access that to configure Configuration object (used from HEM atm).
 */
@Deprecated public Map getSettings(){
  return settings;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
  return this;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public void add(XmlDocument metadataXml){
}
"
"/** 
 * @deprecated No longer supported
 */
@Deprecated public Configuration addXML(String xml) throws MappingException {
  return this;
}
"
"/** 
 * Read mappings from a DOM <tt>Document</tt>
 * @param doc The DOM document
 * @return this (for method chaining purposes)
 * @throws MappingException Indicates problems reading the DOM or processingthe mapping document.
 * @deprecated Use addURL, addResource, addFile, etc. instead
 */
@Deprecated public Configuration addDocument(org.w3c.dom.Document doc) throws MappingException {
  metadataSources.addDocument(doc);
  return this;
}
"
"/** 
 * @deprecated This form (accepting a ClassLoader) is no longer supported.  Instead, add the ClassLoaderto the ClassLoaderService on the ServiceRegistry associated with this Configuration
 */
@Deprecated public Configuration addResource(String resourceName,ClassLoader classLoader) throws MappingException {
  return addResource(resourceName);
}
"
"/** 
 * @deprecated Does nothing
 */
@Deprecated public void buildMappings(){
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
  return this;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public void add(XmlDocument metadataXml){
}
"
"/** 
 * @deprecated No longer supported
 */
@Deprecated public Configuration addXML(String xml) throws MappingException {
  return this;
}
"
"/** 
 * Read mappings from a DOM <tt>Document</tt>
 * @param doc The DOM document
 * @return this (for method chaining purposes)
 * @throws MappingException Indicates problems reading the DOM or processingthe mapping document.
 * @deprecated Use addURL, addResource, addFile, etc. instead
 */
@Deprecated public Configuration addDocument(org.w3c.dom.Document doc) throws MappingException {
  metadataSources.addDocument(doc);
  return this;
}
"
"/** 
 * @deprecated This form (accepting a ClassLoader) is no longer supported.  Instead, add the ClassLoaderto the ClassLoaderService on the ServiceRegistry associated with this Configuration
 */
@Deprecated public Configuration addResource(String resourceName,ClassLoader classLoader) throws MappingException {
  return addResource(resourceName);
}
"
"/** 
 * @deprecated Does nothing
 */
@Deprecated public void buildMappings(){
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Get the current lock mode
 * @return LockMode
 * @deprecated Instead use getLockOptions
 */
public LockMode getLockMode(){
  return lockOptions.getLockMode();
}
"
"/** 
 * Set the lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public Select setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Obtain service for providing JDBC connections.
 * @return The connection provider.
 * @deprecated See deprecation notice on {@link org.hibernate.engine.spi.SessionFactoryImplementor#getConnectionProvider()}for details
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * Get the connection provider
 * @deprecated Access to connections via {@link org.hibernate.engine.jdbc.connections.spi.JdbcConnectionAccess} shouldbe preferred over access via  {@link ConnectionProvider}, whenever possible. {@link org.hibernate.engine.jdbc.connections.spi.JdbcConnectionAccess} is tied to the Hibernate Session toproperly account for contextual information.  See  {@link SessionImplementor#getJdbcConnectionAccess()}
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retrieve the type for a given filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use {@link #getLoadQueryInfluencers} instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * The SQL required to create the underlying database objects.
 * @param dialect The dialect against which to generate the create command(s)
 * @return The create command(s)
 * @throws HibernateException problem creating the create command(s)
 * @deprecated Utilize the ExportableProducer contract instead
 */
@Deprecated public String[] sqlCreateStrings(Dialect dialect) throws HibernateException ;
"
"/** 
 * The SQL required to remove the underlying database objects.
 * @param dialect The dialect against which to generate the drop command(s)
 * @return The drop command(s)
 * @throws HibernateException problem creating the drop command(s)
 * @deprecated Utilize the ExportableProducer contract instead
 */
@Deprecated public String[] sqlDropStrings(Dialect dialect) throws HibernateException ;
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Inject the owner into constructor.
 * @param owner The owner
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * Which of the properties of this class are database generated values on insert?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions();
"
"/** 
 * Which of the properties of this class are database generated values on update?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions();
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(ServiceRegistry serviceRegistry,Configuration configuration){
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(Configuration configuration){
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(Configuration configuration,Connection connection) throws HibernateException {
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated Use {@link #setImplicitNamingStrategy} or {@link #setPhysicalNamingStrategy}instead
 */
@Deprecated public void setNamingStrategy(String namingStrategy){
  DeprecationLogger.DEPRECATION_LOGGER.logDeprecatedNamingStrategyAntArgument();
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)}instead.
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType customCollection(String typeName,Properties typeParameters,String role,String propertyRef,boolean embedded){
  Class typeClass;
  try {
    typeClass=ReflectHelper.classForName(typeName);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new MappingException(""user collection type class not found: "" + typeName,cnfe);
  }
  CustomCollectionType result=new CustomCollectionType(typeScope,typeClass,role,propertyRef,embedded);
  if (typeParameters != null) {
    injectParameters(result.getUserType(),typeParameters);
  }
  return result;
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #specialOneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType specialOneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return specialOneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #array(String,String,Class)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType array(String role,String propertyRef,boolean embedded,Class elementClass){
  return new ArrayType(typeScope,role,propertyRef,elementClass,embedded);
}
"
"/** 
 * @deprecated Use {@link #list(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType list(String role,String propertyRef,boolean embedded){
  return new ListType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #bag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType bag(String role,String propertyRef,boolean embedded){
  return new BagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #idbag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType idbag(String role,String propertyRef,boolean embedded){
  return new IdentifierBagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #map(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType map(String role,String propertyRef,boolean embedded){
  return new MapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedMap(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedMap(String role,String propertyRef,boolean embedded){
  return new OrderedMapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedMap(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedMap(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedMapType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @deprecated Use {@link #set(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType set(String role,String propertyRef,boolean embedded){
  return new SetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedSet(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedSet(String role,String propertyRef,boolean embedded){
  return new OrderedSetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedSet(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedSet(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedSetType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * Read a mapping as an application resource using the convention that a class named  {@code foo.bar.Foo} ismapped by a file named  {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 * @param entityClass The mapped class. Cannot be {@code null} null.
 * @return this (for method chaining purposes)
 * @deprecated hbm.xml is a legacy mapping format now considered deprecated.
 */
@Deprecated public MetadataSources addClass(Class entityClass){
  if (entityClass == null) {
    throw new IllegalArgumentException(""The specified class cannot be null"");
  }
  LOG.debugf(""adding resource mappings from class convention : %s"",entityClass.getName());
  final String mappingResourceName=entityClass.getName().replace('.','/') + "".hbm.xml"";
  addResource(mappingResourceName);
  return this;
}
"
"/** 
 * @deprecated Use {@link #applyIntegrator} instead
 */
@Deprecated public BootstrapServiceRegistryBuilder with(Integrator integrator){
  return applyIntegrator(integrator);
}
"
"/** 
 * @deprecated Use {@link #applyClassLoader} instead
 */
@Deprecated public BootstrapServiceRegistryBuilder with(ClassLoader classLoader){
  return applyClassLoader(classLoader);
}
"
"/** 
 * @deprecated Use {@link #applyClassLoaderService} instead
 */
@Deprecated public BootstrapServiceRegistryBuilder with(ClassLoaderService classLoaderService){
  return applyClassLoaderService(classLoaderService);
}
"
"/** 
 * @deprecated Use {@link #applyStrategySelector} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public <T>BootstrapServiceRegistryBuilder withStrategySelector(Class<T> strategy,String name,Class<? extends T> implementation){
  return applyStrategySelector(strategy,name,implementation);
}
"
"/** 
 * @deprecated Use {@link #applyStrategySelectors} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public BootstrapServiceRegistryBuilder withStrategySelectors(StrategyRegistrationProvider strategyRegistrationProvider){
  return applyStrategySelectors(strategyRegistrationProvider);
}
"
"/** 
 * Temporarily exposed since Configuration is still around and much code still uses Configuration.  This allows code to configure the builder and access that to configure Configuration object (used from HEM atm).
 * @return The settings map.
 * @deprecated Temporarily exposed since Configuration is still around and much code still uses Configuration.This allows code to configure the builder and access that to configure Configuration object.
 */
@Deprecated public Map getSettings(){
  return settings;
}
"
"/** 
 * Read a mapping as an application resource using the convention that a class named  {@code foo.bar.Foo} ismapped by a file named  {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 * @param entityClass The mapped class. Cannot be {@code null} null.
 * @return this (for method chaining purposes)
 * @deprecated hbm.xml is a legacy mapping format now considered deprecated.
 */
@Deprecated public MetadataSources addClass(Class entityClass){
  if (entityClass == null) {
    throw new IllegalArgumentException(""The specified class cannot be null"");
  }
  LOG.debugf(""adding resource mappings from class convention : %s"",entityClass.getName());
  final String mappingResourceName=entityClass.getName().replace('.','/') + "".hbm.xml"";
  addResource(mappingResourceName);
  return this;
}
"
"/** 
 * Read a mapping as an application resource using the convention that a class named  {@code foo.bar.Foo} ismapped by a file named  {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 * @param entityClass The mapped class. Cannot be {@code null} null.
 * @return this (for method chaining purposes)
 * @deprecated hbm.xml is a legacy mapping format now considered deprecated.
 */
@Deprecated public MetadataSources addClass(Class entityClass){
  if (entityClass == null) {
    throw new IllegalArgumentException(""The specified class cannot be null"");
  }
  LOG.debugf(""adding resource mappings from class convention : %s"",entityClass.getName());
  final String mappingResourceName=entityClass.getName().replace('.','/') + "".hbm.xml"";
  addResource(mappingResourceName);
  return this;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
  return this;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public void add(XmlDocument metadataXml){
}
"
"/** 
 * @deprecated No longer supported
 */
@Deprecated public Configuration addXML(String xml) throws MappingException {
  return this;
}
"
"/** 
 * Read mappings from a DOM <tt>Document</tt>
 * @param doc The DOM document
 * @return this (for method chaining purposes)
 * @throws MappingException Indicates problems reading the DOM or processingthe mapping document.
 * @deprecated Use addURL, addResource, addFile, etc. instead
 */
@Deprecated public Configuration addDocument(org.w3c.dom.Document doc) throws MappingException {
  metadataSources.addDocument(doc);
  return this;
}
"
"/** 
 * @deprecated This form (accepting a ClassLoader) is no longer supported.  Instead, add the ClassLoaderto the ClassLoaderService on the ServiceRegistry associated with this Configuration
 */
@Deprecated public Configuration addResource(String resourceName,ClassLoader classLoader) throws MappingException {
  return addResource(resourceName);
}
"
"/** 
 * @deprecated Does nothing
 */
@Deprecated public void buildMappings(){
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(ServiceRegistry serviceRegistry,Configuration configuration){
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(Configuration configuration){
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(Configuration configuration,Connection connection) throws HibernateException {
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated Use {@link #setImplicitNamingStrategy} or {@link #setPhysicalNamingStrategy}instead
 */
@Deprecated public void setNamingStrategy(String namingStrategy){
  DeprecationLogger.DEPRECATION_LOGGER.logDeprecatedNamingStrategyAntArgument();
}
"
"/** 
 * Get the current lock mode
 * @return LockMode
 * @deprecated Instead use getLockOptions
 */
public LockMode getLockMode(){
  return lockOptions.getLockMode();
}
"
"/** 
 * Set the lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
public Select setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated() public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public MutableEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,persistenceContext);
}
"
"/** 
 * Which of the properties of this class are database generated values on insert?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions();
"
"/** 
 * Which of the properties of this class are database generated values on update?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions();
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Temporarily exposed since Configuration is still around and much code still uses Configuration.  This allows code to configure the builder and access that to configure Configuration object (used from HEM atm).
 * @return The settings map.
 * @deprecated Temporarily exposed since Configuration is still around and much code still uses Configuration.This allows code to configure the builder and access that to configure Configuration object.
 */
@Deprecated public Map getSettings(){
  return settings;
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(ServiceRegistry serviceRegistry,Configuration configuration){
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(Configuration configuration){
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(Configuration configuration,Connection connection) throws HibernateException {
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * Cast <tt>candidate</tt> to the instance of <tt>expected</tt> type.
 * @param expected The type of instance expected to return.
 * @param candidate The candidate object to be casted.
 * @param < T > The java type of the expected return
 * @return The instance of expected type or null if this cast fail.
 * @deprecated No idea why this is exposed here...
 */
@Deprecated public <T>T cast(Class<T> expected,Object candidate);
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries() throws HibernateException ;
"
"/** 
 * Read a mapping as an application resource using the convention that a class named  {@code foo.bar.Foo} ismapped by a file named  {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 * @param entityClass The mapped class. Cannot be {@code null} null.
 * @return this (for method chaining purposes)
 * @deprecated hbm.xml is a legacy mapping format now considered deprecated.
 */
@Deprecated public MetadataSources addClass(Class entityClass){
  if (entityClass == null) {
    throw new IllegalArgumentException(""The specified class cannot be null"");
  }
  LOG.debugf(""adding resource mappings from class convention : %s"",entityClass.getName());
  final String mappingResourceName=entityClass.getName().replace('.','/') + "".hbm.xml"";
  addResource(mappingResourceName);
  return this;
}
"
"/** 
 * Checks to see if the given mode is the same as  {@link #MANUAL}.
 * @param mode The mode to check
 * @return true/false
 * @deprecated Just use equality check against {@link #MANUAL}.  Legacy from before this was an enum
 */
@Deprecated public static boolean isManualFlushMode(FlushMode mode){
  return MANUAL.level == mode.level;
}
"
"/** 
 * Applies the given entity mode as the default for the SessionFactory.
 * @param entityMode The default entity mode to use.
 * @return {@code this}, for method chaining
 * @see org.hibernate.cfg.AvailableSettings#DEFAULT_ENTITY_MODE
 * @deprecated Different entity modes per entity is soon to be removed as a feature.
 */
@Deprecated public SessionFactoryBuilder applyDefaultEntityMode(EntityMode entityMode);
"
"/** 
 * Should we track JTA transactions to attempt to detect timeouts?
 * @param enabled {@code true} indicates we should track by thread; {@code false} indicates not
 * @return {@code this}, for method chaining
 * @see org.hibernate.cfg.AvailableSettings#JTA_TRACK_BY_THREAD
 * @deprecated This should be replaced by new TransactionCoordinator work...
 */
@Deprecated public SessionFactoryBuilder applyJtaTrackingByThread(boolean enabled);
"
"/** 
 * Apply query substitutions to use in HQL queries.  Note, this is a legacy feature and almost always never needed anymore...
 * @param substitutions The substitution map
 * @return {@code this}, for method chaining
 * @see org.hibernate.cfg.AvailableSettings#QUERY_SUBSTITUTIONS
 * @deprecated This is a legacy feature and should never be needed anymore...
 */
@Deprecated public SessionFactoryBuilder applyQuerySubstitutions(Map substitutions);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
@Deprecated @Override public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.<String,SQLFunction>emptyMap()));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #translateOrderBy} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * Temporarily exposed since Configuration is still around and much code still uses Configuration.  This allows code to configure the builder and access that to configure Configuration object (used from HEM atm).
 * @return The settings map.
 * @deprecated Temporarily exposed since Configuration is still around and much code still uses Configuration.This allows code to configure the builder and access that to configure Configuration object.
 */
@Deprecated public Map getSettings(){
  return settings;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect) throws SQLException {
  this(connection,dialect,null,true);
}
"
"/** 
 * @deprecated Use {@link #DatabaseMetadata(Connection,Dialect,Configuration,boolean)} instead
 */
@Deprecated public DatabaseMetadata(Connection connection,Dialect dialect,boolean extras) throws SQLException {
  this(connection,dialect,null,extras);
}
"
"/** 
 * Checks to see if the given mode is the same as  {@link #MANUAL}.
 * @param mode The mode to check
 * @return true/false
 * @deprecated Just use equality check against {@link #MANUAL}.  Legacy from before this was an enum
 */
@Deprecated public static boolean isManualFlushMode(FlushMode mode){
  return MANUAL.level == mode.level;
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public AbstractEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,persistenceContext);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public ImmutableEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,persistenceContext);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public MutableEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,persistenceContext);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
@Deprecated @Override public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.<String,SQLFunction>emptyMap()));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #translateOrderBy} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * Applies the given entity mode as the default for the SessionFactory.
 * @param entityMode The default entity mode to use.
 * @return {@code this}, for method chaining
 * @see org.hibernate.cfg.AvailableSettings#DEFAULT_ENTITY_MODE
 * @deprecated Different entity modes per entity is soon to be removed as a feature.
 */
@Deprecated public SessionFactoryBuilder applyDefaultEntityMode(EntityMode entityMode);
"
"/** 
 * Should we track JTA transactions to attempt to detect timeouts?
 * @param enabled {@code true} indicates we should track by thread; {@code false} indicates not
 * @return {@code this}, for method chaining
 * @see org.hibernate.cfg.AvailableSettings#JTA_TRACK_BY_THREAD
 * @deprecated This should be replaced by new TransactionCoordinator work...
 */
@Deprecated public SessionFactoryBuilder applyJtaTrackingByThread(boolean enabled);
"
"/** 
 * Apply query substitutions to use in HQL queries.  Note, this is a legacy feature and almost always never needed anymore...
 * @param substitutions The substitution map
 * @return {@code this}, for method chaining
 * @see org.hibernate.cfg.AvailableSettings#QUERY_SUBSTITUTIONS
 * @deprecated This is a legacy feature and should never be needed anymore...
 */
@Deprecated public SessionFactoryBuilder applyQuerySubstitutions(Map substitutions);
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated See {@link #determineKeywordsForAutoQuoting} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated See {@link #determineKeywordsForAutoQuoting} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Get the connection provider
 * @deprecated Access to connections via {@link org.hibernate.engine.jdbc.connections.spi.JdbcConnectionAccess} shouldbe preferred over access via  {@link ConnectionProvider}, whenever possible. {@link org.hibernate.engine.jdbc.connections.spi.JdbcConnectionAccess} is tied to the Hibernate Session toproperly account for contextual information.  See  {@link SessionImplementor#getJdbcConnectionAccess()}
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * @deprecated Use {@link #getSessionFactoryOptions()} instead
 */
@Deprecated public Settings getSettings();
"
"/** 
 * Retreive the currently set value for a filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter parameter value.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Object getFilterParameterValue(String filterParameterName);
"
"/** 
 * Retrieve the type for a given filter parameter.
 * @param filterParameterName The filter parameter name in the format{FILTER_NAME.PARAMETER_NAME}.
 * @return The filter param type
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Type getFilterParameterType(String filterParameterName);
"
"/** 
 * Return the currently enabled filters.  The filter map is keyed by filter name, with values corresponding to the  {@link org.hibernate.internal.FilterImpl}instance.
 * @return The currently enabled filters.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public Map getEnabledFilters();
"
"/** 
 * Get the <i>internal</i> fetch profile currently associated with this session.
 * @return The current internal fetch profile, or null if none currently associated.
 * @deprecated use #getLoadQueryInfluencers instead
 */
@Deprecated public String getFetchProfile();
"
"/** 
 * Set the current <i>internal</i> fetch profile for this session.
 * @param name The internal fetch profile name to use
 * @deprecated use {@link #getLoadQueryInfluencers} instead
 */
@Deprecated public void setFetchProfile(String name);
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param persistentClass The entity class for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#containsEntity(Class,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evict(Class persistentClass,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level  cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param entityName The entity name for which to evict data.
 * @param id The entity id
 * @throws HibernateException Generally will mean that either that'persisttentClass' did not name a mapped entity or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictEntity(String entityName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict all entries from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role whose regions should be evicted
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName) throws HibernateException ;
"
"/** 
 * Evict an entry from the second-level cache. This method occurs outside of any transaction; it performs an immediate ""hard"" remove, so does not respect any transaction isolation semantics of the usage strategy. Use with care.
 * @param roleName The name of the collection role
 * @param id The id of the collection owner
 * @throws HibernateException Generally will mean that either that'roleName' did not name a mapped collection or a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictCollection(String roleName,Serializable id) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the named query cache region.
 * @param cacheRegion The named query cache region from which to evict.
 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,this should indicate a problem communicating with underlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries(String cacheRegion) throws HibernateException ;
"
"/** 
 * Evict any query result sets cached in the default query cache region.
 * @throws HibernateException Indicate a problem communicating withunderlying cache impl.
 * @deprecated Use {@link Cache#evictQueryRegions} accessed through{@link #getCache()} instead.
 */
@Deprecated public void evictQueries() throws HibernateException ;
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param theClass a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(Class theClass,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, obtaining the specified lock mode, assuming the instance exists.
 * @param entityName a persistent class
 * @param id a valid identifier of an existing persistent instance of the class
 * @param lockMode the lock level
 * @return the persistent instance or proxy
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object load(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.READ</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(object)
 */
@Deprecated public void lock(Object object,LockMode lockMode);
"
"/** 
 * Obtain the specified lock level upon the given object. This may be used to perform a version check (<tt>LockMode.OPTIMISTIC</tt>), to upgrade to a pessimistic lock (<tt>LockMode.PESSIMISTIC_WRITE</tt>), or to simply reassociate a transient instance with a session (<tt>LockMode.NONE</tt>). This operation cascades to associated instances if the association is mapped with <tt>cascade=""lock""</tt>.
 * @param entityName The name of the entity
 * @param object a persistent or transient instance
 * @param lockMode the lock level
 * @deprecated instead call buildLockRequest(LockMode).lock(entityName, object)
 */
@SuppressWarnings({""JavaDoc""}) @Deprecated public void lock(String entityName,Object object,LockMode lockMode);
"
"/** 
 * Re-read the state of the given instance from the underlying database, with the given <tt>LockMode</tt>. It is inadvisable to use this to implement long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
 * @param object a persistent or detached instance
 * @param lockMode the lock mode to use
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public void refresh(Object object,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param clazz a persistent class
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(Class clazz,Serializable id,LockMode lockMode);
"
"/** 
 * Return the persistent instance of the given entity class with the given identifier, or null if there is no such persistent instance. (If the instance is already associated with the session, return that instance. This method never returns an uninitialized instance.) Obtain the specified lock mode if the instance exists.
 * @param entityName the entity name
 * @param id an identifier
 * @param lockMode the lock mode
 * @return a persistent instance or null
 * @deprecated LockMode parameter should be replaced with LockOptions
 */
@Deprecated public Object get(String entityName,Serializable id,LockMode lockMode);
"
"/** 
 * Called when sql string is being prepared. 
 * @param sql sql to be prepared
 * @return original or modified sql
 * @deprecated Supply a {@link org.hibernate.resource.jdbc.spi.StatementInspector} instead, if you wishto inspect and alter SQL statements.
 */
@Deprecated public String onPrepareStatement(String sql);
"
"/** 
 * Should the session be automatically closed after transaction completion.
 * @param autoClose Should the session be automatically closed
 * @return {@code this}, for method chaining
 * @deprecated Only integrations can specify autoClosing behavior of individual sessions.  See{@link org.hibernate.engine.spi.SessionOwner}
 */
@Deprecated public SessionBuilder autoClose(boolean autoClose);
"
"/** 
 * Applies the given entity mode as the default for the SessionFactory.
 * @param entityMode The default entity mode to use.
 * @return {@code this}, for method chaining
 * @see org.hibernate.cfg.AvailableSettings#DEFAULT_ENTITY_MODE
 * @deprecated Different entity modes per entity is soon to be removed as a feature.
 */
@Deprecated public SessionFactoryBuilder applyDefaultEntityMode(EntityMode entityMode);
"
"/** 
 * Apply query substitutions to use in HQL queries.  Note, this is a legacy feature and almost always never needed anymore...
 * @param substitutions The substitution map
 * @return {@code this}, for method chaining
 * @see org.hibernate.cfg.AvailableSettings#QUERY_SUBSTITUTIONS
 * @deprecated This is a legacy feature and should never be needed anymore...
 */
@Deprecated public SessionFactoryBuilder applyQuerySubstitutions(Map substitutions);
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Returns the current JDBC connection associated with this instance.<br> <br> If the session is using aggressive connection release (as in a CMT environment), it is the application's responsibility to close the connection returned by this call. Otherwise, the application should not close the connection.
 * @deprecated just missed when deprecating same method from {@link Session}
 * @return The connection associated with this stateless session
 */
@Deprecated public Connection connection();
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
  return this;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public void add(XmlDocument metadataXml){
}
"
"/** 
 * @deprecated No longer supported
 */
@Deprecated public Configuration addXML(String xml) throws MappingException {
  return this;
}
"
"/** 
 * Read mappings from a DOM <tt>Document</tt>
 * @param doc The DOM document
 * @return this (for method chaining purposes)
 * @throws MappingException Indicates problems reading the DOM or processingthe mapping document.
 * @deprecated Use addURL, addResource, addFile, etc. instead
 */
@Deprecated public Configuration addDocument(org.w3c.dom.Document doc) throws MappingException {
  metadataSources.addDocument(doc);
  return this;
}
"
"/** 
 * @deprecated This form (accepting a ClassLoader) is no longer supported.  Instead, add the ClassLoaderto the ClassLoaderService on the ServiceRegistry associated with this Configuration
 */
@Deprecated public Configuration addResource(String resourceName,ClassLoader classLoader) throws MappingException {
  return addResource(resourceName);
}
"
"/** 
 * @deprecated Does nothing
 */
@Deprecated public void buildMappings(){
}
"
"/** 
 * Get the connection provider
 * @deprecated Access to connections via {@link org.hibernate.engine.jdbc.connections.spi.JdbcConnectionAccess} shouldbe preferred over access via  {@link ConnectionProvider}, whenever possible. {@link org.hibernate.engine.jdbc.connections.spi.JdbcConnectionAccess} is tied to the Hibernate Session toproperly account for contextual information.  See  {@link SessionImplementor#getJdbcConnectionAccess()}
 */
@Deprecated public ConnectionProvider getConnectionProvider();
"
"/** 
 * @deprecated Use {@link #getSessionFactoryOptions()} instead
 */
@Deprecated public Settings getSettings();
"
"/** 
 * Retrieves the SQLExceptionConverter in effect for this SessionFactory.
 * @return The SQLExceptionConverter for this SessionFactory.
 * @deprecated since 5.0; use {@link JdbcServices#getSqlExceptionHelper()} ->{@link SqlExceptionHelper#getSqlExceptionConverter()} instead as obtained from {@link #getServiceRegistry()}
 */
@Deprecated public SQLExceptionConverter getSQLExceptionConverter();
"
"/** 
 * Retrieves the SqlExceptionHelper in effect for this SessionFactory.
 * @return The SqlExceptionHelper for this SessionFactory.
 * @deprecated since 5.0; use {@link JdbcServices#getSqlExceptionHelper()} instead asobtained from  {@link #getServiceRegistry()}
 */
@Deprecated public SqlExceptionHelper getSQLExceptionHelper();
"
"/** 
 * @deprecated since 5.0; use {@link #getSessionFactoryOptions()} instead
 */
@Deprecated public Settings getSettings();
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated See {@link #determineKeywordsForAutoQuoting} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Read a mapping as an application resource using the convention that a class named  {@code foo.bar.Foo} ismapped by a file named  {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 * @param entityClass The mapped class. Cannot be {@code null} null.
 * @return this (for method chaining purposes)
 * @deprecated hbm.xml is a legacy mapping format now considered deprecated.
 */
@Deprecated public MetadataSources addClass(Class entityClass){
  if (entityClass == null) {
    throw new IllegalArgumentException(""The specified class cannot be null"");
  }
  LOG.debugf(""adding resource mappings from class convention : %s"",entityClass.getName());
  final String mappingResourceName=entityClass.getName().replace('.','/') + "".hbm.xml"";
  addResource(mappingResourceName);
  return this;
}
"
"/** 
 * Read mappings from a DOM  {@link org.w3c.dom.Document}
 * @param document The DOM document
 * @return this (for method chaining purposes)
 * @deprecated since 5.0.  Use one of the other methods for passing mapping source(s).
 */
@Deprecated public MetadataSources addDocument(Document document){
  final Origin origin=new Origin(SourceType.DOM,Origin.UNKNOWN_FILE_PATH);
  xmlBindings.add(new JaxpSourceXmlSource(origin,new DOMSource(document)).doBind(mappingsBinder));
  return this;
}
"
"/** 
 * @deprecated prefer {@link #getOptimisticLockStyle}
 */
@Deprecated public int getOptimisticLockMode(){
  return getOptimisticLockStyle().getOldCode();
}
"
"/** 
 * @deprecated prefer {@link #setOptimisticLockStyle}
 */
@Deprecated public void setOptimisticLockMode(int optimisticLockMode){
  setOptimisticLockStyle(OptimisticLockStyle.interpretOldCode(optimisticLockMode));
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
@Deprecated public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return value;
  }
 else   if (clazz == Integer.class) {
    return (int)value;
  }
 else   if (clazz == Short.class) {
    return (short)value;
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * Which of the properties of this class are database generated values on insert?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions();
"
"/** 
 * Which of the properties of this class are database generated values on update?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions();
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Get the current lock mode
 * @return LockMode
 * @deprecated Instead use getLockOptions
 */
@Deprecated public LockMode getLockMode(){
  return lockOptions.getLockMode();
}
"
"/** 
 * Set the lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
@Deprecated public Select setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * @deprecated DOM4j entity mode is no longer supported
 */
@Deprecated public String getNode();
"
"/** 
 * @deprecated See mainly {@link #buildEntityBasedAttribute}
 */
@Deprecated public static StandardProperty buildStandardProperty(Property property,boolean lazyAvailable){
  final Type type=property.getValue().getType();
  boolean alwaysDirtyCheck=type.isAssociationType() && ((AssociationType)type).isAlwaysDirtyChecked();
  return new StandardProperty(property.getName(),type,lazyAvailable && property.isLazy(),property.isInsertable(),property.isUpdateable(),property.getValueGenerationStrategy(),property.isOptional(),alwaysDirtyCheck || property.isUpdateable(),property.isOptimisticLocked(),property.getCascadeStyle(),property.getValue().getFetchMode());
}
"
"/** 
 * @deprecated Use {@link #ArrayType(TypeFactory.TypeScope,String,String,Class)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ArrayType(TypeFactory.TypeScope typeScope,String role,String propertyRef,Class elementClass,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
  this.elementClass=elementClass;
  arrayClass=Array.newInstance(elementClass,0).getClass();
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * @deprecated Use {@link #ListType(org.hibernate.type.TypeFactory.TypeScope,String,String)}See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public ListType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * @deprecated Use {@link #MapType(TypeFactory.TypeScope,String,String) } instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public MapType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * @deprecated Use {@link #SpecialOneToOneType(org.hibernate.type.TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)} instead.
 */
@Deprecated public SpecialOneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
@Deprecated public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated() public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @param owner The owner
 * @deprecated Inject the owner into constructor.
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * Which of the properties of this class are database generated values on insert?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions();
"
"/** 
 * Which of the properties of this class are database generated values on update?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions();
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated prefer {@link #getOptimisticLockStyle}
 */
@Deprecated public int getOptimisticLockMode(){
  return getOptimisticLockStyle().getOldCode();
}
"
"/** 
 * @deprecated prefer {@link #setOptimisticLockStyle}
 */
@Deprecated public void setOptimisticLockMode(int optimisticLockMode){
  setOptimisticLockStyle(OptimisticLockStyle.interpretOldCode(optimisticLockMode));
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.<String,SQLFunction>emptyMap()));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #translateOrderBy} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(ServiceRegistry serviceRegistry,Configuration configuration){
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(Configuration configuration){
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(Configuration configuration,Connection connection) throws HibernateException {
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated Use {@link #setImplicitNamingStrategy} or {@link #setPhysicalNamingStrategy}instead
 */
@Deprecated public void setNamingStrategy(String namingStrategy){
  DeprecationLogger.DEPRECATION_LOGGER.logDeprecatedNamingStrategyAntArgument();
}
"
"/** 
 * @deprecated DOM4j entity mode is no longer supported
 */
@Deprecated public String getNode();
"
"/** 
 * @deprecated See mainly {@link #buildEntityBasedAttribute}
 */
@Deprecated public static StandardProperty buildStandardProperty(Property property,boolean lazyAvailable){
  final Type type=property.getValue().getType();
  boolean alwaysDirtyCheck=type.isAssociationType() && ((AssociationType)type).isAlwaysDirtyChecked();
  return new StandardProperty(property.getName(),type,lazyAvailable && property.isLazy(),property.isInsertable(),property.isUpdateable(),property.getValueGenerationStrategy(),property.isOptional(),alwaysDirtyCheck || property.isUpdateable(),property.isOptimisticLocked(),property.getCascadeStyle(),property.getValue().getFetchMode());
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * @deprecated Use {@link #SetType(org.hibernate.type.TypeFactory.TypeScope,String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public SetType(TypeFactory.TypeScope typeScope,String role,String propertyRef,boolean isEmbeddedInXML){
  super(typeScope,role,propertyRef,isEmbeddedInXML);
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType customCollection(String typeName,Properties typeParameters,String role,String propertyRef,boolean embedded){
  Class typeClass;
  try {
    typeClass=ReflectHelper.classForName(typeName);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new MappingException(""user collection type class not found: "" + typeName,cnfe);
  }
  CustomCollectionType result=new CustomCollectionType(typeScope,typeClass,role,propertyRef,embedded);
  if (typeParameters != null) {
    injectParameters(result.getUserType(),typeParameters);
  }
  return result;
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #array(String,String,Class)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType array(String role,String propertyRef,boolean embedded,Class elementClass){
  return new ArrayType(typeScope,role,propertyRef,elementClass,embedded);
}
"
"/** 
 * @deprecated Use {@link #list(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType list(String role,String propertyRef,boolean embedded){
  return new ListType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #bag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType bag(String role,String propertyRef,boolean embedded){
  return new BagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #idbag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType idbag(String role,String propertyRef,boolean embedded){
  return new IdentifierBagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #map(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType map(String role,String propertyRef,boolean embedded){
  return new MapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedMap(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedMap(String role,String propertyRef,boolean embedded){
  return new OrderedMapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedMap(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedMap(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedMapType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @deprecated Use {@link #set(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType set(String role,String propertyRef,boolean embedded){
  return new SetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedSet(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedSet(String role,String propertyRef,boolean embedded){
  return new OrderedSetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedSet(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedSet(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedSetType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * Which of the properties of this class are database generated values on insert?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions();
"
"/** 
 * Which of the properties of this class are database generated values on update?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions();
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(Iterator,Set,SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,Collections.<MappedSuperclass>emptySet(),sessionFactory,false);
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * @deprecated prefer {@link #getOptimisticLockStyle}
 */
@Deprecated public int getOptimisticLockMode(){
  return getOptimisticLockStyle().getOldCode();
}
"
"/** 
 * @deprecated prefer {@link #setOptimisticLockStyle}
 */
@Deprecated public void setOptimisticLockMode(int optimisticLockMode){
  setOptimisticLockStyle(OptimisticLockStyle.interpretOldCode(optimisticLockMode));
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * Read a mapping as an application resource using the convention that a class named  {@code foo.bar.Foo} ismapped by a file named  {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 * @param entityClass The mapped class. Cannot be {@code null} null.
 * @return this (for method chaining purposes)
 * @deprecated hbm.xml is a legacy mapping format now considered deprecated.
 */
@Deprecated public MetadataSources addClass(Class entityClass){
  if (entityClass == null) {
    throw new IllegalArgumentException(""The specified class cannot be null"");
  }
  LOG.debugf(""adding resource mappings from class convention : %s"",entityClass.getName());
  final String mappingResourceName=entityClass.getName().replace('.','/') + "".hbm.xml"";
  addResource(mappingResourceName);
  return this;
}
"
"/** 
 * Read mappings from a DOM  {@link org.w3c.dom.Document}
 * @param document The DOM document
 * @return this (for method chaining purposes)
 * @deprecated since 5.0.  Use one of the other methods for passing mapping source(s).
 */
@Deprecated public MetadataSources addDocument(Document document){
  final Origin origin=new Origin(SourceType.DOM,Origin.UNKNOWN_FILE_PATH);
  xmlBindings.add(new JaxpSourceXmlSource(origin,new DOMSource(document)).doBind(mappingsBinder));
  return this;
}
"
"/** 
 * Temporarily exposed since Configuration is still around and much code still uses Configuration.  This allows code to configure the builder and access that to configure Configuration object (used from HEM atm).
 * @return The settings map.
 * @deprecated Temporarily exposed since Configuration is still around and much code still uses Configuration.This allows code to configure the builder and access that to configure Configuration object.
 */
@Deprecated public Map getSettings(){
  return settings;
}
"
"/** 
 * @deprecated Use {@link #CollectionType(TypeFactory.TypeScope,String,String)} insteadSee Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType(TypeFactory.TypeScope typeScope,String role,String foreignKeyPropertyName,boolean isEmbeddedInXML){
  this.typeScope=typeScope;
  this.role=role;
  this.foreignKeyPropertyName=foreignKeyPropertyName;
  this.isEmbeddedInXML=isEmbeddedInXML;
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * @deprecated (tell clover to ignore this method)
 */
@Deprecated @Override public Type getDataType(){
  throw new UnsupportedOperationException(""getDataType() is not supported by ConstructorNode!"");
}
"
"/** 
 * Perform resolution of a class name. <p/> Same as  {@link #classForName(String,Class)} except that here we delegate to{@link Class#forName(String)} if the context classloader lookup is unsuccessful.
 * @param name The class name
 * @return The class reference.
 * @throws ClassNotFoundException From {@link Class#forName(String)}.
 * @deprecated Depending on context, either {@link org.hibernate.boot.registry.classloading.spi.ClassLoaderService}or  {@link org.hibernate.boot.spi.ClassLoaderAccess} should be preferred
 */
@Deprecated public static Class classForName(String name) throws ClassNotFoundException {
  try {
    ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
    if (classLoader != null) {
      return classLoader.loadClass(name);
    }
  }
 catch (  Throwable ignore) {
  }
  return Class.forName(name);
}
"
"/** 
 * @param owner The owner
 * @deprecated Inject the owner into constructor.
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated prefer {@link #getOptimisticLockStyle}
 */
@Deprecated public int getOptimisticLockMode(){
  return getOptimisticLockStyle().getOldCode();
}
"
"/** 
 * @deprecated prefer {@link #setOptimisticLockStyle}
 */
@Deprecated public void setOptimisticLockMode(int optimisticLockMode){
  setOptimisticLockStyle(OptimisticLockStyle.interpretOldCode(optimisticLockMode));
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public boolean isEmbedded(){
  return embedded;
}
"
"/** 
 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public void setEmbedded(boolean embedded){
  this.embedded=embedded;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(ServiceRegistry serviceRegistry,Configuration configuration){
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(Configuration configuration){
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(Configuration configuration,Connection connection) throws HibernateException {
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated See mainly {@link #buildEntityBasedAttribute}
 */
@Deprecated public static StandardProperty buildStandardProperty(Property property,boolean lazyAvailable){
  final Type type=property.getValue().getType();
  boolean alwaysDirtyCheck=type.isAssociationType() && ((AssociationType)type).isAlwaysDirtyChecked();
  return new StandardProperty(property.getName(),type,lazyAvailable && property.isLazy(),property.isInsertable(),property.isUpdateable(),property.getValueGenerationStrategy(),property.isOptional(),alwaysDirtyCheck || property.isUpdateable(),property.isOptimisticLocked(),property.getCascadeStyle(),property.getValue().getFetchMode());
}
"
"/** 
 * Read a mapping as an application resource using the convention that a class named  {@code foo.bar.Foo} ismapped by a file named  {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 * @param entityClass The mapped class. Cannot be {@code null} null.
 * @return this (for method chaining purposes)
 * @deprecated hbm.xml is a legacy mapping format now considered deprecated.
 */
@Deprecated public MetadataSources addClass(Class entityClass){
  if (entityClass == null) {
    throw new IllegalArgumentException(""The specified class cannot be null"");
  }
  LOG.debugf(""adding resource mappings from class convention : %s"",entityClass.getName());
  final String mappingResourceName=entityClass.getName().replace('.','/') + "".hbm.xml"";
  addResource(mappingResourceName);
  return this;
}
"
"/** 
 * Read mappings from a DOM  {@link org.w3c.dom.Document}
 * @param document The DOM document
 * @return this (for method chaining purposes)
 * @deprecated since 5.0.  Use one of the other methods for passing mapping source(s).
 */
@Deprecated public MetadataSources addDocument(Document document){
  final Origin origin=new Origin(SourceType.DOM,Origin.UNKNOWN_FILE_PATH);
  xmlBindings.add(new JaxpSourceXmlSource(origin,new DOMSource(document)).doBind(getXmlMappingBinderAccess().getMappingBinder()));
  return this;
}
"
"/** 
 * Release all resources held by this provider.
 * @throws HibernateException Indicates a problem closing the underlying pool or releasing resources
 * @deprecated Use {@link #stop} instead
 */
@Deprecated public void close() throws HibernateException {
  stop();
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public AbstractEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,persistenceContext);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public ImmutableEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,persistenceContext);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public MutableEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,persistenceContext);
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated() public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated() public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated() public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * Read a mapping as an application resource using the convention that a class named  {@code foo.bar.Foo} ismapped by a file named  {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 * @param entityClass The mapped class. Cannot be {@code null} null.
 * @return this (for method chaining purposes)
 * @deprecated hbm.xml is a legacy mapping format now considered deprecated.
 */
@Deprecated public MetadataSources addClass(Class entityClass){
  if (entityClass == null) {
    throw new IllegalArgumentException(""The specified class cannot be null"");
  }
  LOG.debugf(""adding resource mappings from class convention : %s"",entityClass.getName());
  final String mappingResourceName=entityClass.getName().replace('.','/') + "".hbm.xml"";
  addResource(mappingResourceName);
  return this;
}
"
"/** 
 * Read mappings from a DOM  {@link org.w3c.dom.Document}
 * @param document The DOM document
 * @return this (for method chaining purposes)
 * @deprecated since 5.0.  Use one of the other methods for passing mapping source(s).
 */
@Deprecated public MetadataSources addDocument(Document document){
  final Origin origin=new Origin(SourceType.DOM,Origin.UNKNOWN_FILE_PATH);
  xmlBindings.add(new JaxpSourceXmlSource(origin,new DOMSource(document)).doBind(getXmlMappingBinderAccess().getMappingBinder()));
  return this;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(ServiceRegistry serviceRegistry,Configuration configuration){
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(Configuration configuration){
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(Configuration configuration,Connection connection) throws HibernateException {
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated() public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public AbstractEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,persistenceContext);
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Close the provider.
 * @deprecated Use {@link #stop} instead
 */
@SuppressWarnings(""UnusedDeclaration"") @Deprecated public void close(){
  stop();
}
"
"/** 
 * @deprecated Use {@link ConnectionProviderInitiator#toIsolationNiceName} instead
 */
@Deprecated public static String isolationLevelToString(int isolation){
  return ConnectionProviderInitiator.toIsolationNiceName(isolation);
}
"
"/** 
 * Release all resources held by this provider.
 * @throws HibernateException Indicates a problem closing the underlying pool or releasing resources
 * @deprecated Use {@link #stop} instead
 */
@Deprecated public void close() throws HibernateException {
  stop();
}
"
"/** 
 * @deprecated See mainly {@link #buildEntityBasedAttribute}
 */
@Deprecated public static StandardProperty buildStandardProperty(Property property,boolean lazyAvailable){
  final Type type=property.getValue().getType();
  boolean alwaysDirtyCheck=type.isAssociationType() && ((AssociationType)type).isAlwaysDirtyChecked();
  return new StandardProperty(property.getName(),type,lazyAvailable && property.isLazy(),property.isInsertable(),property.isUpdateable(),property.getValueGenerationStrategy(),property.isOptional(),alwaysDirtyCheck || property.isUpdateable(),property.isOptimisticLocked(),property.getCascadeStyle(),property.getValue().getFetchMode());
}
"
"/** 
 * Compare 2 arrays only at the first level
 * @deprecated Use {@link java.util.Arrays#equals(Object[],Object[])} instead
 */
@Deprecated public static boolean isEquals(Object[] o1,Object[] o2){
  if (o1 == o2) {
    return true;
  }
  if (o1 == null || o2 == null) {
    return false;
  }
  int length=o1.length;
  if (length != o2.length) {
    return false;
  }
  for (int index=0; index < length; index++) {
    if (!o1[index].equals(o2[index])) {
      return false;
    }
  }
  return true;
}
"
"/** 
 * Compare 2 arrays only at the first level
 * @deprecated Use {@link java.util.Arrays#equals(char[],char[])} instead
 */
@Deprecated public static boolean isEquals(char[] o1,char[] o2){
  if (o1 == o2) {
    return true;
  }
  if (o1 == null || o2 == null) {
    return false;
  }
  int length=o1.length;
  if (length != o2.length) {
    return false;
  }
  for (int index=0; index < length; index++) {
    if (!(o1[index] == o2[index])) {
      return false;
    }
  }
  return true;
}
"
"/** 
 * Compare 2 arrays only at the first level
 * @deprecated Use {@link java.util.Arrays#equals(byte[],byte[])} instead
 */
@Deprecated public static boolean isEquals(byte[] b1,byte[] b2){
  if (b1 == b2) {
    return true;
  }
  if (b1 == null || b2 == null) {
    return false;
  }
  int length=b1.length;
  if (length != b2.length) {
    return false;
  }
  for (int index=0; index < length; index++) {
    if (!(b1[index] == b2[index])) {
      return false;
    }
  }
  return true;
}
"
"/** 
 * Compare 2 arrays only at the first level
 * @deprecated Use {@link java.util.Arrays#equals(Object[],Object[])} instead
 */
@Deprecated public static boolean isEquals(Object[] o1,Object[] o2){
  if (o1 == o2) {
    return true;
  }
  if (o1 == null || o2 == null) {
    return false;
  }
  int length=o1.length;
  if (length != o2.length) {
    return false;
  }
  for (int index=0; index < length; index++) {
    if (!o1[index].equals(o2[index])) {
      return false;
    }
  }
  return true;
}
"
"/** 
 * Compare 2 arrays only at the first level
 * @deprecated Use {@link java.util.Arrays#equals(char[],char[])} instead
 */
@Deprecated public static boolean isEquals(char[] o1,char[] o2){
  if (o1 == o2) {
    return true;
  }
  if (o1 == null || o2 == null) {
    return false;
  }
  int length=o1.length;
  if (length != o2.length) {
    return false;
  }
  for (int index=0; index < length; index++) {
    if (!(o1[index] == o2[index])) {
      return false;
    }
  }
  return true;
}
"
"/** 
 * Compare 2 arrays only at the first level
 * @deprecated Use {@link java.util.Arrays#equals(byte[],byte[])} instead
 */
@Deprecated public static boolean isEquals(byte[] b1,byte[] b2){
  if (b1 == b2) {
    return true;
  }
  if (b1 == null || b2 == null) {
    return false;
  }
  int length=b1.length;
  if (length != b2.length) {
    return false;
  }
  for (int index=0; index < length; index++) {
    if (!(b1[index] == b2[index])) {
      return false;
    }
  }
  return true;
}
"
"/** 
 * @param owner The owner
 * @deprecated Inject the owner into constructor.
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @param owner The owner
 * @deprecated Inject the owner into constructor.
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)}instead.
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #SpecialOneToOneType(org.hibernate.type.TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)} instead.
 */
@Deprecated public SpecialOneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)}instead.
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #SpecialOneToOneType(org.hibernate.type.TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)} instead.
 */
@Deprecated public SpecialOneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @param owner The owner
 * @deprecated Inject the owner into constructor.
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated prefer {@link #getOptimisticLockStyle}
 */
@Deprecated public int getOptimisticLockMode(){
  return getOptimisticLockStyle().getOldCode();
}
"
"/** 
 * @deprecated prefer {@link #setOptimisticLockStyle}
 */
@Deprecated public void setOptimisticLockMode(int optimisticLockMode){
  setOptimisticLockStyle(OptimisticLockStyle.interpretOldCode(optimisticLockMode));
}
"
"/** 
 * @param owner The owner
 * @deprecated Inject the owner into constructor.
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated prefer {@link #getOptimisticLockStyle}
 */
@Deprecated public int getOptimisticLockMode(){
  return getOptimisticLockStyle().getOldCode();
}
"
"/** 
 * @deprecated prefer {@link #setOptimisticLockStyle}
 */
@Deprecated public void setOptimisticLockMode(int optimisticLockMode){
  setOptimisticLockStyle(OptimisticLockStyle.interpretOldCode(optimisticLockMode));
}
"
"/** 
 * @deprecated See mainly {@link #buildEntityBasedAttribute}
 */
@Deprecated public static StandardProperty buildStandardProperty(Property property,boolean lazyAvailable){
  final Type type=property.getValue().getType();
  boolean alwaysDirtyCheck=type.isAssociationType() && ((AssociationType)type).isAlwaysDirtyChecked();
  return new StandardProperty(property.getName(),type,lazyAvailable && property.isLazy(),property.isInsertable(),property.isUpdateable(),property.getValueGenerationStrategy(),property.isOptional(),alwaysDirtyCheck || property.isUpdateable(),property.isOptimisticLocked(),property.getCascadeStyle(),property.getValue().getFetchMode());
}
"
"/** 
 * @deprecated See mainly {@link #buildEntityBasedAttribute}
 */
@Deprecated public static StandardProperty buildStandardProperty(Property property,boolean lazyAvailable){
  final Type type=property.getValue().getType();
  boolean alwaysDirtyCheck=type.isAssociationType() && ((AssociationType)type).isAlwaysDirtyChecked();
  return new StandardProperty(property.getName(),type,lazyAvailable && property.isLazy(),property.isInsertable(),property.isUpdateable(),property.getValueGenerationStrategy(),property.isOptional(),alwaysDirtyCheck || property.isUpdateable(),property.isOptimisticLocked(),property.getCascadeStyle(),property.getValue().getFetchMode());
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated() public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated() public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated() public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated() public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * Does this dialect support identity column key generation?
 * @return True if IDENTITY columns are supported; false otherwise.
 * @deprecated use {@link IdentityColumnSupport} method instead
 */
@Deprecated public boolean supportsIdentityColumns(){
  return getIdentityColumnSupport().supportsIdentityColumns();
}
"
"/** 
 * Does the dialect support some form of inserting and selecting the generated IDENTITY value all in the same statement.
 * @return True if the dialect supports selecting the justgenerated IDENTITY in the insert statement.
 * @deprecated use {@link IdentityColumnSupport} method instead
 */
@Deprecated public boolean supportsInsertSelectIdentity(){
  return getIdentityColumnSupport().supportsInsertSelectIdentity();
}
"
"/** 
 * Whether this dialect have an Identity clause added to the data type or a completely separate identity data type
 * @return boolean
 * @deprecated use {@link IdentityColumnSupport} method instead
 */
@Deprecated public boolean hasDataTypeInIdentityColumn(){
  return getIdentityColumnSupport().hasDataTypeInIdentityColumn();
}
"
"/** 
 * Provided we  {@link #supportsInsertSelectIdentity}, then attach the ""select identity"" clause to the  insert statement. <p/> Note, if  {@link #supportsInsertSelectIdentity} == false thenthe insert-string should be returned without modification.
 * @param insertString The insert command
 * @return The insert command with any necessary identity selectclause attached.
 * @deprecated use {@link IdentityColumnSupport} method instead
 */
@Deprecated public String appendIdentitySelectToInsert(String insertString){
  return getIdentityColumnSupport().appendIdentitySelectToInsert(insertString);
}
"
"/** 
 * Get the select command to use to retrieve the last generated IDENTITY value for a particular table
 * @param table The table into which the insert was done
 * @param column The PK column.
 * @param type The {@link java.sql.Types} type code.
 * @return The appropriate select command
 * @throws MappingException If IDENTITY generation is not supported.
 * @deprecated use {@link IdentityColumnSupport} method instead
 */
@Deprecated public String getIdentitySelectString(String table,String column,int type) throws MappingException {
  return getIdentityColumnSupport().getIdentitySelectString(table,column,type);
}
"
"/** 
 * The syntax used during DDL to define a column as being an IDENTITY of a particular type.
 * @param type The {@link java.sql.Types} type code.
 * @return The appropriate DDL fragment.
 * @throws MappingException If IDENTITY generation is not supported.
 * @deprecated use {@link IdentityColumnSupport} method instead
 */
@Deprecated public String getIdentityColumnString(int type) throws MappingException {
  return getIdentityColumnSupport().getIdentityColumnString(type);
}
"
"/** 
 * The keyword used to insert a generated value into an identity column (or null). Need if the dialect does not support inserts that specify no column values.
 * @return The appropriate keyword.
 * @deprecated use {@link IdentityColumnSupport} method instead
 */
@Deprecated public String getIdentityInsertString(){
  return getIdentityColumnSupport().getIdentityInsertString();
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)}instead.
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public String getQualifiedName(Dialect dialect,String defaultCatalog,String defaultSchema){
  if (subselect != null) {
    return ""( "" + subselect + "" )"";
  }
  String quotedName=getQuotedName(dialect);
  String usedSchema=schema == null ? defaultSchema : getQuotedSchema(dialect);
  String usedCatalog=catalog == null ? defaultCatalog : getQuotedCatalog(dialect);
  return qualify(usedCatalog,usedSchema,quotedName);
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public static String qualify(String catalog,String schema,String table){
  StringBuilder qualifiedName=new StringBuilder();
  if (catalog != null) {
    qualifiedName.append(catalog).append('.');
  }
  if (schema != null) {
    qualifiedName.append(schema).append('.');
  }
  return qualifiedName.append(table).toString();
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public String getQualifiedName(Dialect dialect,String defaultCatalog,String defaultSchema){
  if (subselect != null) {
    return ""( "" + subselect + "" )"";
  }
  String quotedName=getQuotedName(dialect);
  String usedSchema=schema == null ? defaultSchema : getQuotedSchema(dialect);
  String usedCatalog=catalog == null ? defaultCatalog : getQuotedCatalog(dialect);
  return qualify(usedCatalog,usedSchema,quotedName);
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public static String qualify(String catalog,String schema,String table){
  StringBuilder qualifiedName=new StringBuilder();
  if (catalog != null) {
    qualifiedName.append(catalog).append('.');
  }
  if (schema != null) {
    qualifiedName.append(schema).append('.');
  }
  return qualifiedName.append(table).toString();
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)}instead.
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.<String,SQLFunction>emptyMap()));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #translateOrderBy} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.<String,SQLFunction>emptyMap()));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #translateOrderBy} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.<String,SQLFunction>emptyMap()));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #translateOrderBy} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.<String,SQLFunction>emptyMap()));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #translateOrderBy} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * Perform resolution of a class name. <p/> Same as  {@link #classForName(String,Class)} except that here we delegate to{@link Class#forName(String)} if the context classloader lookup is unsuccessful.
 * @param name The class name
 * @return The class reference.
 * @throws ClassNotFoundException From {@link Class#forName(String)}.
 * @deprecated Depending on context, either {@link org.hibernate.boot.registry.classloading.spi.ClassLoaderService}or  {@link org.hibernate.boot.spi.ClassLoaderAccess} should be preferred
 */
@Deprecated public static Class classForName(String name) throws ClassNotFoundException {
  try {
    ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
    if (classLoader != null) {
      return classLoader.loadClass(name);
    }
  }
 catch (  Throwable ignore) {
  }
  return Class.forName(name);
}
"
"/** 
 * Perform resolution of a class name. <p/> Same as  {@link #classForName(String,Class)} except that here we delegate to{@link Class#forName(String)} if the context classloader lookup is unsuccessful.
 * @param name The class name
 * @return The class reference.
 * @throws ClassNotFoundException From {@link Class#forName(String)}.
 * @deprecated Depending on context, either {@link org.hibernate.boot.registry.classloading.spi.ClassLoaderService}or  {@link org.hibernate.boot.spi.ClassLoaderAccess} should be preferred
 */
@Deprecated public static Class classForName(String name) throws ClassNotFoundException {
  try {
    ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
    if (classLoader != null) {
      return classLoader.loadClass(name);
    }
  }
 catch (  Throwable ignore) {
  }
  return Class.forName(name);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #applyIntegrator} instead
 */
@Deprecated public BootstrapServiceRegistryBuilder with(Integrator integrator){
  return applyIntegrator(integrator);
}
"
"/** 
 * @deprecated Use {@link #applyClassLoader} instead
 */
@Deprecated public BootstrapServiceRegistryBuilder with(ClassLoader classLoader){
  return applyClassLoader(classLoader);
}
"
"/** 
 * @deprecated Use {@link #applyClassLoaderService} instead
 */
@Deprecated public BootstrapServiceRegistryBuilder with(ClassLoaderService classLoaderService){
  return applyClassLoaderService(classLoaderService);
}
"
"/** 
 * @deprecated Use {@link #applyStrategySelector} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public <T>BootstrapServiceRegistryBuilder withStrategySelector(Class<T> strategy,String name,Class<? extends T> implementation){
  return applyStrategySelector(strategy,name,implementation);
}
"
"/** 
 * @deprecated Use {@link #applyStrategySelectors} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public BootstrapServiceRegistryBuilder withStrategySelectors(StrategyRegistrationProvider strategyRegistrationProvider){
  return applyStrategySelectors(strategyRegistrationProvider);
}
"
"/** 
 * @deprecated Use {@link #applyIntegrator} instead
 */
@Deprecated public BootstrapServiceRegistryBuilder with(Integrator integrator){
  return applyIntegrator(integrator);
}
"
"/** 
 * @deprecated Use {@link #applyClassLoader} instead
 */
@Deprecated public BootstrapServiceRegistryBuilder with(ClassLoader classLoader){
  return applyClassLoader(classLoader);
}
"
"/** 
 * @deprecated Use {@link #applyClassLoaderService} instead
 */
@Deprecated public BootstrapServiceRegistryBuilder with(ClassLoaderService classLoaderService){
  return applyClassLoaderService(classLoaderService);
}
"
"/** 
 * @deprecated Use {@link #applyStrategySelector} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public <T>BootstrapServiceRegistryBuilder withStrategySelector(Class<T> strategy,String name,Class<? extends T> implementation){
  return applyStrategySelector(strategy,name,implementation);
}
"
"/** 
 * @deprecated Use {@link #applyStrategySelectors} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public BootstrapServiceRegistryBuilder withStrategySelectors(StrategyRegistrationProvider strategyRegistrationProvider){
  return applyStrategySelectors(strategyRegistrationProvider);
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated() public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated() public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public ImmutableEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,null);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public AbstractEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,persistenceContext);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public ImmutableEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,null);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public ImmutableEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,null);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public AbstractEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,persistenceContext);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public ImmutableEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,null);
}
"
"/** 
 * Does this dialect support identity column key generation?
 * @return True if IDENTITY columns are supported; false otherwise.
 * @deprecated use {@link IdentityColumnSupport} method instead
 */
@Deprecated public boolean supportsIdentityColumns(){
  return getIdentityColumnSupport().supportsIdentityColumns();
}
"
"/** 
 * Does the dialect support some form of inserting and selecting the generated IDENTITY value all in the same statement.
 * @return True if the dialect supports selecting the justgenerated IDENTITY in the insert statement.
 * @deprecated use {@link IdentityColumnSupport} method instead
 */
@Deprecated public boolean supportsInsertSelectIdentity(){
  return getIdentityColumnSupport().supportsInsertSelectIdentity();
}
"
"/** 
 * Whether this dialect have an Identity clause added to the data type or a completely separate identity data type
 * @return boolean
 * @deprecated use {@link IdentityColumnSupport} method instead
 */
@Deprecated public boolean hasDataTypeInIdentityColumn(){
  return getIdentityColumnSupport().hasDataTypeInIdentityColumn();
}
"
"/** 
 * Provided we  {@link #supportsInsertSelectIdentity}, then attach the ""select identity"" clause to the  insert statement. <p/> Note, if  {@link #supportsInsertSelectIdentity} == false thenthe insert-string should be returned without modification.
 * @param insertString The insert command
 * @return The insert command with any necessary identity selectclause attached.
 * @deprecated use {@link IdentityColumnSupport} method instead
 */
@Deprecated public String appendIdentitySelectToInsert(String insertString){
  return getIdentityColumnSupport().appendIdentitySelectToInsert(insertString);
}
"
"/** 
 * Get the select command to use to retrieve the last generated IDENTITY value for a particular table
 * @param table The table into which the insert was done
 * @param column The PK column.
 * @param type The {@link java.sql.Types} type code.
 * @return The appropriate select command
 * @throws MappingException If IDENTITY generation is not supported.
 * @deprecated use {@link IdentityColumnSupport} method instead
 */
@Deprecated public String getIdentitySelectString(String table,String column,int type) throws MappingException {
  return getIdentityColumnSupport().getIdentitySelectString(table,column,type);
}
"
"/** 
 * The syntax used during DDL to define a column as being an IDENTITY of a particular type.
 * @param type The {@link java.sql.Types} type code.
 * @return The appropriate DDL fragment.
 * @throws MappingException If IDENTITY generation is not supported.
 * @deprecated use {@link IdentityColumnSupport} method instead
 */
@Deprecated public String getIdentityColumnString(int type) throws MappingException {
  return getIdentityColumnSupport().getIdentityColumnString(type);
}
"
"/** 
 * The keyword used to insert a generated value into an identity column (or null). Need if the dialect does not support inserts that specify no column values.
 * @return The appropriate keyword.
 * @deprecated use {@link IdentityColumnSupport} method instead
 */
@Deprecated public String getIdentityInsertString(){
  return getIdentityColumnSupport().getIdentityInsertString();
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public String getQualifiedName(Dialect dialect,String defaultCatalog,String defaultSchema){
  if (subselect != null) {
    return ""( "" + subselect + "" )"";
  }
  String quotedName=getQuotedName(dialect);
  String usedSchema=schema == null ? defaultSchema : getQuotedSchema(dialect);
  String usedCatalog=catalog == null ? defaultCatalog : getQuotedCatalog(dialect);
  return qualify(usedCatalog,usedSchema,quotedName);
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public static String qualify(String catalog,String schema,String table){
  StringBuilder qualifiedName=new StringBuilder();
  if (catalog != null) {
    qualifiedName.append(catalog).append('.');
  }
  if (schema != null) {
    qualifiedName.append(schema).append('.');
  }
  return qualifiedName.append(table).toString();
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public AbstractEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,persistenceContext);
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public String getQualifiedName(Dialect dialect,String defaultCatalog,String defaultSchema){
  if (subselect != null) {
    return ""( "" + subselect + "" )"";
  }
  String quotedName=getQuotedName(dialect);
  String usedSchema=schema == null ? defaultSchema : getQuotedSchema(dialect);
  String usedCatalog=catalog == null ? defaultCatalog : getQuotedCatalog(dialect);
  return qualify(usedCatalog,usedSchema,quotedName);
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public static String qualify(String catalog,String schema,String table){
  StringBuilder qualifiedName=new StringBuilder();
  if (catalog != null) {
    qualifiedName.append(catalog).append('.');
  }
  if (schema != null) {
    qualifiedName.append(schema).append('.');
  }
  return qualifiedName.append(table).toString();
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * Which of the properties of this class are database generated values on insert?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions();
"
"/** 
 * Which of the properties of this class are database generated values on update?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions();
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public AbstractEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,persistenceContext);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public ImmutableEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,null);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public MutableEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,persistenceContext);
}
"
"/** 
 * Get the mapping from entity instance to entity entry
 * @deprecated Due to the introduction of EntityEntryContext and bytecode enhancement; only valid really forsizing, see  {@link #getNumberOfManagedEntities}.  For iterating the entity/EntityEntry combos, see {@link #reentrantSafeEntityEntries}
 */
@Deprecated public Map getEntityEntries();
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * Which of the properties of this class are database generated values on insert?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions();
"
"/** 
 * Which of the properties of this class are database generated values on update?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions();
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * @deprecated prefer {@link #getOptimisticLockStyle}
 */
@Deprecated public int getOptimisticLockMode(){
  return getOptimisticLockStyle().getOldCode();
}
"
"/** 
 * @deprecated prefer {@link #setOptimisticLockStyle}
 */
@Deprecated public void setOptimisticLockMode(int optimisticLockMode){
  setOptimisticLockStyle(OptimisticLockStyle.interpretOldCode(optimisticLockMode));
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public String getQualifiedName(Dialect dialect,String defaultCatalog,String defaultSchema){
  if (subselect != null) {
    return ""( "" + subselect + "" )"";
  }
  String quotedName=getQuotedName(dialect);
  String usedSchema=schema == null ? defaultSchema : getQuotedSchema(dialect);
  String usedCatalog=catalog == null ? defaultCatalog : getQuotedCatalog(dialect);
  return qualify(usedCatalog,usedSchema,quotedName);
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public static String qualify(String catalog,String schema,String table){
  StringBuilder qualifiedName=new StringBuilder();
  if (catalog != null) {
    qualifiedName.append(catalog).append('.');
  }
  if (schema != null) {
    qualifiedName.append(schema).append('.');
  }
  return qualifiedName.append(table).toString();
}
"
"/** 
 * @deprecated prefer {@link #getOptimisticLockStyle}
 */
@Deprecated public int getOptimisticLockMode(){
  return getOptimisticLockStyle().getOldCode();
}
"
"/** 
 * @deprecated prefer {@link #setOptimisticLockStyle}
 */
@Deprecated public void setOptimisticLockMode(int optimisticLockMode){
  setOptimisticLockStyle(OptimisticLockStyle.interpretOldCode(optimisticLockMode));
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public String getQualifiedName(Dialect dialect,String defaultCatalog,String defaultSchema){
  if (subselect != null) {
    return ""( "" + subselect + "" )"";
  }
  String quotedName=getQuotedName(dialect);
  String usedSchema=schema == null ? defaultSchema : getQuotedSchema(dialect);
  String usedCatalog=catalog == null ? defaultCatalog : getQuotedCatalog(dialect);
  return qualify(usedCatalog,usedSchema,quotedName);
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public static String qualify(String catalog,String schema,String table){
  StringBuilder qualifiedName=new StringBuilder();
  if (catalog != null) {
    qualifiedName.append(catalog).append('.');
  }
  if (schema != null) {
    qualifiedName.append(schema).append('.');
  }
  return qualifiedName.append(table).toString();
}
"
"/** 
 * Release all resources held by this provider.
 * @throws HibernateException Indicates a problem closing the underlying pool or releasing resources
 * @deprecated Use {@link #stop} instead
 */
@Deprecated public void close() throws HibernateException {
  stop();
}
"
"/** 
 * Release all resources held by this provider.
 * @throws HibernateException Indicates a problem closing the underlying pool or releasing resources
 * @deprecated Use {@link #stop} instead
 */
@Deprecated public void close() throws HibernateException {
  stop();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType customCollection(String typeName,Properties typeParameters,String role,String propertyRef,boolean embedded){
  Class typeClass;
  try {
    typeClass=ReflectHelper.classForName(typeName);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new MappingException(""user collection type class not found: "" + typeName,cnfe);
  }
  CustomCollectionType result=new CustomCollectionType(typeScope,typeClass,role,propertyRef,embedded);
  if (typeParameters != null) {
    injectParameters(result.getUserType(),typeParameters);
  }
  return result;
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #specialOneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType specialOneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return specialOneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #array(String,String,Class)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType array(String role,String propertyRef,boolean embedded,Class elementClass){
  return new ArrayType(typeScope,role,propertyRef,elementClass,embedded);
}
"
"/** 
 * @deprecated Use {@link #list(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType list(String role,String propertyRef,boolean embedded){
  return new ListType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #bag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType bag(String role,String propertyRef,boolean embedded){
  return new BagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #idbag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType idbag(String role,String propertyRef,boolean embedded){
  return new IdentifierBagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #map(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType map(String role,String propertyRef,boolean embedded){
  return new MapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedMap(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedMap(String role,String propertyRef,boolean embedded){
  return new OrderedMapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedMap(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedMap(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedMapType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @deprecated Use {@link #set(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType set(String role,String propertyRef,boolean embedded){
  return new SetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedSet(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedSet(String role,String propertyRef,boolean embedded){
  return new OrderedSetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedSet(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedSet(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedSetType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass,Properties parameters,TypeScope scope){
  try {
    CompositeUserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CompositeCustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #customCollection(String,java.util.Properties,String,String)}instead. See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType customCollection(String typeName,Properties typeParameters,String role,String propertyRef,boolean embedded){
  Class typeClass;
  try {
    typeClass=ReflectHelper.classForName(typeName);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new MappingException(""user collection type class not found: "" + typeName,cnfe);
  }
  CustomCollectionType result=new CustomCollectionType(typeScope,typeClass,role,propertyRef,embedded);
  if (typeParameters != null) {
    injectParameters(result.getUserType(),typeParameters);
  }
  return result;
}
"
"/** 
 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 */
@Deprecated public static CustomType custom(Class<UserType> typeClass,Properties parameters,TypeScope scope){
  try {
    UserType userType=typeClass.newInstance();
    injectParameters(userType,parameters);
    return new CustomType(userType);
  }
 catch (  Exception e) {
    throw new MappingException(""Unable to instantiate custom type: "" + typeClass.getName(),e);
  }
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #oneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType oneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return oneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #specialOneToOne(String,ForeignKeyDirection,String,boolean,boolean,String,String,boolean)} instead.
 */
@Deprecated public EntityType specialOneToOne(String persistentClass,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  return specialOneToOne(persistentClass,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #manyToOne(String,boolean,String,boolean,boolean,boolean,boolean)} instead.
 */
@Deprecated public EntityType manyToOne(String persistentClass,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean ignoreNotFound,boolean isLogicalOneToOne){
  return manyToOne(persistentClass,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #array(String,String,Class)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType array(String role,String propertyRef,boolean embedded,Class elementClass){
  return new ArrayType(typeScope,role,propertyRef,elementClass,embedded);
}
"
"/** 
 * @deprecated Use {@link #list(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType list(String role,String propertyRef,boolean embedded){
  return new ListType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #bag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType bag(String role,String propertyRef,boolean embedded){
  return new BagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #idbag(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType idbag(String role,String propertyRef,boolean embedded){
  return new IdentifierBagType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #map(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType map(String role,String propertyRef,boolean embedded){
  return new MapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedMap(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedMap(String role,String propertyRef,boolean embedded){
  return new OrderedMapType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedMap(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedMap(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedMapType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @deprecated Use {@link #set(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType set(String role,String propertyRef,boolean embedded){
  return new SetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #orderedSet(String,String)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType orderedSet(String role,String propertyRef,boolean embedded){
  return new OrderedSetType(typeScope,role,propertyRef,embedded);
}
"
"/** 
 * @deprecated Use {@link #sortedSet(String,String,java.util.Comparator)} instead.See Jira issue: <a href=""https://hibernate.onjira.com/browse/HHH-7771"">HHH-7771</a>
 */
@Deprecated public CollectionType sortedSet(String role,String propertyRef,boolean embedded,Comparator comparator){
  return new SortedSetType(typeScope,role,propertyRef,comparator,embedded);
}
"
"/** 
 * @param dialect The dialect for which to generate the creation script
 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out whatshould be created/altered
 * @return The sequence of DDL commands to apply the schema objects
 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect,DatabaseMetadata)} instead
 */
@SuppressWarnings({""unchecked""}) @Deprecated public String[] generateSchemaUpdateScript(Dialect dialect,DatabaseMetadata databaseMetadata) throws HibernateException {
  List<SchemaUpdateScript> scripts=generateSchemaUpdateScriptList(dialect,databaseMetadata);
  return SchemaUpdateScript.toStringArray(scripts);
}
"
"/** 
 * Create a  {@link SessionFactory} using the properties and mappings in this configuration. The{@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} afterbuilding the  {@link SessionFactory} will not affect it.
 * @return The build {@link SessionFactory}
 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 */
public SessionFactory buildSessionFactory() throws HibernateException {
  Environment.verifyProperties(properties);
  ConfigurationHelper.resolvePlaceHolders(properties);
  final ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(properties).buildServiceRegistry();
  setSessionFactoryObserver(new SessionFactoryObserver(){
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      ((StandardServiceRegistryImpl)serviceRegistry).destroy();
    }
  }
);
  return buildSessionFactory(serviceRegistry);
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    final Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,incrementSize);
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * Builds an optimizer
 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 * @param returnClass The generated value java type
 * @param incrementSize The increment size.
 * @return The built optimizer
 * @deprecated Use {@link #buildOptimizer(String,Class,int,long)} instead
 */
@Deprecated public static Optimizer buildOptimizer(String type,Class returnClass,int incrementSize){
  final Class<? extends Optimizer> optimizerClass;
  final StandardOptimizerDescriptor standardDescriptor=StandardOptimizerDescriptor.fromExternalName(type);
  if (standardDescriptor != null) {
    optimizerClass=standardDescriptor.getOptimizerClass();
  }
 else {
    try {
      optimizerClass=ReflectHelper.classForName(type);
    }
 catch (    Throwable ignore) {
      LOG.unableToLocateCustomOptimizerClass(type);
      return buildFallbackOptimizer(returnClass,incrementSize);
    }
  }
  try {
    final Constructor ctor=optimizerClass.getConstructor(CTOR_SIG);
    return (Optimizer)ctor.newInstance(returnClass,incrementSize);
  }
 catch (  Throwable ignore) {
    LOG.unableToInstantiateOptimizer(type);
  }
  return buildFallbackOptimizer(returnClass,incrementSize);
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated() public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated() public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a the result-set mapping information is not explicitly  provided in the query definition (i.e., no resultset-mapping used).
 * @param name The name of named query
 * @param query The sql query string
 * @param queryReturns The in-lined query return definitions
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,NativeSQLQueryReturn[] queryReturns,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,null,querySpaces,callable,queryReturns);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a resultset-mapping reference is used.
 * @param name The name of named query
 * @param query The sql query string
 * @param resultSetRef The resultset-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,String resultSetRef,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,resultSetRef,querySpaces,callable,null);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a the result-set mapping information is not explicitly  provided in the query definition (i.e., no resultset-mapping used).
 * @param name The name of named query
 * @param query The sql query string
 * @param queryReturns The in-lined query return definitions
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,NativeSQLQueryReturn[] queryReturns,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,null,querySpaces,callable,queryReturns);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a resultset-mapping reference is used.
 * @param name The name of named query
 * @param query The sql query string
 * @param resultSetRef The resultset-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,String resultSetRef,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,resultSetRef,querySpaces,callable,null);
}
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(Iterator,Set,SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,Collections.<MappedSuperclass>emptySet(),sessionFactory,false);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a the result-set mapping information is not explicitly  provided in the query definition (i.e., no resultset-mapping used).
 * @param name The name of named query
 * @param query The sql query string
 * @param queryReturns The in-lined query return definitions
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,NativeSQLQueryReturn[] queryReturns,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,null,querySpaces,callable,queryReturns);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a resultset-mapping reference is used.
 * @param name The name of named query
 * @param query The sql query string
 * @param resultSetRef The resultset-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,String resultSetRef,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,resultSetRef,querySpaces,callable,null);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a the result-set mapping information is not explicitly  provided in the query definition (i.e., no resultset-mapping used).
 * @param name The name of named query
 * @param query The sql query string
 * @param queryReturns The in-lined query return definitions
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,NativeSQLQueryReturn[] queryReturns,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,null,querySpaces,callable,queryReturns);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a resultset-mapping reference is used.
 * @param name The name of named query
 * @param query The sql query string
 * @param resultSetRef The resultset-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,String resultSetRef,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,resultSetRef,querySpaces,callable,null);
}
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(Iterator,Set,SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,Collections.<MappedSuperclass>emptySet(),sessionFactory,false);
}
"
"/** 
 * Applies the given entity mode as the default for the SessionFactory.
 * @param entityMode The default entity mode to use.
 * @return {@code this}, for method chaining
 * @see org.hibernate.cfg.AvailableSettings#DEFAULT_ENTITY_MODE
 * @deprecated Different entity modes per entity is soon to be removed as a feature.
 */
@Deprecated public SessionFactoryBuilder applyDefaultEntityMode(EntityMode entityMode);
"
"/** 
 * Apply query substitutions to use in HQL queries.  Note, this is a legacy feature and almost always never needed anymore...
 * @param substitutions The substitution map
 * @return {@code this}, for method chaining
 * @see org.hibernate.cfg.AvailableSettings#QUERY_SUBSTITUTIONS
 * @deprecated This is a legacy feature and should never be needed anymore...
 */
@Deprecated public SessionFactoryBuilder applyQuerySubstitutions(Map substitutions);
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(ServiceRegistry serviceRegistry,Configuration configuration){
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(Configuration configuration){
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(Configuration configuration,Connection connection) throws HibernateException {
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(ServiceRegistry serviceRegistry,Configuration configuration){
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(Configuration configuration){
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * @deprecated Use one of the forms accepting {@link MetadataImplementor}, rather than  {@link Configuration}, instead.
 */
@Deprecated public SchemaExport(Configuration configuration,Connection connection) throws HibernateException {
  throw new UnsupportedOperationException(""Attempt to use unsupported SchemaExport constructor accepting org.hibernate.cfg.Configuration; "" + ""one of the forms accepting org.hibernate.boot.spi.MetadataImplementor should be used instead"");
}
"
"/** 
 * Does this dialect support identity column key generation?
 * @return True if IDENTITY columns are supported; false otherwise.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().supportsIdentityColumns()} does not delegateto this method, then this method is ignored.
 */
@Deprecated public boolean supportsIdentityColumns(){
  return false;
}
"
"/** 
 * Does the dialect support some form of inserting and selecting the generated IDENTITY value all in the same statement.
 * @return True if the dialect supports selecting the justgenerated IDENTITY in the insert statement.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().supportsInsertSelectIdentity()} does not delegateto this method, then this method is ignored.
 */
@Deprecated public boolean supportsInsertSelectIdentity(){
  return false;
}
"
"/** 
 * Whether this dialect have an Identity clause added to the data type or a completely separate identity data type
 * @return boolean
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().hasDataTypeInIdentityColumn()} does not delegateto this method, then this method is ignored.
 */
@Deprecated public boolean hasDataTypeInIdentityColumn(){
  return true;
}
"
"/** 
 * Provided we  {@link #supportsInsertSelectIdentity}, then attach the ""select identity"" clause to the  insert statement. <p/> Note, if  {@link #supportsInsertSelectIdentity} == false thenthe insert-string should be returned without modification.
 * @param insertString The insert command
 * @return The insert command with any necessary identity selectclause attached.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().appendIdentitySelectToInsert(String)} does not delegateto this method, then this method is ignored.
 */
@Deprecated public String appendIdentitySelectToInsert(String insertString){
  return insertString;
}
"
"/** 
 * Get the select command to use to retrieve the last generated IDENTITY value for a particular table
 * @param table The table into which the insert was done
 * @param column The PK column.
 * @param type The {@link java.sql.Types} type code.
 * @return The appropriate select command
 * @throws MappingException If IDENTITY generation is not supported.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().getIdentitySelectString(String,String,int)} does not delegateto this method, then this method is ignored.
 */
@Deprecated public String getIdentitySelectString(String table,String column,int type) throws MappingException {
  return getIdentitySelectString();
}
"
"/** 
 * The syntax used during DDL to define a column as being an IDENTITY of a particular type.
 * @param type The {@link java.sql.Types} type code.
 * @return The appropriate DDL fragment.
 * @throws MappingException If IDENTITY generation is not supported.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().getIdentityColumnString(int)} does not delegateto this method, then this method is ignored.
 */
@Deprecated public String getIdentityColumnString(int type) throws MappingException {
  return getIdentityColumnString();
}
"
"/** 
 * The keyword used to insert a generated value into an identity column (or null). Need if the dialect does not support inserts that specify no column values.
 * @return The appropriate keyword.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().getIdentityInsertString()} does not delegateto this method, then this method is ignored.
 */
@Deprecated public String getIdentityInsertString(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public String getQualifiedName(Dialect dialect,String defaultCatalog,String defaultSchema){
  if (subselect != null) {
    return ""( "" + subselect + "" )"";
  }
  String quotedName=getQuotedName(dialect);
  String usedSchema=schema == null ? defaultSchema : getQuotedSchema(dialect);
  String usedCatalog=catalog == null ? defaultCatalog : getQuotedCatalog(dialect);
  return qualify(usedCatalog,usedSchema,quotedName);
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public static String qualify(String catalog,String schema,String table){
  StringBuilder qualifiedName=new StringBuilder();
  if (catalog != null) {
    qualifiedName.append(catalog).append('.');
  }
  if (schema != null) {
    qualifiedName.append(schema).append('.');
  }
  return qualifiedName.append(table).toString();
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * Which of the properties of this class are database generated values on insert?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions();
"
"/** 
 * Which of the properties of this class are database generated values on update?
 * @deprecated Replaced internally with InMemoryValueGenerationStrategy / InDatabaseValueGenerationStrategy
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions();
"
"/** 
 * Get the identifier of an instance (throw an exception if no identifier property)
 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public Serializable getIdentifier(Object object) throws HibernateException ;
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-separated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-separated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,JoinType,Criterion)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, using the specified join type.
 * @param associationPath A dot-separated property path
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-separated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-separated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,String,org.hibernate.sql.JoinType,org.hibernate.criterion.Criterion)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
  return this;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public void add(XmlDocument metadataXml){
}
"
"/** 
 * @deprecated No longer supported
 */
@Deprecated public Configuration addXML(String xml) throws MappingException {
  return this;
}
"
"/** 
 * Read mappings from a DOM <tt>Document</tt>
 * @param doc The DOM document
 * @return this (for method chaining purposes)
 * @throws MappingException Indicates problems reading the DOM or processingthe mapping document.
 * @deprecated Use addURL, addResource, addFile, etc. instead
 */
@Deprecated public Configuration addDocument(org.w3c.dom.Document doc) throws MappingException {
  metadataSources.addDocument(doc);
  return this;
}
"
"/** 
 * @deprecated This form (accepting a ClassLoader) is no longer supported.  Instead, add the ClassLoaderto the ClassLoaderService on the ServiceRegistry associated with this Configuration
 */
@Deprecated public Configuration addResource(String resourceName,ClassLoader classLoader) throws MappingException {
  return addResource(resourceName);
}
"
"/** 
 * @deprecated Does nothing
 */
@Deprecated public void buildMappings(){
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * Creates a single node AST. <p/> TODO : this is silly, remove it...
 * @param astFactory The factory.
 * @param type The node type.
 * @param text The node text.
 * @return AST - A single node tree.
 * @deprecated silly
 */
@Deprecated public static AST create(ASTFactory astFactory,int type,String text){
  return astFactory.create(type,text);
}
"
"/** 
 * Get the name of a constant defined on the given class which has the given value. <p/> Note, if multiple constants have this value, the first will be returned which is known to be different on different JVM implementations.
 * @param owner The class which defines the constant
 * @param value The value of the constant.
 * @return The token type name, *or* the integer value if the name could not be found.
 * @deprecated Use #getTokenTypeName instead
 */
@Deprecated public static String getConstantName(Class owner,int value){
  return getTokenTypeName(owner,value);
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
@Deprecated public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
@Deprecated public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
@Deprecated public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  if (providedClassLoaders.isEmpty()) {
    log.debugf(""Incoming config yielded no classloaders; adding standard SE ones"");
    final ClassLoader tccl=locateTCCL();
    if (tccl != null) {
      providedClassLoaders.add(tccl);
    }
    providedClassLoaders.add(ClassLoaderServiceImpl.class.getClassLoader());
  }
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated Use {@link #setImplicitNamingStrategy} or {@link #setPhysicalNamingStrategy}instead
 */
@Deprecated public void setNamingStrategy(String namingStrategy){
  DeprecationLogger.DEPRECATION_LOGGER.logDeprecatedNamingStrategyAntArgument();
}
"
"/** 
 * @deprecated prefer {@link #getOptimisticLockStyle}
 */
@Deprecated public int getOptimisticLockMode(){
  return getOptimisticLockStyle().getOldCode();
}
"
"/** 
 * @deprecated prefer {@link #setOptimisticLockStyle}
 */
@Deprecated public void setOptimisticLockMode(int optimisticLockMode){
  setOptimisticLockStyle(OptimisticLockStyle.interpretOldCode(optimisticLockMode));
}
"
"/** 
 * @deprecated prefer {@link #getOptimisticLockStyle}
 */
@Deprecated public int getOptimisticLockMode(){
  return getOptimisticLockStyle().getOldCode();
}
"
"/** 
 * @deprecated prefer {@link #setOptimisticLockStyle}
 */
@Deprecated public void setOptimisticLockMode(int optimisticLockMode){
  setOptimisticLockStyle(OptimisticLockStyle.interpretOldCode(optimisticLockMode));
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
@Deprecated public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return value;
  }
 else   if (clazz == Integer.class) {
    return (int)value;
  }
 else   if (clazz == Short.class) {
    return (short)value;
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
@Deprecated public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return value;
  }
 else   if (clazz == Integer.class) {
    return (int)value;
  }
 else   if (clazz == Short.class) {
    return (short)value;
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public String getQualifiedName(Dialect dialect,String defaultCatalog,String defaultSchema){
  if (subselect != null) {
    return ""( "" + subselect + "" )"";
  }
  String quotedName=getQuotedName(dialect);
  String usedSchema=schema == null ? defaultSchema : getQuotedSchema(dialect);
  String usedCatalog=catalog == null ? defaultCatalog : getQuotedCatalog(dialect);
  return qualify(usedCatalog,usedSchema,quotedName);
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public static String qualify(String catalog,String schema,String table){
  StringBuilder qualifiedName=new StringBuilder();
  if (catalog != null) {
    qualifiedName.append(catalog).append('.');
  }
  if (schema != null) {
    qualifiedName.append(schema).append('.');
  }
  return qualifiedName.append(table).toString();
}
"
"/** 
 * @deprecated (snce 6.0) SessionDelegatorBaseImpl should take just one argument, the SessionImplementor.Use the  {@link #SessionDelegatorBaseImpl(SessionImplementor)} form instead
 */
@Deprecated public SessionDelegatorBaseImpl(SessionImplementor delegate,Session session){
  if (delegate == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null delegate object"");
  }
  if (session == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null Session"");
  }
  if (delegate != session) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from different Session/SessionImplementor references"");
  }
  this.delegate=delegate;
}
"
"/** 
 * Build the metamodel using the information from the collection of Hibernate {@link PersistentClass} models as well as the Hibernate {@link org.hibernate.SessionFactory}.
 * @param persistentClasses Iterator over the Hibernate (config-time) metamodel
 * @param sessionFactory The Hibernate session factory.
 * @return The built metamodel
 * @deprecated use {@link #buildMetamodel(Iterator,Set,SessionFactoryImplementor,boolean)} instead
 */
@Deprecated public static MetamodelImpl buildMetamodel(Iterator<PersistentClass> persistentClasses,SessionFactoryImplementor sessionFactory){
  return buildMetamodel(persistentClasses,Collections.emptySet(),sessionFactory,false);
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The type
 * @deprecated Use {@link OrdinalParameterDescriptor#getExpectedType()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public Type getOrdinalParameterExpectedType(int position){
  return getOrdinalParameterDescriptor(position).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The source location
 * @deprecated Use {@link OrdinalParameterDescriptor#getSourceLocation()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public int getOrdinalParameterSourceLocation(int position){
  return getOrdinalParameterDescriptor(position).getSourceLocation();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getExpectedType()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public Type getNamedParameterExpectedType(String name){
  return getNamedParameterDescriptor(name).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getSourceLocations()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public int[] getNamedParameterSourceLocations(String name){
  return getNamedParameterDescriptor(name).getSourceLocations();
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Type> collectBindTypes(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindType).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Object> collectBindValues(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindValue).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Type[] collectPositionalBindTypes(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Type[] types=new Type[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    Type type=entry.getValue().getBindType();
    if (type == null) {
      log.debugf(""Binding for positional-parameter [%s] did not define type, using SerializableType"",position);
      type=SerializableType.INSTANCE;
    }
    types[position]=type;
  }
  return types;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Object[] collectPositionalBindValues(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Object[] values=new Object[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    values[position]=entry.getValue().getBindValue();
  }
  return values;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Map<String,TypedValue> collectNamedParameterBindings(){
  Map<String,TypedValue> collectedBindings=new HashMap<>();
  for (  Map.Entry<QueryParameter,QueryParameterBinding> entry : parameterBindingMap.entrySet()) {
    if (entry.getKey().getName() == null) {
      continue;
    }
    Type bindType=entry.getValue().getBindType();
    if (bindType == null) {
      log.debugf(""Binding for named-parameter [%s] did not define type"",entry.getKey().getName());
      bindType=SerializableType.INSTANCE;
    }
    collectedBindings.put(entry.getKey().getName(),new TypedValue(bindType,entry.getValue().getBindValue()));
  }
  return collectedBindings;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(QueryParameter<T> queryParameter){
  QueryParameterListBinding result=parameterListBindingMap.get(queryParameter);
  if (result == null) {
    result=transformQueryParameterBindingToQueryParameterListBinding(queryParameter);
  }
  return result;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(String name){
  final QueryParameter<T> queryParameter=resolveQueryParameter(name);
  return getQueryParameterListBinding(queryParameter);
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public String expandListValuedParameters(String queryString,SharedSessionContractImplementor session){
  if (queryString == null) {
    return null;
  }
  final Dialect dialect=session.getFactory().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect();
  final int inExprLimit=dialect.getInExpressionCountLimit();
  for (  Map.Entry<QueryParameter,QueryParameterListBinding> entry : parameterListBindingMap.entrySet()) {
    final NamedParameterDescriptor sourceParam=(NamedParameterDescriptor)entry.getKey();
    final Collection bindValues=entry.getValue().getBindValues();
    if (inExprLimit > 0 && bindValues.size() > inExprLimit) {
      log.tooManyInExpressions(dialect.getClass().getName(),inExprLimit,sourceParam.getName(),bindValues.size());
    }
    final boolean isJpaPositionalParam=sourceParam.isJpaPositionalParameter();
    final String paramPrefix=isJpaPositionalParam ? ""?"" : ParserHelper.HQL_VARIABLE_PREFIX;
    final String placeholder=paramPrefix + sourceParam.getName();
    final int loc=queryString.indexOf(placeholder);
    if (loc < 0) {
      continue;
    }
    final String beforePlaceholder=queryString.substring(0,loc);
    final String afterPlaceholder=queryString.substring(loc + placeholder.length());
    boolean isEnclosedInParens=StringHelper.getLastNonWhitespaceCharacter(beforePlaceholder) == '(' && StringHelper.getFirstNonWhitespaceCharacter(afterPlaceholder) == ')';
    if (bindValues.size() == 1 && isEnclosedInParens) {
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValues.iterator().next());
      parameterBindingMap.put(sourceParam,syntheticBinding);
      continue;
    }
    StringBuilder expansionList=new StringBuilder();
    int i=0;
    for (    Object bindValue : entry.getValue().getBindValues()) {
      final String syntheticName=(isJpaPositionalParam ? 'x' : """") + sourceParam.getName() + '_'+ i;
      if (i > 0) {
        expansionList.append("", "");
      }
      expansionList.append(ParserHelper.HQL_VARIABLE_PREFIX).append(syntheticName);
      final QueryParameter syntheticParam=new QueryParameterNamedImpl<>(syntheticName,sourceParam.getSourceLocations(),sourceParam.isJpaPositionalParameter(),sourceParam.getType());
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValue);
      if (parameterBindingMap.put(syntheticParam,syntheticBinding) != null) {
        throw new HibernateException(""Repeated usage of synthetic parameter name ["" + syntheticName + ""] while expanding list parameter."");
      }
      i++;
    }
    queryString=StringHelper.replace(beforePlaceholder,afterPlaceholder,placeholder,expansionList.toString(),true,true);
  }
  parameterListBindingMap.clear();
  return queryString;
}
"
"/** 
 * @deprecated Use {@link #SpecialOneToOneType(org.hibernate.type.TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)} instead.
 */
@Deprecated public SpecialOneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Type> collectBindTypes(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindType).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Object> collectBindValues(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindValue).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Type[] collectPositionalBindTypes(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Type[] types=new Type[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    Type type=entry.getValue().getBindType();
    if (type == null) {
      log.debugf(""Binding for positional-parameter [%s] did not define type, using SerializableType"",position);
      type=SerializableType.INSTANCE;
    }
    types[position]=type;
  }
  return types;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Object[] collectPositionalBindValues(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Object[] values=new Object[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    values[position]=entry.getValue().getBindValue();
  }
  return values;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Map<String,TypedValue> collectNamedParameterBindings(){
  Map<String,TypedValue> collectedBindings=new HashMap<>();
  for (  Map.Entry<QueryParameter,QueryParameterBinding> entry : parameterBindingMap.entrySet()) {
    if (entry.getKey().getName() == null) {
      continue;
    }
    Type bindType=entry.getValue().getBindType();
    if (bindType == null) {
      log.debugf(""Binding for named-parameter [%s] did not define type"",entry.getKey().getName());
      bindType=SerializableType.INSTANCE;
    }
    collectedBindings.put(entry.getKey().getName(),new TypedValue(bindType,entry.getValue().getBindValue()));
  }
  return collectedBindings;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(QueryParameter<T> queryParameter){
  QueryParameterListBinding result=parameterListBindingMap.get(queryParameter);
  if (result == null) {
    result=transformQueryParameterBindingToQueryParameterListBinding(queryParameter);
  }
  return result;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(String name){
  final QueryParameter<T> queryParameter=resolveQueryParameter(name);
  return getQueryParameterListBinding(queryParameter);
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public String expandListValuedParameters(String queryString,SharedSessionContractImplementor session){
  if (queryString == null) {
    return null;
  }
  final Dialect dialect=session.getFactory().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect();
  final int inExprLimit=dialect.getInExpressionCountLimit();
  for (  Map.Entry<QueryParameter,QueryParameterListBinding> entry : parameterListBindingMap.entrySet()) {
    final NamedParameterDescriptor sourceParam=(NamedParameterDescriptor)entry.getKey();
    final Collection bindValues=entry.getValue().getBindValues();
    if (inExprLimit > 0 && bindValues.size() > inExprLimit) {
      log.tooManyInExpressions(dialect.getClass().getName(),inExprLimit,sourceParam.getName(),bindValues.size());
    }
    final boolean isJpaPositionalParam=sourceParam.isJpaPositionalParameter();
    final String paramPrefix=isJpaPositionalParam ? ""?"" : ParserHelper.HQL_VARIABLE_PREFIX;
    final String placeholder=paramPrefix + sourceParam.getName();
    final int loc=queryString.indexOf(placeholder);
    if (loc < 0) {
      continue;
    }
    final String beforePlaceholder=queryString.substring(0,loc);
    final String afterPlaceholder=queryString.substring(loc + placeholder.length());
    boolean isEnclosedInParens=StringHelper.getLastNonWhitespaceCharacter(beforePlaceholder) == '(' && StringHelper.getFirstNonWhitespaceCharacter(afterPlaceholder) == ')';
    if (bindValues.size() == 1 && isEnclosedInParens) {
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValues.iterator().next());
      parameterBindingMap.put(sourceParam,syntheticBinding);
      continue;
    }
    StringBuilder expansionList=new StringBuilder();
    int i=0;
    for (    Object bindValue : entry.getValue().getBindValues()) {
      final String syntheticName=(isJpaPositionalParam ? 'x' : """") + sourceParam.getName() + '_'+ i;
      if (i > 0) {
        expansionList.append("", "");
      }
      expansionList.append(ParserHelper.HQL_VARIABLE_PREFIX).append(syntheticName);
      final QueryParameter syntheticParam=new QueryParameterNamedImpl<>(syntheticName,sourceParam.getSourceLocations(),sourceParam.isJpaPositionalParameter(),sourceParam.getType());
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValue);
      if (parameterBindingMap.put(syntheticParam,syntheticBinding) != null) {
        throw new HibernateException(""Repeated usage of synthetic parameter name ["" + syntheticName + ""] while expanding list parameter."");
      }
      i++;
    }
    queryString=StringHelper.replace(beforePlaceholder,afterPlaceholder,placeholder,expansionList.toString(),true,true);
  }
  parameterListBindingMap.clear();
  return queryString;
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The type
 * @deprecated Use {@link OrdinalParameterDescriptor#getExpectedType()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public Type getOrdinalParameterExpectedType(int position){
  return getOrdinalParameterDescriptor(position).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The source location
 * @deprecated Use {@link OrdinalParameterDescriptor#getSourceLocation()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public int getOrdinalParameterSourceLocation(int position){
  return getOrdinalParameterDescriptor(position).getSourceLocation();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getExpectedType()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public Type getNamedParameterExpectedType(String name){
  return getNamedParameterDescriptor(name).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getSourceLocations()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public int[] getNamedParameterSourceLocations(String name){
  return getNamedParameterDescriptor(name).getSourceLocations();
}
"
"/** 
 * @deprecated (snce 6.0) SessionDelegatorBaseImpl should take just one argument, the SessionImplementor.Use the  {@link #SessionDelegatorBaseImpl(SessionImplementor)} form instead
 */
@Deprecated public SessionDelegatorBaseImpl(SessionImplementor delegate,Session session){
  if (delegate == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null delegate object"");
  }
  if (session == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null Session"");
  }
  if (delegate != session) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from different Session/SessionImplementor references"");
  }
  this.delegate=delegate;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Type> collectBindTypes(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindType).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Object> collectBindValues(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindValue).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Type[] collectPositionalBindTypes(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Type[] types=new Type[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    Type type=entry.getValue().getBindType();
    if (type == null) {
      log.debugf(""Binding for positional-parameter [%s] did not define type, using SerializableType"",position);
      type=SerializableType.INSTANCE;
    }
    types[position]=type;
  }
  return types;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Object[] collectPositionalBindValues(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Object[] values=new Object[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    values[position]=entry.getValue().getBindValue();
  }
  return values;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Map<String,TypedValue> collectNamedParameterBindings(){
  Map<String,TypedValue> collectedBindings=new HashMap<>();
  for (  Map.Entry<QueryParameter,QueryParameterBinding> entry : parameterBindingMap.entrySet()) {
    if (entry.getKey().getName() == null) {
      continue;
    }
    Type bindType=entry.getValue().getBindType();
    if (bindType == null) {
      log.debugf(""Binding for named-parameter [%s] did not define type"",entry.getKey().getName());
      bindType=SerializableType.INSTANCE;
    }
    collectedBindings.put(entry.getKey().getName(),new TypedValue(bindType,entry.getValue().getBindValue()));
  }
  return collectedBindings;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(QueryParameter<T> queryParameter){
  QueryParameterListBinding result=parameterListBindingMap.get(queryParameter);
  if (result == null) {
    result=transformQueryParameterBindingToQueryParameterListBinding(queryParameter);
  }
  return result;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(String name){
  final QueryParameter<T> queryParameter=resolveQueryParameter(name);
  return getQueryParameterListBinding(queryParameter);
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public String expandListValuedParameters(String queryString,SharedSessionContractImplementor session){
  if (queryString == null) {
    return null;
  }
  final Dialect dialect=session.getFactory().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect();
  final int inExprLimit=dialect.getInExpressionCountLimit();
  for (  Map.Entry<QueryParameter,QueryParameterListBinding> entry : parameterListBindingMap.entrySet()) {
    final NamedParameterDescriptor sourceParam=(NamedParameterDescriptor)entry.getKey();
    final Collection bindValues=entry.getValue().getBindValues();
    if (inExprLimit > 0 && bindValues.size() > inExprLimit) {
      log.tooManyInExpressions(dialect.getClass().getName(),inExprLimit,sourceParam.getName(),bindValues.size());
    }
    final boolean isJpaPositionalParam=sourceParam.isJpaPositionalParameter();
    final String paramPrefix=isJpaPositionalParam ? ""?"" : ParserHelper.HQL_VARIABLE_PREFIX;
    final String placeholder=paramPrefix + sourceParam.getName();
    final int loc=queryString.indexOf(placeholder);
    if (loc < 0) {
      continue;
    }
    final String beforePlaceholder=queryString.substring(0,loc);
    final String afterPlaceholder=queryString.substring(loc + placeholder.length());
    boolean isEnclosedInParens=StringHelper.getLastNonWhitespaceCharacter(beforePlaceholder) == '(' && StringHelper.getFirstNonWhitespaceCharacter(afterPlaceholder) == ')';
    if (bindValues.size() == 1 && isEnclosedInParens) {
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValues.iterator().next());
      parameterBindingMap.put(sourceParam,syntheticBinding);
      continue;
    }
    StringBuilder expansionList=new StringBuilder();
    int i=0;
    for (    Object bindValue : entry.getValue().getBindValues()) {
      final String syntheticName=(isJpaPositionalParam ? 'x' : """") + sourceParam.getName() + '_'+ i;
      if (i > 0) {
        expansionList.append("", "");
      }
      expansionList.append(ParserHelper.HQL_VARIABLE_PREFIX).append(syntheticName);
      final QueryParameter syntheticParam=new QueryParameterNamedImpl<>(syntheticName,sourceParam.getSourceLocations(),sourceParam.isJpaPositionalParameter(),sourceParam.getType());
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValue);
      if (parameterBindingMap.put(syntheticParam,syntheticBinding) != null) {
        throw new HibernateException(""Repeated usage of synthetic parameter name ["" + syntheticName + ""] while expanding list parameter."");
      }
      i++;
    }
    queryString=StringHelper.replace(beforePlaceholder,afterPlaceholder,placeholder,expansionList.toString(),true,true);
  }
  return queryString;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Type> collectBindTypes(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindType).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Object> collectBindValues(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindValue).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Type[] collectPositionalBindTypes(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Type[] types=new Type[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    Type type=entry.getValue().getBindType();
    if (type == null) {
      log.debugf(""Binding for positional-parameter [%s] did not define type, using SerializableType"",position);
      type=SerializableType.INSTANCE;
    }
    types[position]=type;
  }
  return types;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Object[] collectPositionalBindValues(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Object[] values=new Object[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    values[position]=entry.getValue().getBindValue();
  }
  return values;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Map<String,TypedValue> collectNamedParameterBindings(){
  Map<String,TypedValue> collectedBindings=new HashMap<>();
  for (  Map.Entry<QueryParameter,QueryParameterBinding> entry : parameterBindingMap.entrySet()) {
    if (entry.getKey().getName() == null) {
      continue;
    }
    Type bindType=entry.getValue().getBindType();
    if (bindType == null) {
      log.debugf(""Binding for named-parameter [%s] did not define type"",entry.getKey().getName());
      bindType=SerializableType.INSTANCE;
    }
    collectedBindings.put(entry.getKey().getName(),new TypedValue(bindType,entry.getValue().getBindValue()));
  }
  return collectedBindings;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(QueryParameter<T> queryParameter){
  QueryParameterListBinding result=parameterListBindingMap.get(queryParameter);
  if (result == null) {
    result=transformQueryParameterBindingToQueryParameterListBinding(queryParameter);
  }
  return result;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(String name){
  final QueryParameter<T> queryParameter=resolveQueryParameter(name);
  return getQueryParameterListBinding(queryParameter);
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public String expandListValuedParameters(String queryString,SharedSessionContractImplementor session){
  if (queryString == null) {
    return null;
  }
  final Dialect dialect=session.getFactory().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect();
  final int inExprLimit=dialect.getInExpressionCountLimit();
  for (  Map.Entry<QueryParameter,QueryParameterListBinding> entry : parameterListBindingMap.entrySet()) {
    final NamedParameterDescriptor sourceParam=(NamedParameterDescriptor)entry.getKey();
    final Collection bindValues=entry.getValue().getBindValues();
    if (inExprLimit > 0 && bindValues.size() > inExprLimit) {
      log.tooManyInExpressions(dialect.getClass().getName(),inExprLimit,sourceParam.getName(),bindValues.size());
    }
    final boolean isJpaPositionalParam=sourceParam.isJpaPositionalParameter();
    final String paramPrefix=isJpaPositionalParam ? ""?"" : ParserHelper.HQL_VARIABLE_PREFIX;
    final String placeholder=paramPrefix + sourceParam.getName();
    final int loc=queryString.indexOf(placeholder);
    if (loc < 0) {
      continue;
    }
    final String beforePlaceholder=queryString.substring(0,loc);
    final String afterPlaceholder=queryString.substring(loc + placeholder.length());
    boolean isEnclosedInParens=StringHelper.getLastNonWhitespaceCharacter(beforePlaceholder) == '(' && StringHelper.getFirstNonWhitespaceCharacter(afterPlaceholder) == ')';
    if (bindValues.size() == 1 && isEnclosedInParens) {
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValues.iterator().next());
      parameterBindingMap.put(sourceParam,syntheticBinding);
      continue;
    }
    StringBuilder expansionList=new StringBuilder();
    int i=0;
    for (    Object bindValue : entry.getValue().getBindValues()) {
      final String syntheticName=(isJpaPositionalParam ? 'x' : """") + sourceParam.getName() + '_'+ i;
      if (i > 0) {
        expansionList.append("", "");
      }
      expansionList.append(ParserHelper.HQL_VARIABLE_PREFIX).append(syntheticName);
      final QueryParameter syntheticParam=new QueryParameterNamedImpl<>(syntheticName,sourceParam.getSourceLocations(),sourceParam.isJpaPositionalParameter(),sourceParam.getType());
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValue);
      if (parameterBindingMap.put(syntheticParam,syntheticBinding) != null) {
        throw new HibernateException(""Repeated usage of synthetic parameter name ["" + syntheticName + ""] while expanding list parameter."");
      }
      i++;
    }
    queryString=StringHelper.replace(beforePlaceholder,afterPlaceholder,placeholder,expansionList.toString(),true,true);
  }
  return queryString;
}
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-separated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-separated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,JoinType,Criterion)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, using the specified join type.
 * @param associationPath A dot-separated property path
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-separated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-separated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,String,org.hibernate.sql.JoinType,org.hibernate.criterion.Criterion)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Checks to see if the given mode is the same as  {@link #MANUAL}.
 * @param mode The mode to check
 * @return true/false
 * @deprecated Just use equality check against {@link #MANUAL}.  Legacy from beforeQuery this was an enum
 */
@Deprecated public static boolean isManualFlushMode(FlushMode mode){
  return MANUAL.level == mode.level;
}
"
"/** 
 * Access to the delayed entity key
 * @return The delayed entity key
 * @deprecated No Hibernate code currently uses this method
 */
@Deprecated @SuppressWarnings(""UnusedDeclaration"") public EntityKey getDelayedEntityKey(){
  return delayedEntityKey;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Type> collectBindTypes(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindType).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Object> collectBindValues(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindValue).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Type[] collectPositionalBindTypes(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Type[] types=new Type[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    Type type=entry.getValue().getBindType();
    if (type == null) {
      log.debugf(""Binding for positional-parameter [%s] did not define type, using SerializableType"",position);
      type=SerializableType.INSTANCE;
    }
    types[position]=type;
  }
  return types;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Object[] collectPositionalBindValues(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Object[] values=new Object[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    values[position]=entry.getValue().getBindValue();
  }
  return values;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Map<String,TypedValue> collectNamedParameterBindings(){
  Map<String,TypedValue> collectedBindings=new HashMap<>();
  for (  Map.Entry<QueryParameter,QueryParameterBinding> entry : parameterBindingMap.entrySet()) {
    if (entry.getKey().getName() == null) {
      continue;
    }
    Type bindType=entry.getValue().getBindType();
    if (bindType == null) {
      log.debugf(""Binding for named-parameter [%s] did not define type"",entry.getKey().getName());
      bindType=SerializableType.INSTANCE;
    }
    collectedBindings.put(entry.getKey().getName(),new TypedValue(bindType,entry.getValue().getBindValue()));
  }
  return collectedBindings;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(QueryParameter<T> queryParameter){
  QueryParameterListBinding result=parameterListBindingMap.get(queryParameter);
  if (result == null) {
    result=transformQueryParameterBindingToQueryParameterListBinding(queryParameter);
  }
  return result;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(String name){
  final QueryParameter<T> queryParameter=resolveQueryParameter(name);
  return getQueryParameterListBinding(queryParameter);
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public String expandListValuedParameters(String queryString,SharedSessionContractImplementor session){
  if (queryString == null) {
    return null;
  }
  final Dialect dialect=session.getFactory().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect();
  final int inExprLimit=dialect.getInExpressionCountLimit();
  for (  Map.Entry<QueryParameter,QueryParameterListBinding> entry : parameterListBindingMap.entrySet()) {
    final NamedParameterDescriptor sourceParam=(NamedParameterDescriptor)entry.getKey();
    final Collection bindValues=entry.getValue().getBindValues();
    if (inExprLimit > 0 && bindValues.size() > inExprLimit) {
      log.tooManyInExpressions(dialect.getClass().getName(),inExprLimit,sourceParam.getName(),bindValues.size());
    }
    final boolean isJpaPositionalParam=sourceParam.isJpaPositionalParameter();
    final String paramPrefix=isJpaPositionalParam ? ""?"" : ParserHelper.HQL_VARIABLE_PREFIX;
    final String placeholder=paramPrefix + sourceParam.getName();
    final int loc=queryString.indexOf(placeholder);
    if (loc < 0) {
      continue;
    }
    final String beforePlaceholder=queryString.substring(0,loc);
    final String afterPlaceholder=queryString.substring(loc + placeholder.length());
    boolean isEnclosedInParens=StringHelper.getLastNonWhitespaceCharacter(beforePlaceholder) == '(' && StringHelper.getFirstNonWhitespaceCharacter(afterPlaceholder) == ')';
    if (bindValues.size() == 1 && isEnclosedInParens) {
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValues.iterator().next());
      parameterBindingMap.put(sourceParam,syntheticBinding);
      continue;
    }
    StringBuilder expansionList=new StringBuilder();
    int i=0;
    for (    Object bindValue : entry.getValue().getBindValues()) {
      final String syntheticName=(isJpaPositionalParam ? 'x' : """") + sourceParam.getName() + '_'+ i;
      if (i > 0) {
        expansionList.append("", "");
      }
      expansionList.append(ParserHelper.HQL_VARIABLE_PREFIX).append(syntheticName);
      final QueryParameter syntheticParam=new QueryParameterNamedImpl<>(syntheticName,sourceParam.getSourceLocations(),sourceParam.isJpaPositionalParameter(),sourceParam.getType());
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValue);
      if (parameterBindingMap.put(syntheticParam,syntheticBinding) != null) {
        throw new HibernateException(""Repeated usage of synthetic parameter name ["" + syntheticName + ""] while expanding list parameter."");
      }
      i++;
    }
    queryString=StringHelper.replace(beforePlaceholder,afterPlaceholder,placeholder,expansionList.toString(),true,true);
  }
  return queryString;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Type> collectBindTypes(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindType).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Object> collectBindValues(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindValue).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Type[] collectPositionalBindTypes(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Type[] types=new Type[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    Type type=entry.getValue().getBindType();
    if (type == null) {
      log.debugf(""Binding for positional-parameter [%s] did not define type, using SerializableType"",position);
      type=SerializableType.INSTANCE;
    }
    types[position]=type;
  }
  return types;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Object[] collectPositionalBindValues(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Object[] values=new Object[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    values[position]=entry.getValue().getBindValue();
  }
  return values;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Map<String,TypedValue> collectNamedParameterBindings(){
  Map<String,TypedValue> collectedBindings=new HashMap<>();
  for (  Map.Entry<QueryParameter,QueryParameterBinding> entry : parameterBindingMap.entrySet()) {
    if (entry.getKey().getName() == null) {
      continue;
    }
    Type bindType=entry.getValue().getBindType();
    if (bindType == null) {
      log.debugf(""Binding for named-parameter [%s] did not define type"",entry.getKey().getName());
      bindType=SerializableType.INSTANCE;
    }
    collectedBindings.put(entry.getKey().getName(),new TypedValue(bindType,entry.getValue().getBindValue()));
  }
  return collectedBindings;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(QueryParameter<T> queryParameter){
  QueryParameterListBinding result=parameterListBindingMap.get(queryParameter);
  if (result == null) {
    result=transformQueryParameterBindingToQueryParameterListBinding(queryParameter);
  }
  return result;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(String name){
  final QueryParameter<T> queryParameter=resolveQueryParameter(name);
  return getQueryParameterListBinding(queryParameter);
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public String expandListValuedParameters(String queryString,SharedSessionContractImplementor session){
  if (queryString == null) {
    return null;
  }
  final Dialect dialect=session.getFactory().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect();
  final int inExprLimit=dialect.getInExpressionCountLimit();
  for (  Map.Entry<QueryParameter,QueryParameterListBinding> entry : parameterListBindingMap.entrySet()) {
    final NamedParameterDescriptor sourceParam=(NamedParameterDescriptor)entry.getKey();
    final Collection bindValues=entry.getValue().getBindValues();
    if (inExprLimit > 0 && bindValues.size() > inExprLimit) {
      log.tooManyInExpressions(dialect.getClass().getName(),inExprLimit,sourceParam.getName(),bindValues.size());
    }
    final boolean isJpaPositionalParam=sourceParam.isJpaPositionalParameter();
    final String paramPrefix=isJpaPositionalParam ? ""?"" : ParserHelper.HQL_VARIABLE_PREFIX;
    final String placeholder=paramPrefix + sourceParam.getName();
    final int loc=queryString.indexOf(placeholder);
    if (loc < 0) {
      continue;
    }
    final String beforePlaceholder=queryString.substring(0,loc);
    final String afterPlaceholder=queryString.substring(loc + placeholder.length());
    boolean isEnclosedInParens=StringHelper.getLastNonWhitespaceCharacter(beforePlaceholder) == '(' && StringHelper.getFirstNonWhitespaceCharacter(afterPlaceholder) == ')';
    if (bindValues.size() == 1 && isEnclosedInParens) {
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValues.iterator().next());
      parameterBindingMap.put(sourceParam,syntheticBinding);
      continue;
    }
    StringBuilder expansionList=new StringBuilder();
    int i=0;
    for (    Object bindValue : entry.getValue().getBindValues()) {
      final String syntheticName=(isJpaPositionalParam ? 'x' : """") + sourceParam.getName() + '_'+ i;
      if (i > 0) {
        expansionList.append("", "");
      }
      expansionList.append(ParserHelper.HQL_VARIABLE_PREFIX).append(syntheticName);
      final QueryParameter syntheticParam=new QueryParameterNamedImpl<>(syntheticName,sourceParam.getSourceLocations(),sourceParam.isJpaPositionalParameter(),sourceParam.getType());
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValue);
      if (parameterBindingMap.put(syntheticParam,syntheticBinding) != null) {
        throw new HibernateException(""Repeated usage of synthetic parameter name ["" + syntheticName + ""] while expanding list parameter."");
      }
      i++;
    }
    queryString=StringHelper.replace(beforePlaceholder,afterPlaceholder,placeholder,expansionList.toString(),true,true);
  }
  return queryString;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
  return this;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public void add(XmlDocument metadataXml){
}
"
"/** 
 * @deprecated No longer supported
 */
@Deprecated public Configuration addXML(String xml) throws MappingException {
  return this;
}
"
"/** 
 * Read mappings from a DOM <tt>Document</tt>
 * @param doc The DOM document
 * @return this (for method chaining purposes)
 * @throws MappingException Indicates problems reading the DOM or processingthe mapping document.
 * @deprecated Use addURL, addResource, addFile, etc. instead
 */
@Deprecated public Configuration addDocument(org.w3c.dom.Document doc) throws MappingException {
  metadataSources.addDocument(doc);
  return this;
}
"
"/** 
 * @deprecated This form (accepting a ClassLoader) is no longer supported.  Instead, add the ClassLoaderto the ClassLoaderService on the ServiceRegistry associated with this Configuration
 */
@Deprecated public Configuration addResource(String resourceName,ClassLoader classLoader) throws MappingException {
  return addResource(resourceName);
}
"
"/** 
 * @deprecated Does nothing
 */
@Deprecated public void buildMappings(){
}
"
"/** 
 * @deprecated Use {@link ConnectionProviderInitiator#toIsolationNiceName} instead
 */
@Deprecated public static String isolationLevelToString(int isolation){
  return ConnectionProviderInitiator.toIsolationNiceName(isolation);
}
"
"/** 
 * Lol
 * @return duh
 * @deprecated an instance factory method does not make sense
 * @see Projections#projectionList()
 */
@Deprecated public ProjectionList create(){
  return new ProjectionList();
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come beforeQuery other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public AbstractEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,persistenceContext);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a the result-set mapping information is not explicitly  provided in the query definition (i.e., no resultset-mapping used).
 * @param name The name of named query
 * @param query The sql query string
 * @param queryReturns The in-lined query return definitions
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,NativeSQLQueryReturn[] queryReturns,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,null,querySpaces,callable,queryReturns);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a resultset-mapping reference is used.
 * @param name The name of named query
 * @param query The sql query string
 * @param resultSetRef The resultset-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,String resultSetRef,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,resultSetRef,querySpaces,callable,null);
}
"
"/** 
 * Get the mapping from entity instance to entity entry
 * @deprecated Due to the introduction of EntityEntryContext and bytecode enhancement; only valid really forsizing, see  {@link #getNumberOfManagedEntities}.  For iterating the entity/EntityEntry combos, see {@link #reentrantSafeEntityEntries}
 */
@Deprecated public Map getEntityEntries();
"
"/** 
 * @deprecated (snce 6.0) SessionDelegatorBaseImpl should take just one argument, the SessionImplementor.Use the  {@link #SessionDelegatorBaseImpl(SessionImplementor)} form instead
 */
@Deprecated public SessionDelegatorBaseImpl(SessionImplementor delegate,Session session){
  if (delegate == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null delegate object"");
  }
  if (session == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null Session"");
  }
  if (delegate != session) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from different Session/SessionImplementor references"");
  }
  this.delegate=delegate;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Type> collectBindTypes(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindType).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Object> collectBindValues(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindValue).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Type[] collectPositionalBindTypes(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Type[] types=new Type[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    Type type=entry.getValue().getBindType();
    if (type == null) {
      log.debugf(""Binding for positional-parameter [%s] did not define type, using SerializableType"",position);
      type=SerializableType.INSTANCE;
    }
    types[position]=type;
  }
  return types;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Object[] collectPositionalBindValues(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Object[] values=new Object[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    values[position]=entry.getValue().getBindValue();
  }
  return values;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Map<String,TypedValue> collectNamedParameterBindings(){
  Map<String,TypedValue> collectedBindings=new HashMap<>();
  for (  Map.Entry<QueryParameter,QueryParameterBinding> entry : parameterBindingMap.entrySet()) {
    if (entry.getKey().getName() == null) {
      continue;
    }
    Type bindType=entry.getValue().getBindType();
    if (bindType == null) {
      log.debugf(""Binding for named-parameter [%s] did not define type"",entry.getKey().getName());
      bindType=SerializableType.INSTANCE;
    }
    collectedBindings.put(entry.getKey().getName(),new TypedValue(bindType,entry.getValue().getBindValue()));
  }
  return collectedBindings;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(QueryParameter<T> queryParameter){
  QueryParameterListBinding result=parameterListBindingMap.get(queryParameter);
  if (result == null) {
    result=transformQueryParameterBindingToQueryParameterListBinding(queryParameter);
  }
  return result;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(String name){
  final QueryParameter<T> queryParameter=resolveQueryParameter(name);
  return getQueryParameterListBinding(queryParameter);
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public String expandListValuedParameters(String queryString,SharedSessionContractImplementor session){
  if (queryString == null) {
    return null;
  }
  final Dialect dialect=session.getFactory().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect();
  final int inExprLimit=dialect.getInExpressionCountLimit();
  for (  Map.Entry<QueryParameter,QueryParameterListBinding> entry : parameterListBindingMap.entrySet()) {
    final NamedParameterDescriptor sourceParam=(NamedParameterDescriptor)entry.getKey();
    final Collection bindValues=entry.getValue().getBindValues();
    if (inExprLimit > 0 && bindValues.size() > inExprLimit) {
      log.tooManyInExpressions(dialect.getClass().getName(),inExprLimit,sourceParam.getName(),bindValues.size());
    }
    final boolean isJpaPositionalParam=sourceParam.isJpaPositionalParameter();
    final String paramPrefix=isJpaPositionalParam ? ""?"" : ParserHelper.HQL_VARIABLE_PREFIX;
    final String placeholder=paramPrefix + sourceParam.getName();
    final int loc=queryString.indexOf(placeholder);
    if (loc < 0) {
      continue;
    }
    final String beforePlaceholder=queryString.substring(0,loc);
    final String afterPlaceholder=queryString.substring(loc + placeholder.length());
    boolean isEnclosedInParens=StringHelper.getLastNonWhitespaceCharacter(beforePlaceholder) == '(' && StringHelper.getFirstNonWhitespaceCharacter(afterPlaceholder) == ')';
    if (bindValues.size() == 1 && isEnclosedInParens) {
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValues.iterator().next());
      parameterBindingMap.put(sourceParam,syntheticBinding);
      continue;
    }
    StringBuilder expansionList=new StringBuilder();
    int i=0;
    for (    Object bindValue : entry.getValue().getBindValues()) {
      final String syntheticName=(isJpaPositionalParam ? 'x' : """") + sourceParam.getName() + '_'+ i;
      if (i > 0) {
        expansionList.append("", "");
      }
      expansionList.append(ParserHelper.HQL_VARIABLE_PREFIX).append(syntheticName);
      final QueryParameter syntheticParam=new QueryParameterNamedImpl<>(syntheticName,sourceParam.getSourceLocations(),sourceParam.isJpaPositionalParameter(),sourceParam.getType());
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValue);
      if (parameterBindingMap.put(syntheticParam,syntheticBinding) != null) {
        throw new HibernateException(""Repeated usage of synthetic parameter name ["" + syntheticName + ""] while expanding list parameter."");
      }
      i++;
    }
    queryString=StringHelper.replace(beforePlaceholder,afterPlaceholder,placeholder,expansionList.toString(),true,true);
  }
  return queryString;
}
"
"/** 
 * @deprecated (snce 6.0) SessionDelegatorBaseImpl should take just one argument, the SessionImplementor.Use the  {@link #SessionDelegatorBaseImpl(SessionImplementor)} form instead
 */
@Deprecated public SessionDelegatorBaseImpl(SessionImplementor delegate,Session session){
  if (delegate == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null delegate object"");
  }
  if (session == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null Session"");
  }
  if (delegate != session) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from different Session/SessionImplementor references"");
  }
  this.delegate=delegate;
}
"
"/** 
 * Perform resolution of a class name. <p/> Same as  {@link #classForName(String,Class)} except that here we delegate to{@link Class#forName(String)} if the context classloader lookup is unsuccessful.
 * @param name The class name
 * @return The class reference.
 * @throws ClassNotFoundException From {@link Class#forName(String)}.
 * @deprecated Depending on context, either {@link org.hibernate.boot.registry.classloading.spi.ClassLoaderService}or  {@link org.hibernate.boot.spi.ClassLoaderAccess} should be preferred
 */
@Deprecated public static Class classForName(String name) throws ClassNotFoundException {
  try {
    ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
    if (classLoader != null) {
      return classLoader.loadClass(name);
    }
  }
 catch (  Throwable ignore) {
  }
  return Class.forName(name);
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The type
 * @deprecated Use {@link OrdinalParameterDescriptor#getExpectedType()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public Type getOrdinalParameterExpectedType(int position){
  return getOrdinalParameterDescriptor(position).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The source location
 * @deprecated Use {@link OrdinalParameterDescriptor#getSourceLocation()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public int getOrdinalParameterSourceLocation(int position){
  return getOrdinalParameterDescriptor(position).getSourceLocation();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getExpectedType()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public Type getNamedParameterExpectedType(String name){
  return getNamedParameterDescriptor(name).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getSourceLocations()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public int[] getNamedParameterSourceLocations(String name){
  return getNamedParameterDescriptor(name).getSourceLocations();
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Type> collectBindTypes(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindType).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Object> collectBindValues(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindValue).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Type[] collectPositionalBindTypes(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Type[] types=new Type[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    Type type=entry.getValue().getBindType();
    if (type == null) {
      log.debugf(""Binding for positional-parameter [%s] did not define type, using SerializableType"",position);
      type=SerializableType.INSTANCE;
    }
    types[position]=type;
  }
  return types;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Object[] collectPositionalBindValues(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Object[] values=new Object[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    values[position]=entry.getValue().getBindValue();
  }
  return values;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Map<String,TypedValue> collectNamedParameterBindings(){
  Map<String,TypedValue> collectedBindings=new HashMap<>();
  for (  Map.Entry<QueryParameter,QueryParameterBinding> entry : parameterBindingMap.entrySet()) {
    if (entry.getKey().getName() == null) {
      continue;
    }
    Type bindType=entry.getValue().getBindType();
    if (bindType == null) {
      log.debugf(""Binding for named-parameter [%s] did not define type"",entry.getKey().getName());
      bindType=SerializableType.INSTANCE;
    }
    collectedBindings.put(entry.getKey().getName(),new TypedValue(bindType,entry.getValue().getBindValue()));
  }
  return collectedBindings;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(QueryParameter<T> queryParameter){
  QueryParameterListBinding result=parameterListBindingMap.get(queryParameter);
  if (result == null) {
    result=transformQueryParameterBindingToQueryParameterListBinding(queryParameter);
  }
  return result;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(String name){
  final QueryParameter<T> queryParameter=resolveQueryParameter(name);
  return getQueryParameterListBinding(queryParameter);
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public String expandListValuedParameters(String queryString,SharedSessionContractImplementor session){
  if (queryString == null) {
    return null;
  }
  final Dialect dialect=session.getFactory().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect();
  final int inExprLimit=dialect.getInExpressionCountLimit();
  for (  Map.Entry<QueryParameter,QueryParameterListBinding> entry : parameterListBindingMap.entrySet()) {
    final NamedParameterDescriptor sourceParam=(NamedParameterDescriptor)entry.getKey();
    final Collection bindValues=entry.getValue().getBindValues();
    if (inExprLimit > 0 && bindValues.size() > inExprLimit) {
      log.tooManyInExpressions(dialect.getClass().getName(),inExprLimit,sourceParam.getName(),bindValues.size());
    }
    final boolean isJpaPositionalParam=sourceParam.isJpaPositionalParameter();
    final String paramPrefix=isJpaPositionalParam ? ""?"" : ParserHelper.HQL_VARIABLE_PREFIX;
    final String placeholder=paramPrefix + sourceParam.getName();
    final int loc=queryString.indexOf(placeholder);
    if (loc < 0) {
      continue;
    }
    final String beforePlaceholder=queryString.substring(0,loc);
    final String afterPlaceholder=queryString.substring(loc + placeholder.length());
    boolean isEnclosedInParens=StringHelper.getLastNonWhitespaceCharacter(beforePlaceholder) == '(' && StringHelper.getFirstNonWhitespaceCharacter(afterPlaceholder) == ')';
    if (bindValues.size() == 1 && isEnclosedInParens) {
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValues.iterator().next());
      parameterBindingMap.put(sourceParam,syntheticBinding);
      continue;
    }
    StringBuilder expansionList=new StringBuilder();
    int i=0;
    for (    Object bindValue : entry.getValue().getBindValues()) {
      final String syntheticName=(isJpaPositionalParam ? 'x' : """") + sourceParam.getName() + '_'+ i;
      if (i > 0) {
        expansionList.append("", "");
      }
      expansionList.append(ParserHelper.HQL_VARIABLE_PREFIX).append(syntheticName);
      final QueryParameter syntheticParam=new QueryParameterNamedImpl<>(syntheticName,sourceParam.getSourceLocations(),sourceParam.isJpaPositionalParameter(),sourceParam.getType());
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValue);
      if (parameterBindingMap.put(syntheticParam,syntheticBinding) != null) {
        throw new HibernateException(""Repeated usage of synthetic parameter name ["" + syntheticName + ""] while expanding list parameter."");
      }
      i++;
    }
    queryString=StringHelper.replace(beforePlaceholder,afterPlaceholder,placeholder,expansionList.toString(),true,true);
  }
  return queryString;
}
"
"/** 
 * Make this go somewhere else.  These aren't really linked this way anymore.  ScrollableResultSetProcessor is not tied in yet, so not sure yet exactly how that will play out.
 * @deprecated Going away!
 */
@Deprecated public ScrollableResultSetProcessor toOnDemandForm();
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public String getQualifiedName(Dialect dialect,String defaultCatalog,String defaultSchema){
  if (subselect != null) {
    return ""( "" + subselect + "" )"";
  }
  String quotedName=getQuotedName(dialect);
  String usedSchema=schema == null ? defaultSchema : getQuotedSchema(dialect);
  String usedCatalog=catalog == null ? defaultCatalog : getQuotedCatalog(dialect);
  return qualify(usedCatalog,usedSchema,quotedName);
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public static String qualify(String catalog,String schema,String table){
  StringBuilder qualifiedName=new StringBuilder();
  if (catalog != null) {
    qualifiedName.append(catalog).append('.');
  }
  if (schema != null) {
    qualifiedName.append(schema).append('.');
  }
  return qualifiedName.append(table).toString();
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The type
 * @deprecated Use {@link OrdinalParameterDescriptor#getExpectedType()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public Type getOrdinalParameterExpectedType(int position){
  return getOrdinalParameterDescriptor(position).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The source location
 * @deprecated Use {@link OrdinalParameterDescriptor#getSourceLocation()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public int getOrdinalParameterSourceLocation(int position){
  return getOrdinalParameterDescriptor(position).getSourceLocation();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getExpectedType()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public Type getNamedParameterExpectedType(String name){
  return getNamedParameterDescriptor(name).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getSourceLocations()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public int[] getNamedParameterSourceLocations(String name){
  return getNamedParameterDescriptor(name).getSourceLocations();
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Type> collectBindTypes(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindType).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Object> collectBindValues(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindValue).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Type[] collectPositionalBindTypes(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Type[] types=new Type[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    Type type=entry.getValue().getBindType();
    if (type == null) {
      log.debugf(""Binding for positional-parameter [%s] did not define type, using SerializableType"",position);
      type=SerializableType.INSTANCE;
    }
    types[position]=type;
  }
  return types;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Object[] collectPositionalBindValues(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Object[] values=new Object[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    values[position]=entry.getValue().getBindValue();
  }
  return values;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Map<String,TypedValue> collectNamedParameterBindings(){
  Map<String,TypedValue> collectedBindings=new HashMap<>();
  for (  Map.Entry<QueryParameter,QueryParameterBinding> entry : parameterBindingMap.entrySet()) {
    if (entry.getKey().getName() == null) {
      continue;
    }
    Type bindType=entry.getValue().getBindType();
    if (bindType == null) {
      log.debugf(""Binding for named-parameter [%s] did not define type"",entry.getKey().getName());
      bindType=SerializableType.INSTANCE;
    }
    collectedBindings.put(entry.getKey().getName(),new TypedValue(bindType,entry.getValue().getBindValue()));
  }
  return collectedBindings;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(QueryParameter<T> queryParameter){
  QueryParameterListBinding result=parameterListBindingMap.get(queryParameter);
  if (result == null) {
    result=transformQueryParameterBindingToQueryParameterListBinding(queryParameter);
  }
  return result;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(String name){
  final QueryParameter<T> queryParameter=resolveQueryParameter(name);
  return getQueryParameterListBinding(queryParameter);
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public String expandListValuedParameters(String queryString,SharedSessionContractImplementor session){
  if (queryString == null) {
    return null;
  }
  final Dialect dialect=session.getFactory().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect();
  final int inExprLimit=dialect.getInExpressionCountLimit();
  for (  Map.Entry<QueryParameter,QueryParameterListBinding> entry : parameterListBindingMap.entrySet()) {
    final NamedParameterDescriptor sourceParam=(NamedParameterDescriptor)entry.getKey();
    final Collection bindValues=entry.getValue().getBindValues();
    if (inExprLimit > 0 && bindValues.size() > inExprLimit) {
      log.tooManyInExpressions(dialect.getClass().getName(),inExprLimit,sourceParam.getName(),bindValues.size());
    }
    final boolean isJpaPositionalParam=sourceParam.isJpaPositionalParameter();
    final String paramPrefix=isJpaPositionalParam ? ""?"" : ParserHelper.HQL_VARIABLE_PREFIX;
    final String placeholder=paramPrefix + sourceParam.getName();
    final int loc=queryString.indexOf(placeholder);
    if (loc < 0) {
      continue;
    }
    final String beforePlaceholder=queryString.substring(0,loc);
    final String afterPlaceholder=queryString.substring(loc + placeholder.length());
    boolean isEnclosedInParens=StringHelper.getLastNonWhitespaceCharacter(beforePlaceholder) == '(' && StringHelper.getFirstNonWhitespaceCharacter(afterPlaceholder) == ')';
    if (bindValues.size() == 1 && isEnclosedInParens) {
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValues.iterator().next());
      parameterBindingMap.put(sourceParam,syntheticBinding);
      continue;
    }
    StringBuilder expansionList=new StringBuilder();
    int i=0;
    for (    Object bindValue : entry.getValue().getBindValues()) {
      final String syntheticName=(isJpaPositionalParam ? 'x' : """") + sourceParam.getName() + '_'+ i;
      if (i > 0) {
        expansionList.append("", "");
      }
      expansionList.append(ParserHelper.HQL_VARIABLE_PREFIX).append(syntheticName);
      final QueryParameter syntheticParam=new QueryParameterNamedImpl<>(syntheticName,sourceParam.getSourceLocations(),sourceParam.isJpaPositionalParameter(),sourceParam.getType());
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValue);
      if (parameterBindingMap.put(syntheticParam,syntheticBinding) != null) {
        throw new HibernateException(""Repeated usage of synthetic parameter name ["" + syntheticName + ""] while expanding list parameter."");
      }
      i++;
    }
    queryString=StringHelper.replace(beforePlaceholder,afterPlaceholder,placeholder,expansionList.toString(),true,true);
  }
  return queryString;
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The type
 * @deprecated Use {@link OrdinalParameterDescriptor#getExpectedType()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public Type getOrdinalParameterExpectedType(int position){
  return getOrdinalParameterDescriptor(position).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The source location
 * @deprecated Use {@link OrdinalParameterDescriptor#getSourceLocation()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public int getOrdinalParameterSourceLocation(int position){
  return getOrdinalParameterDescriptor(position).getSourceLocation();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getExpectedType()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public Type getNamedParameterExpectedType(String name){
  return getNamedParameterDescriptor(name).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getSourceLocations()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public int[] getNamedParameterSourceLocations(String name){
  return getNamedParameterDescriptor(name).getSourceLocations();
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Type> collectBindTypes(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindType).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Object> collectBindValues(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindValue).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Type[] collectPositionalBindTypes(){
  List<Type> types=new ArrayList<>();
  for (  Map.Entry<QueryParameter,QueryParameterBinding> entry : parameterBindingMap.entrySet()) {
    if (entry.getKey().getPosition() == null) {
      continue;
    }
    Type type=entry.getValue().getBindType();
    types.add(entry.getKey().getPosition(),type);
  }
  return types.toArray(new Type[types.size()]);
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Object[] collectPositionalBindValues(){
  List<Object> values=new ArrayList<>();
  for (  Map.Entry<QueryParameter,QueryParameterBinding> entry : parameterBindingMap.entrySet()) {
    if (entry.getKey().getPosition() == null) {
      continue;
    }
    values.add(entry.getKey().getPosition(),entry.getValue().getBindValue());
  }
  return values.toArray(new Object[values.size()]);
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Map<String,TypedValue> collectNamedParameterBindings(){
  Map<String,TypedValue> collectedBindings=new HashMap<>();
  for (  Map.Entry<QueryParameter,QueryParameterBinding> entry : parameterBindingMap.entrySet()) {
    if (entry.getKey().getName() == null) {
      continue;
    }
    collectedBindings.put(entry.getKey().getName(),new TypedValue(entry.getValue().getBindType(),entry.getValue().getBindValue()));
  }
  return collectedBindings;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(QueryParameter<T> queryParameter){
  QueryParameterListBinding result=parameterListBindingMap.get(queryParameter);
  if (result == null) {
    result=transformQueryParameterBindingToQueryParameterListBinding(queryParameter);
  }
  return result;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(String name){
  final QueryParameter<T> queryParameter=resolveQueryParameter(name);
  return getQueryParameterListBinding(queryParameter);
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public String expandListValuedParameters(String queryString,SharedSessionContractImplementor session){
  if (queryString == null) {
    return null;
  }
  final Dialect dialect=session.getFactory().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect();
  final int inExprLimit=dialect.getInExpressionCountLimit();
  for (  Map.Entry<QueryParameter,QueryParameterListBinding> entry : parameterListBindingMap.entrySet()) {
    final QueryParameterNamedImpl sourceParam=(QueryParameterNamedImpl)entry.getKey();
    final Collection bindValues=entry.getValue().getBindValues();
    if (inExprLimit > 0 && bindValues.size() > inExprLimit) {
      log.tooManyInExpressions(dialect.getClass().getName(),inExprLimit,sourceParam.getName(),bindValues.size());
    }
    final boolean isJpaPositionalParam=sourceParam.isJpaPositionalParameter();
    final String paramPrefix=isJpaPositionalParam ? ""?"" : ParserHelper.HQL_VARIABLE_PREFIX;
    final String placeholder=paramPrefix + sourceParam.getName();
    final int loc=queryString.indexOf(placeholder);
    if (loc < 0) {
      continue;
    }
    final String beforePlaceholder=queryString.substring(0,loc);
    final String afterPlaceholder=queryString.substring(loc + placeholder.length());
    boolean isEnclosedInParens=StringHelper.getLastNonWhitespaceCharacter(beforePlaceholder) == '(' && StringHelper.getFirstNonWhitespaceCharacter(afterPlaceholder) == ')';
    if (bindValues.size() == 1 && isEnclosedInParens) {
      final QueryParameterBinding syntheticBinding=new QueryParameterBindingImpl(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValues.iterator().next());
      parameterBindingMap.put(sourceParam,syntheticBinding);
      continue;
    }
    StringBuilder expansionList=new StringBuilder();
    int i=0;
    for (    Object bindValue : entry.getValue().getBindValues()) {
      final String syntheticName=(isJpaPositionalParam ? 'x' : """") + sourceParam.getName() + '_'+ i;
      if (i > 0) {
        expansionList.append("", "");
      }
      expansionList.append(ParserHelper.HQL_VARIABLE_PREFIX).append(syntheticName);
      final QueryParameter syntheticParam=new QueryParameterNamedImpl<>(syntheticName,sourceParam.getSourceLocations(),sourceParam.isJpaPositionalParameter(),sourceParam.getType());
      final QueryParameterBinding syntheticBinding=new QueryParameterBindingImpl(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValue);
      if (parameterBindingMap.put(syntheticParam,syntheticBinding) != null) {
        throw new HibernateException(""Repeated usage of synthetic parameter name ["" + syntheticName + ""] while expanding list parameter."");
      }
      i++;
    }
    queryString=StringHelper.replace(beforePlaceholder,afterPlaceholder,placeholder,expansionList.toString(),true,true);
  }
  parameterListBindingMap.clear();
  return queryString;
}
"
"/** 
 * Get the current lock mode
 * @return LockMode
 * @deprecated Instead use getLockOptions
 */
@Deprecated public LockMode getLockMode(){
  return lockOptions.getLockMode();
}
"
"/** 
 * Set the lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
@Deprecated public Select setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.<String,SQLFunction>emptyMap()));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #translateOrderBy} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #OneToOneType(TypeFactory.TypeScope,String,ForeignKeyDirection,boolean,String,boolean,boolean,String,String)}instead.
 */
@Deprecated public OneToOneType(TypeFactory.TypeScope scope,String referencedEntityName,ForeignKeyDirection foreignKeyType,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,String entityName,String propertyName){
  this(scope,referencedEntityName,foreignKeyType,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,entityName,propertyName);
}
"
"/** 
 * @deprecated (snce 6.0) SessionDelegatorBaseImpl should take just one argument, the SessionImplementor.Use the  {@link #SessionDelegatorBaseImpl(SessionImplementor)} form instead
 */
@Deprecated public SessionDelegatorBaseImpl(SessionImplementor delegate,Session session){
  if (delegate == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null delegate object"");
  }
  if (session == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null Session"");
  }
  if (delegate != session) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from different Session/SessionImplementor references"");
  }
  this.delegate=delegate;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
  return this;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public void add(XmlDocument metadataXml){
}
"
"/** 
 * @deprecated No longer supported
 */
@Deprecated public Configuration addXML(String xml) throws MappingException {
  return this;
}
"
"/** 
 * Read mappings from a DOM <tt>Document</tt>
 * @param doc The DOM document
 * @return this (for method chaining purposes)
 * @throws MappingException Indicates problems reading the DOM or processingthe mapping document.
 * @deprecated Use addURL, addResource, addFile, etc. instead
 */
@Deprecated public Configuration addDocument(org.w3c.dom.Document doc) throws MappingException {
  metadataSources.addDocument(doc);
  return this;
}
"
"/** 
 * @deprecated This form (accepting a ClassLoader) is no longer supported.  Instead, add the ClassLoaderto the ClassLoaderService on the ServiceRegistry associated with this Configuration
 */
@Deprecated public Configuration addResource(String resourceName,ClassLoader classLoader) throws MappingException {
  return addResource(resourceName);
}
"
"/** 
 * @deprecated Does nothing
 */
@Deprecated public void buildMappings(){
}
"
"/** 
 * @deprecated Use {@link ConnectionProviderInitiator#toIsolationNiceName} instead
 */
@Deprecated public static String isolationLevelToString(int isolation){
  return ConnectionProviderInitiator.toIsolationNiceName(isolation);
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Type> collectBindTypes(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindType).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Object> collectBindValues(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindValue).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Type[] collectPositionalBindTypes(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Type[] types=new Type[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    Type type=entry.getValue().getBindType();
    if (type == null) {
      log.debugf(""Binding for positional-parameter [%s] did not define type, using SerializableType"",position);
      type=SerializableType.INSTANCE;
    }
    types[position]=type;
  }
  return types;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Object[] collectPositionalBindValues(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Object[] values=new Object[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    values[position]=entry.getValue().getBindValue();
  }
  return values;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Map<String,TypedValue> collectNamedParameterBindings(){
  Map<String,TypedValue> collectedBindings=new HashMap<>();
  for (  Map.Entry<QueryParameter,QueryParameterBinding> entry : parameterBindingMap.entrySet()) {
    if (entry.getKey().getName() == null) {
      continue;
    }
    Type bindType=entry.getValue().getBindType();
    if (bindType == null) {
      log.debugf(""Binding for named-parameter [%s] did not define type"",entry.getKey().getName());
      bindType=SerializableType.INSTANCE;
    }
    collectedBindings.put(entry.getKey().getName(),new TypedValue(bindType,entry.getValue().getBindValue()));
  }
  return collectedBindings;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(QueryParameter<T> queryParameter){
  QueryParameterListBinding result=parameterListBindingMap.get(queryParameter);
  if (result == null) {
    result=transformQueryParameterBindingToQueryParameterListBinding(queryParameter);
  }
  return result;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(String name){
  final QueryParameter<T> queryParameter=resolveQueryParameter(name);
  return getQueryParameterListBinding(queryParameter);
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public String expandListValuedParameters(String queryString,SharedSessionContractImplementor session){
  if (queryString == null) {
    return null;
  }
  final Dialect dialect=session.getFactory().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect();
  final int inExprLimit=dialect.getInExpressionCountLimit();
  for (  Map.Entry<QueryParameter,QueryParameterListBinding> entry : parameterListBindingMap.entrySet()) {
    final NamedParameterDescriptor sourceParam=(NamedParameterDescriptor)entry.getKey();
    final Collection bindValues=entry.getValue().getBindValues();
    if (inExprLimit > 0 && bindValues.size() > inExprLimit) {
      log.tooManyInExpressions(dialect.getClass().getName(),inExprLimit,sourceParam.getName(),bindValues.size());
    }
    final boolean isJpaPositionalParam=sourceParam.isJpaPositionalParameter();
    final String paramPrefix=isJpaPositionalParam ? ""?"" : ParserHelper.HQL_VARIABLE_PREFIX;
    final String placeholder=paramPrefix + sourceParam.getName();
    final int loc=queryString.indexOf(placeholder);
    if (loc < 0) {
      continue;
    }
    final String beforePlaceholder=queryString.substring(0,loc);
    final String afterPlaceholder=queryString.substring(loc + placeholder.length());
    boolean isEnclosedInParens=StringHelper.getLastNonWhitespaceCharacter(beforePlaceholder) == '(' && StringHelper.getFirstNonWhitespaceCharacter(afterPlaceholder) == ')';
    if (bindValues.size() == 1 && isEnclosedInParens) {
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValues.iterator().next());
      parameterBindingMap.put(sourceParam,syntheticBinding);
      continue;
    }
    StringBuilder expansionList=new StringBuilder();
    int i=0;
    for (    Object bindValue : entry.getValue().getBindValues()) {
      final String syntheticName=(isJpaPositionalParam ? 'x' : """") + sourceParam.getName() + '_'+ i;
      if (i > 0) {
        expansionList.append("", "");
      }
      expansionList.append(ParserHelper.HQL_VARIABLE_PREFIX).append(syntheticName);
      final QueryParameter syntheticParam=new QueryParameterNamedImpl<>(syntheticName,sourceParam.getSourceLocations(),sourceParam.isJpaPositionalParameter(),sourceParam.getType());
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValue);
      if (parameterBindingMap.put(syntheticParam,syntheticBinding) != null) {
        throw new HibernateException(""Repeated usage of synthetic parameter name ["" + syntheticName + ""] while expanding list parameter."");
      }
      i++;
    }
    queryString=StringHelper.replace(beforePlaceholder,afterPlaceholder,placeholder,expansionList.toString(),true,true);
  }
  parameterListBindingMap.clear();
  return queryString;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come beforeQuery other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come beforeQuery other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated (since 5.2), use {@link EqualsHelper#areEqual(Object,Object)}.
 */
@Deprecated public static boolean objectsEqual(Object obj1,Object obj2){
  return EqualsHelper.areEqual(obj1,obj2);
}
"
"/** 
 * @deprecated (since 5.2), use {@link EqualsHelper#areEqual(Object,Object)}.
 */
@Deprecated public static boolean objectsEqual(Object obj1,Object obj2){
  return EqualsHelper.areEqual(obj1,obj2);
}
"
"/** 
 * @deprecated (since 5.2), use {@link EqualsHelper#areEqual(Object,Object)}.
 */
@Deprecated public static boolean objectsEqual(Object obj1,Object obj2){
  return EqualsHelper.areEqual(obj1,obj2);
}
"
"/** 
 * @deprecated (snce 6.0) SessionDelegatorBaseImpl should take just one argument, the SessionImplementor.Use the  {@link #SessionDelegatorBaseImpl(SessionImplementor)} form instead
 */
@Deprecated public SessionDelegatorBaseImpl(SessionImplementor delegate,Session session){
  if (delegate == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null delegate object"");
  }
  if (session == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null Session"");
  }
  if (delegate != session) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from different Session/SessionImplementor references"");
  }
  this.delegate=delegate;
}
"
"/** 
 * @deprecated (since 5.2), use {@link EqualsHelper#areEqual(Object,Object)}.
 */
@Deprecated public static boolean objectsEqual(Object obj1,Object obj2){
  return EqualsHelper.areEqual(obj1,obj2);
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
@Deprecated public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public AbstractEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,persistenceContext);
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public AbstractEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,persistenceContext);
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come beforeQuery other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.<String,SQLFunction>emptyMap()));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #translateOrderBy} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * @deprecated (snce 6.0) SessionDelegatorBaseImpl should take just one argument, the SessionImplementor.Use the  {@link #SessionDelegatorBaseImpl(SessionImplementor)} form instead
 */
@Deprecated public SessionDelegatorBaseImpl(SessionImplementor delegate,Session session){
  if (delegate == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null delegate object"");
  }
  if (session == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null Session"");
  }
  if (delegate != session) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from different Session/SessionImplementor references"");
  }
  this.delegate=delegate;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come beforeQuery other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
@Deprecated public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public String getQualifiedName(Dialect dialect,String defaultCatalog,String defaultSchema){
  if (subselect != null) {
    return ""( "" + subselect + "" )"";
  }
  String quotedName=getQuotedName(dialect);
  String usedSchema=schema == null ? defaultSchema : getQuotedSchema(dialect);
  String usedCatalog=catalog == null ? defaultCatalog : getQuotedCatalog(dialect);
  return qualify(usedCatalog,usedSchema,quotedName);
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public static String qualify(String catalog,String schema,String table){
  StringBuilder qualifiedName=new StringBuilder();
  if (catalog != null) {
    qualifiedName.append(catalog).append('.');
  }
  if (schema != null) {
    qualifiedName.append(schema).append('.');
  }
  return qualifiedName.append(table).toString();
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come beforeQuery other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public String getQualifiedName(Dialect dialect,String defaultCatalog,String defaultSchema){
  if (subselect != null) {
    return ""( "" + subselect + "" )"";
  }
  String quotedName=getQuotedName(dialect);
  String usedSchema=schema == null ? defaultSchema : getQuotedSchema(dialect);
  String usedCatalog=catalog == null ? defaultCatalog : getQuotedCatalog(dialect);
  return qualify(usedCatalog,usedSchema,quotedName);
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public static String qualify(String catalog,String schema,String table){
  StringBuilder qualifiedName=new StringBuilder();
  if (catalog != null) {
    qualifiedName.append(catalog).append('.');
  }
  if (schema != null) {
    qualifiedName.append(schema).append('.');
  }
  return qualifiedName.append(table).toString();
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated() public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated() public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated() public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come beforeQuery other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated (snce 6.0) SessionDelegatorBaseImpl should take just one argument, the SessionImplementor.Use the  {@link #SessionDelegatorBaseImpl(SessionImplementor)} form instead
 */
@Deprecated public SessionDelegatorBaseImpl(SessionImplementor delegate,Session session){
  if (delegate == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null delegate object"");
  }
  if (session == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null Session"");
  }
  if (delegate != session) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from different Session/SessionImplementor references"");
  }
  this.delegate=delegate;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come beforeQuery other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * Does this dialect support identity column key generation?
 * @return True if IDENTITY columns are supported; false otherwise.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().supportsIdentityColumns()} does not delegateto this method, then this method is ignored.
 */
@Deprecated public boolean supportsIdentityColumns(){
  return false;
}
"
"/** 
 * Does the dialect support some form of inserting and selecting the generated IDENTITY value all in the same statement.
 * @return True if the dialect supports selecting the justgenerated IDENTITY in the insert statement.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().supportsInsertSelectIdentity()} does not delegateto this method, then this method is ignored.
 */
@Deprecated public boolean supportsInsertSelectIdentity(){
  return false;
}
"
"/** 
 * Whether this dialect have an Identity clause added to the data type or a completely separate identity data type
 * @return boolean
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().hasDataTypeInIdentityColumn()} does not delegateto this method, then this method is ignored.
 */
@Deprecated public boolean hasDataTypeInIdentityColumn(){
  return true;
}
"
"/** 
 * Provided we  {@link #supportsInsertSelectIdentity}, then attach the ""select identity"" clause to the  insert statement. <p/> Note, if  {@link #supportsInsertSelectIdentity} == false thenthe insert-string should be returned without modification.
 * @param insertString The insert command
 * @return The insert command with any necessary identity selectclause attached.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().appendIdentitySelectToInsert(String)} does not delegateto this method, then this method is ignored.
 */
@Deprecated public String appendIdentitySelectToInsert(String insertString){
  return insertString;
}
"
"/** 
 * Get the select command to use to retrieve the last generated IDENTITY value for a particular table
 * @param table The table into which the insert was done
 * @param column The PK column.
 * @param type The {@link java.sql.Types} type code.
 * @return The appropriate select command
 * @throws MappingException If IDENTITY generation is not supported.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().getIdentitySelectString(String,String,int)} does not delegateto this method, then this method is ignored.
 */
@Deprecated public String getIdentitySelectString(String table,String column,int type) throws MappingException {
  return getIdentitySelectString();
}
"
"/** 
 * The syntax used during DDL to define a column as being an IDENTITY of a particular type.
 * @param type The {@link java.sql.Types} type code.
 * @return The appropriate DDL fragment.
 * @throws MappingException If IDENTITY generation is not supported.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().getIdentityColumnString(int)} does not delegateto this method, then this method is ignored.
 */
@Deprecated public String getIdentityColumnString(int type) throws MappingException {
  return getIdentityColumnString();
}
"
"/** 
 * The keyword used to insert a generated value into an identity column (or null). Need if the dialect does not support inserts that specify no column values.
 * @return The appropriate keyword.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().getIdentityInsertString()} does not delegateto this method, then this method is ignored.
 */
@Deprecated public String getIdentityInsertString(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come beforeQuery other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come beforeQuery other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Some dialects have trouble applying pessimistic locking depending upon what other query options are specified (paging, ordering, etc).  This method allows these dialects to request that locking be applied by subsequent selects.
 * @return {@code true} indicates that the dialect requests that locking be applied by subsequent select;{@code false} (the default) indicates that locking should be applied to the main SQL statement..
 * @deprecated Use {@link #useFollowOnLocking(QueryParameters)} instead.
 */
@Deprecated public boolean useFollowOnLocking(){
  return useFollowOnLocking(null);
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come beforeQuery other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Some dialects have trouble applying pessimistic locking depending upon what other query options are specified (paging, ordering, etc).  This method allows these dialects to request that locking be applied by subsequent selects.
 * @return {@code true} indicates that the dialect requests that locking be applied by subsequent select;{@code false} (the default) indicates that locking should be applied to the main SQL statement..
 * @deprecated Use {@link #useFollowOnLocking(QueryParameters)} instead.
 */
@Deprecated public boolean useFollowOnLocking(){
  return useFollowOnLocking(null);
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The class (which implements  {@link org.hibernate.id.IdentifierGenerator}) which acts as this dialects native generation strategy. <p/> Comes into play whenever the user specifies the native generator.
 * @return The native generator class.
 * @deprecated use {@link #getNativeIdentifierGeneratorStrategy()} instead
 */
@Deprecated public Class getNativeIdentifierGeneratorClass(){
  if (getIdentityColumnSupport().supportsIdentityColumns()) {
    return IdentityGenerator.class;
  }
 else {
    return SequenceStyleGenerator.class;
  }
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come beforeQuery other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Some dialects have trouble applying pessimistic locking depending upon what other query options are specified (paging, ordering, etc).  This method allows these dialects to request that locking be applied by subsequent selects.
 * @return {@code true} indicates that the dialect requests that locking be applied by subsequent select;{@code false} (the default) indicates that locking should be applied to the main SQL statement..
 * @deprecated Use {@link #useFollowOnLocking(QueryParameters)} instead.
 */
@Deprecated public boolean useFollowOnLocking(){
  return useFollowOnLocking(null);
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public AbstractEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,persistenceContext);
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Type> collectBindTypes(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindType).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Object> collectBindValues(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindValue).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Type[] collectPositionalBindTypes(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Type[] types=new Type[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    Type type=entry.getValue().getBindType();
    if (type == null) {
      log.debugf(""Binding for positional-parameter [%s] did not define type, using SerializableType"",position);
      type=SerializableType.INSTANCE;
    }
    types[position]=type;
  }
  return types;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Object[] collectPositionalBindValues(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Object[] values=new Object[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    values[position]=entry.getValue().getBindValue();
  }
  return values;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Map<String,TypedValue> collectNamedParameterBindings(){
  Map<String,TypedValue> collectedBindings=new HashMap<>();
  for (  Map.Entry<QueryParameter,QueryParameterBinding> entry : parameterBindingMap.entrySet()) {
    if (entry.getKey().getName() == null) {
      continue;
    }
    Type bindType=entry.getValue().getBindType();
    if (bindType == null) {
      log.debugf(""Binding for named-parameter [%s] did not define type"",entry.getKey().getName());
      bindType=SerializableType.INSTANCE;
    }
    collectedBindings.put(entry.getKey().getName(),new TypedValue(bindType,entry.getValue().getBindValue()));
  }
  return collectedBindings;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(QueryParameter<T> queryParameter){
  QueryParameterListBinding result=parameterListBindingMap.get(queryParameter);
  if (result == null) {
    result=transformQueryParameterBindingToQueryParameterListBinding(queryParameter);
  }
  return result;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(String name){
  final QueryParameter<T> queryParameter=resolveQueryParameter(name);
  return getQueryParameterListBinding(queryParameter);
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public String expandListValuedParameters(String queryString,SharedSessionContractImplementor session){
  if (queryString == null) {
    return null;
  }
  final Dialect dialect=session.getFactory().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect();
  final int inExprLimit=dialect.getInExpressionCountLimit();
  for (  Map.Entry<QueryParameter,QueryParameterListBinding> entry : parameterListBindingMap.entrySet()) {
    final NamedParameterDescriptor sourceParam=(NamedParameterDescriptor)entry.getKey();
    final Collection bindValues=entry.getValue().getBindValues();
    if (inExprLimit > 0 && bindValues.size() > inExprLimit) {
      log.tooManyInExpressions(dialect.getClass().getName(),inExprLimit,sourceParam.getName(),bindValues.size());
    }
    final boolean isJpaPositionalParam=sourceParam.isJpaPositionalParameter();
    final String paramPrefix=isJpaPositionalParam ? ""?"" : ParserHelper.HQL_VARIABLE_PREFIX;
    final String placeholder=paramPrefix + sourceParam.getName();
    final int loc=queryString.indexOf(placeholder);
    if (loc < 0) {
      continue;
    }
    final String beforePlaceholder=queryString.substring(0,loc);
    final String afterPlaceholder=queryString.substring(loc + placeholder.length());
    boolean isEnclosedInParens=StringHelper.getLastNonWhitespaceCharacter(beforePlaceholder) == '(' && StringHelper.getFirstNonWhitespaceCharacter(afterPlaceholder) == ')';
    if (bindValues.size() == 1 && isEnclosedInParens) {
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValues.iterator().next());
      parameterBindingMap.put(sourceParam,syntheticBinding);
      continue;
    }
    StringBuilder expansionList=new StringBuilder();
    int i=0;
    for (    Object bindValue : entry.getValue().getBindValues()) {
      final String syntheticName=(isJpaPositionalParam ? 'x' : """") + sourceParam.getName() + '_'+ i;
      if (i > 0) {
        expansionList.append("", "");
      }
      expansionList.append(ParserHelper.HQL_VARIABLE_PREFIX).append(syntheticName);
      final QueryParameter syntheticParam=new QueryParameterNamedImpl<>(syntheticName,sourceParam.getSourceLocations(),sourceParam.isJpaPositionalParameter(),sourceParam.getType());
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValue);
      parameterBindingMap.put(syntheticParam,syntheticBinding);
      i++;
    }
    queryString=StringHelper.replace(beforePlaceholder,afterPlaceholder,placeholder,expansionList.toString(),true,true);
  }
  return queryString;
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The type
 * @deprecated Use {@link OrdinalParameterDescriptor#getExpectedType()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public Type getOrdinalParameterExpectedType(int position){
  return getOrdinalParameterDescriptor(position).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The source location
 * @deprecated Use {@link OrdinalParameterDescriptor#getSourceLocation()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public int getOrdinalParameterSourceLocation(int position){
  return getOrdinalParameterDescriptor(position).getSourceLocation();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getExpectedType()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public Type getNamedParameterExpectedType(String name){
  return getNamedParameterDescriptor(name).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getSourceLocations()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public int[] getNamedParameterSourceLocations(String name){
  return getNamedParameterDescriptor(name).getSourceLocations();
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Type> collectBindTypes(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindType).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Object> collectBindValues(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindValue).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Type[] collectPositionalBindTypes(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Type[] types=new Type[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    Type type=entry.getValue().getBindType();
    if (type == null) {
      log.debugf(""Binding for positional-parameter [%s] did not define type, using SerializableType"",position);
      type=SerializableType.INSTANCE;
    }
    types[position]=type;
  }
  return types;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Object[] collectPositionalBindValues(){
  TreeMap<Integer,QueryParameterBinding> positionalParameterBindingMap=collectPositionalParameterBindings();
  Object[] values=new Object[positionalParameterBindingMap.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindingMap.entrySet()) {
    final int position=entry.getKey();
    values[position]=entry.getValue().getBindValue();
  }
  return values;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Map<String,TypedValue> collectNamedParameterBindings(){
  Map<String,TypedValue> collectedBindings=new HashMap<>();
  for (  Map.Entry<QueryParameter,QueryParameterBinding> entry : parameterBindingMap.entrySet()) {
    if (entry.getKey().getName() == null) {
      continue;
    }
    Type bindType=entry.getValue().getBindType();
    if (bindType == null) {
      log.debugf(""Binding for named-parameter [%s] did not define type"",entry.getKey().getName());
      bindType=SerializableType.INSTANCE;
    }
    collectedBindings.put(entry.getKey().getName(),new TypedValue(bindType,entry.getValue().getBindValue()));
  }
  return collectedBindings;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(QueryParameter<T> queryParameter){
  QueryParameterListBinding result=parameterListBindingMap.get(queryParameter);
  if (result == null) {
    result=transformQueryParameterBindingToQueryParameterListBinding(queryParameter);
  }
  return result;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(String name){
  final QueryParameter<T> queryParameter=resolveQueryParameter(name);
  return getQueryParameterListBinding(queryParameter);
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public String expandListValuedParameters(String queryString,SharedSessionContractImplementor session){
  if (queryString == null) {
    return null;
  }
  final Dialect dialect=session.getFactory().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect();
  final int inExprLimit=dialect.getInExpressionCountLimit();
  for (  Map.Entry<QueryParameter,QueryParameterListBinding> entry : parameterListBindingMap.entrySet()) {
    final NamedParameterDescriptor sourceParam=(NamedParameterDescriptor)entry.getKey();
    final Collection bindValues=entry.getValue().getBindValues();
    if (inExprLimit > 0 && bindValues.size() > inExprLimit) {
      log.tooManyInExpressions(dialect.getClass().getName(),inExprLimit,sourceParam.getName(),bindValues.size());
    }
    final boolean isJpaPositionalParam=sourceParam.isJpaPositionalParameter();
    final String paramPrefix=isJpaPositionalParam ? ""?"" : ParserHelper.HQL_VARIABLE_PREFIX;
    final String placeholder=paramPrefix + sourceParam.getName();
    final int loc=queryString.indexOf(placeholder);
    if (loc < 0) {
      continue;
    }
    final String beforePlaceholder=queryString.substring(0,loc);
    final String afterPlaceholder=queryString.substring(loc + placeholder.length());
    boolean isEnclosedInParens=StringHelper.getLastNonWhitespaceCharacter(beforePlaceholder) == '(' && StringHelper.getFirstNonWhitespaceCharacter(afterPlaceholder) == ')';
    if (bindValues.size() == 1 && isEnclosedInParens) {
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValues.iterator().next());
      parameterBindingMap.put(sourceParam,syntheticBinding);
      continue;
    }
    StringBuilder expansionList=new StringBuilder();
    int i=0;
    for (    Object bindValue : entry.getValue().getBindValues()) {
      final String syntheticName=(isJpaPositionalParam ? 'x' : """") + sourceParam.getName() + '_'+ i;
      if (i > 0) {
        expansionList.append("", "");
      }
      expansionList.append(ParserHelper.HQL_VARIABLE_PREFIX).append(syntheticName);
      final QueryParameter syntheticParam=new QueryParameterNamedImpl<>(syntheticName,sourceParam.getSourceLocations(),sourceParam.isJpaPositionalParameter(),sourceParam.getType());
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValue);
      parameterBindingMap.put(syntheticParam,syntheticBinding);
      i++;
    }
    queryString=StringHelper.replace(beforePlaceholder,afterPlaceholder,placeholder,expansionList.toString(),true,true);
  }
  return queryString;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Type> collectBindTypes(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindType).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Object> collectBindValues(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindValue).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Type[] collectPositionalBindTypes(){
  Type[] types=new Type[positionalParameterBindings.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindings.entrySet()) {
    final int position=entry.getKey();
    Type type=entry.getValue().getBindType();
    if (type == null) {
      log.debugf(""Binding for positional-parameter [%s] did not define type, using SerializableType"",position);
      type=SerializableType.INSTANCE;
    }
    types[position]=type;
  }
  return types;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Object[] collectPositionalBindValues(){
  Object[] values=new Object[positionalParameterBindings.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindings.entrySet()) {
    final int position=entry.getKey();
    values[position]=entry.getValue().getBindValue();
  }
  return values;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Map<String,TypedValue> collectNamedParameterBindings(){
  Map<String,TypedValue> collectedBindings=new HashMap<>();
  for (  Map.Entry<QueryParameter,QueryParameterBinding> entry : parameterBindingMap.entrySet()) {
    if (entry.getKey().getName() == null) {
      continue;
    }
    Type bindType=entry.getValue().getBindType();
    if (bindType == null) {
      log.debugf(""Binding for named-parameter [%s] did not define type"",entry.getKey().getName());
      bindType=SerializableType.INSTANCE;
    }
    collectedBindings.put(entry.getKey().getName(),new TypedValue(bindType,entry.getValue().getBindValue()));
  }
  return collectedBindings;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(QueryParameter<T> queryParameter){
  QueryParameterListBinding result=parameterListBindingMap.get(queryParameter);
  if (result == null) {
    result=transformQueryParameterBindingToQueryParameterListBinding(queryParameter);
  }
  return result;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(String name){
  final QueryParameter<T> queryParameter=resolveQueryParameter(name);
  return getQueryParameterListBinding(queryParameter);
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public String expandListValuedParameters(String queryString,SharedSessionContractImplementor session){
  if (queryString == null) {
    return null;
  }
  final Dialect dialect=session.getFactory().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect();
  final int inExprLimit=dialect.getInExpressionCountLimit();
  for (  Map.Entry<QueryParameter,QueryParameterListBinding> entry : parameterListBindingMap.entrySet()) {
    final NamedParameterDescriptor sourceParam=(NamedParameterDescriptor)entry.getKey();
    final Collection bindValues=entry.getValue().getBindValues();
    if (inExprLimit > 0 && bindValues.size() > inExprLimit) {
      log.tooManyInExpressions(dialect.getClass().getName(),inExprLimit,sourceParam.getName(),bindValues.size());
    }
    final boolean isJpaPositionalParam=sourceParam.isJpaPositionalParameter();
    final String paramPrefix=isJpaPositionalParam ? ""?"" : ParserHelper.HQL_VARIABLE_PREFIX;
    final String placeholder=paramPrefix + sourceParam.getName();
    final int loc=queryString.indexOf(placeholder);
    if (loc < 0) {
      continue;
    }
    final String beforePlaceholder=queryString.substring(0,loc);
    final String afterPlaceholder=queryString.substring(loc + placeholder.length());
    boolean isEnclosedInParens=StringHelper.getLastNonWhitespaceCharacter(beforePlaceholder) == '(' && StringHelper.getFirstNonWhitespaceCharacter(afterPlaceholder) == ')';
    if (bindValues.size() == 1 && isEnclosedInParens) {
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValues.iterator().next());
      parameterBindingMap.put(sourceParam,syntheticBinding);
      continue;
    }
    StringBuilder expansionList=new StringBuilder();
    int i=0;
    for (    Object bindValue : entry.getValue().getBindValues()) {
      final String syntheticName=(isJpaPositionalParam ? 'x' : """") + sourceParam.getName() + '_'+ i;
      if (i > 0) {
        expansionList.append("", "");
      }
      expansionList.append(ParserHelper.HQL_VARIABLE_PREFIX).append(syntheticName);
      final QueryParameter syntheticParam=new QueryParameterNamedImpl<>(syntheticName,sourceParam.getSourceLocations(),sourceParam.isJpaPositionalParameter(),sourceParam.getType());
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValue);
      parameterBindingMap.put(syntheticParam,syntheticBinding);
      i++;
    }
    queryString=StringHelper.replace(beforePlaceholder,afterPlaceholder,placeholder,expansionList.toString(),true,true);
  }
  return queryString;
}
"
"/** 
 * Perform resolution of a class name. <p/> Same as  {@link #classForName(String,Class)} except that here we delegate to{@link Class#forName(String)} if the context classloader lookup is unsuccessful.
 * @param name The class name
 * @return The class reference.
 * @throws ClassNotFoundException From {@link Class#forName(String)}.
 * @deprecated Depending on context, either {@link org.hibernate.boot.registry.classloading.spi.ClassLoaderService}or  {@link org.hibernate.boot.spi.ClassLoaderAccess} should be preferred
 */
@Deprecated public static Class classForName(String name) throws ClassNotFoundException {
  try {
    ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
    if (classLoader != null) {
      return classLoader.loadClass(name);
    }
  }
 catch (  Throwable ignore) {
  }
  return Class.forName(name);
}
"
"/** 
 * Perform resolution of a class name. <p/> Same as  {@link #classForName(String,Class)} except that here we delegate to{@link Class#forName(String)} if the context classloader lookup is unsuccessful.
 * @param name The class name
 * @return The class reference.
 * @throws ClassNotFoundException From {@link Class#forName(String)}.
 * @deprecated Depending on context, either {@link org.hibernate.boot.registry.classloading.spi.ClassLoaderService}or  {@link org.hibernate.boot.spi.ClassLoaderAccess} should be preferred
 */
@Deprecated public static Class classForName(String name) throws ClassNotFoundException {
  try {
    ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
    if (classLoader != null) {
      return classLoader.loadClass(name);
    }
  }
 catch (  Throwable ignore) {
  }
  return Class.forName(name);
}
"
"/** 
 * Generate an initial version.
 * @param session The session from which this request originates.
 * @return an instance of the type
 * @deprecated use {@link RowVersionType} for binary entity versions/timestamps
 */
@Override @Deprecated public byte[] seed(SharedSessionContractImplementor session){
  return null;
}
"
"/** 
 * Increment the version.
 * @param session The session from which this request originates.
 * @param current the current version
 * @return an instance of the type
 * @deprecated use {@link RowVersionType} for binary entity versions/timestamps
 */
@Override @Deprecated public byte[] next(byte[] current,SharedSessionContractImplementor session){
  return current;
}
"
"/** 
 * Get a comparator for version values.
 * @return The comparator to use to compare different version values.
 * @deprecated use {@link RowVersionType} for binary entity versions/timestamps
 */
@Override @Deprecated public Comparator<byte[]> getComparator(){
  return PrimitiveByteArrayTypeDescriptor.INSTANCE.getComparator();
}
"
"/** 
 * Generate an initial version.
 * @param session The session from which this request originates.
 * @return an instance of the type
 * @deprecated use {@link RowVersionType} for binary entity versions/timestamps
 */
@Override @Deprecated public byte[] seed(SessionImplementor session){
  return null;
}
"
"/** 
 * Increment the version.
 * @param session The session from which this request originates.
 * @param current the current version
 * @return an instance of the type
 * @deprecated use {@link RowVersionType} for binary entity versions/timestamps
 */
@Override @Deprecated public byte[] next(byte[] current,SessionImplementor session){
  return current;
}
"
"/** 
 * Get a comparator for version values.
 * @return The comparator to use to compare different version values.
 * @deprecated use {@link RowVersionType} for binary entity versions/timestamps
 */
@Override @Deprecated public Comparator<byte[]> getComparator(){
  return PrimitiveByteArrayTypeDescriptor.INSTANCE.getComparator();
}
"
"/** 
 * Perform resolution of a class name. <p/> Same as  {@link #classForName(String,Class)} except that here we delegate to{@link Class#forName(String)} if the context classloader lookup is unsuccessful.
 * @param name The class name
 * @return The class reference.
 * @throws ClassNotFoundException From {@link Class#forName(String)}.
 * @deprecated Depending on context, either {@link org.hibernate.boot.registry.classloading.spi.ClassLoaderService}or  {@link org.hibernate.boot.spi.ClassLoaderAccess} should be preferred
 */
@Deprecated public static Class classForName(String name) throws ClassNotFoundException {
  try {
    ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
    if (classLoader != null) {
      return classLoader.loadClass(name);
    }
  }
 catch (  Throwable ignore) {
  }
  return Class.forName(name);
}
"
"/** 
 * @deprecated (since 5.2.1), while actually added in 5.2.1, this was added to cleanup theaudit strategy interface temporarily.
 */
@Deprecated public EnversService getEnversService(){
  return enversService;
}
"
"/** 
 * Generate an initial version.
 * @param session The session from which this request originates.
 * @return an instance of the type
 * @deprecated use {@link RowVersionType} for binary entity versions/timestamps
 */
@Override @Deprecated public byte[] seed(SessionImplementor session){
  return null;
}
"
"/** 
 * Increment the version.
 * @param session The session from which this request originates.
 * @param current the current version
 * @return an instance of the type
 * @deprecated use {@link RowVersionType} for binary entity versions/timestamps
 */
@Override @Deprecated public byte[] next(byte[] current,SessionImplementor session){
  return current;
}
"
"/** 
 * Get a comparator for version values.
 * @return The comparator to use to compare different version values.
 * @deprecated use {@link RowVersionType} for binary entity versions/timestamps
 */
@Override @Deprecated public Comparator<byte[]> getComparator(){
  return PrimitiveByteArrayTypeDescriptor.INSTANCE.getComparator();
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * @param owner The owner
 * @deprecated Inject the owner into constructor.
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @param owner The owner
 * @deprecated Inject the owner into constructor.
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @param owner The owner
 * @deprecated Inject the owner into constructor.
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
  return this;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public void add(XmlDocument metadataXml){
}
"
"/** 
 * @deprecated No longer supported
 */
@Deprecated public Configuration addXML(String xml) throws MappingException {
  return this;
}
"
"/** 
 * Read mappings from a DOM <tt>Document</tt>
 * @param doc The DOM document
 * @return this (for method chaining purposes)
 * @throws MappingException Indicates problems reading the DOM or processingthe mapping document.
 * @deprecated Use addURL, addResource, addFile, etc. instead
 */
@Deprecated public Configuration addDocument(org.w3c.dom.Document doc) throws MappingException {
  metadataSources.addDocument(doc);
  return this;
}
"
"/** 
 * @deprecated This form (accepting a ClassLoader) is no longer supported.  Instead, add the ClassLoaderto the ClassLoaderService on the ServiceRegistry associated with this Configuration
 */
@Deprecated public Configuration addResource(String resourceName,ClassLoader classLoader) throws MappingException {
  return addResource(resourceName);
}
"
"/** 
 * @deprecated Does nothing
 */
@Deprecated public void buildMappings(){
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public AbstractEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,persistenceContext);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public AbstractEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,persistenceContext);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public AbstractEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,persistenceContext);
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The class (which implements  {@link org.hibernate.id.IdentifierGenerator}) which acts as this dialects native generation strategy. <p/> Comes into play whenever the user specifies the native generator.
 * @return The native generator class.
 * @deprecated use {@link #getNativeIdentifierGeneratorStrategy()} instead
 */
@Deprecated public Class getNativeIdentifierGeneratorClass(){
  if (getIdentityColumnSupport().supportsIdentityColumns()) {
    return IdentityGenerator.class;
  }
 else {
    return SequenceStyleGenerator.class;
  }
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come beforeQuery other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Some dialects have trouble applying pessimistic locking depending upon what other query options are specified (paging, ordering, etc).  This method allows these dialects to request that locking be applied by subsequent selects.
 * @return {@code true} indicates that the dialect requests that locking be applied by subsequent select;{@code false} (the default) indicates that locking should be applied to the main SQL statement..
 * @deprecated Use {@link #useFollowOnLocking(QueryParameters)} instead.
 */
@Deprecated public boolean useFollowOnLocking(){
  return useFollowOnLocking(null);
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * @deprecated Use {@link #buildUniqueConstraintHolders} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static List<String[]> buildUniqueConstraints(UniqueConstraint[] constraintsArray){
  List<String[]> result=new ArrayList<String[]>();
  if (constraintsArray.length != 0) {
    for (    UniqueConstraint uc : constraintsArray) {
      result.add(uc.columnNames());
    }
  }
  return result;
}
"
"/** 
 * The class (which implements  {@link org.hibernate.id.IdentifierGenerator}) which acts as this dialects native generation strategy. <p/> Comes into play whenever the user specifies the native generator.
 * @return The native generator class.
 * @deprecated use {@link #getNativeIdentifierGeneratorStrategy()} instead
 */
@Deprecated public Class getNativeIdentifierGeneratorClass(){
  if (getIdentityColumnSupport().supportsIdentityColumns()) {
    return IdentityGenerator.class;
  }
 else {
    return SequenceStyleGenerator.class;
  }
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The class (which implements  {@link org.hibernate.id.IdentifierGenerator}) which acts as this dialects native generation strategy. <p/> Comes into play whenever the user specifies the native generator.
 * @return The native generator class.
 * @deprecated use {@link #getNativeIdentifierGeneratorStrategy()} instead
 */
@Deprecated public Class getNativeIdentifierGeneratorClass(){
  if (getIdentityColumnSupport().supportsIdentityColumns()) {
    return IdentityGenerator.class;
  }
 else {
    return SequenceStyleGenerator.class;
  }
}
"
"/** 
 * Does this dialect support identity column key generation?
 * @return True if IDENTITY columns are supported; false otherwise.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().supportsIdentityColumns()} does not delegateto this method, then this method is ignored.
 */
@Deprecated public boolean supportsIdentityColumns(){
  return false;
}
"
"/** 
 * Does the dialect support some form of inserting and selecting the generated IDENTITY value all in the same statement.
 * @return True if the dialect supports selecting the justgenerated IDENTITY in the insert statement.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().supportsInsertSelectIdentity()} does not delegateto this method, then this method is ignored.
 */
@Deprecated public boolean supportsInsertSelectIdentity(){
  return false;
}
"
"/** 
 * Whether this dialect have an Identity clause added to the data type or a completely separate identity data type
 * @return boolean
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().hasDataTypeInIdentityColumn()} does not delegateto this method, then this method is ignored.
 */
@Deprecated public boolean hasDataTypeInIdentityColumn(){
  return true;
}
"
"/** 
 * Provided we  {@link #supportsInsertSelectIdentity}, then attach the ""select identity"" clause to the  insert statement. <p/> Note, if  {@link #supportsInsertSelectIdentity} == false thenthe insert-string should be returned without modification.
 * @param insertString The insert command
 * @return The insert command with any necessary identity selectclause attached.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().appendIdentitySelectToInsert(String)} does not delegateto this method, then this method is ignored.
 */
@Deprecated public String appendIdentitySelectToInsert(String insertString){
  return insertString;
}
"
"/** 
 * Get the select command to use to retrieve the last generated IDENTITY value for a particular table
 * @param table The table into which the insert was done
 * @param column The PK column.
 * @param type The {@link java.sql.Types} type code.
 * @return The appropriate select command
 * @throws MappingException If IDENTITY generation is not supported.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().getIdentitySelectString(String,String,int)} does not delegateto this method, then this method is ignored.
 */
@Deprecated public String getIdentitySelectString(String table,String column,int type) throws MappingException {
  return getIdentitySelectString();
}
"
"/** 
 * The syntax used during DDL to define a column as being an IDENTITY of a particular type.
 * @param type The {@link java.sql.Types} type code.
 * @return The appropriate DDL fragment.
 * @throws MappingException If IDENTITY generation is not supported.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().getIdentityColumnString(int)} does not delegateto this method, then this method is ignored.
 */
@Deprecated public String getIdentityColumnString(int type) throws MappingException {
  return getIdentityColumnString();
}
"
"/** 
 * The keyword used to insert a generated value into an identity column (or null). Need if the dialect does not support inserts that specify no column values.
 * @return The appropriate keyword.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().getIdentityInsertString()} does not delegateto this method, then this method is ignored.
 */
@Deprecated public String getIdentityInsertString(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
  return this;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public void add(XmlDocument metadataXml){
}
"
"/** 
 * @deprecated No longer supported
 */
@Deprecated public Configuration addXML(String xml) throws MappingException {
  return this;
}
"
"/** 
 * Read mappings from a DOM <tt>Document</tt>
 * @param doc The DOM document
 * @return this (for method chaining purposes)
 * @throws MappingException Indicates problems reading the DOM or processingthe mapping document.
 * @deprecated Use addURL, addResource, addFile, etc. instead
 */
@Deprecated public Configuration addDocument(org.w3c.dom.Document doc) throws MappingException {
  metadataSources.addDocument(doc);
  return this;
}
"
"/** 
 * @deprecated This form (accepting a ClassLoader) is no longer supported.  Instead, add the ClassLoaderto the ClassLoaderService on the ServiceRegistry associated with this Configuration
 */
@Deprecated public Configuration addResource(String resourceName,ClassLoader classLoader) throws MappingException {
  return addResource(resourceName);
}
"
"/** 
 * @deprecated Does nothing
 */
@Deprecated public void buildMappings(){
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
  return this;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public void add(XmlDocument metadataXml){
}
"
"/** 
 * @deprecated No longer supported
 */
@Deprecated public Configuration addXML(String xml) throws MappingException {
  return this;
}
"
"/** 
 * Read mappings from a DOM <tt>Document</tt>
 * @param doc The DOM document
 * @return this (for method chaining purposes)
 * @throws MappingException Indicates problems reading the DOM or processingthe mapping document.
 * @deprecated Use addURL, addResource, addFile, etc. instead
 */
@Deprecated public Configuration addDocument(org.w3c.dom.Document doc) throws MappingException {
  metadataSources.addDocument(doc);
  return this;
}
"
"/** 
 * @deprecated This form (accepting a ClassLoader) is no longer supported.  Instead, add the ClassLoaderto the ClassLoaderService on the ServiceRegistry associated with this Configuration
 */
@Deprecated public Configuration addResource(String resourceName,ClassLoader classLoader) throws MappingException {
  return addResource(resourceName);
}
"
"/** 
 * @deprecated Does nothing
 */
@Deprecated public void buildMappings(){
}
"
"/** 
 * Set lock mode
 * @param lockMode The {@link LockMode} used for this query.
 * @return this object
 * @deprecated Instead use setLockOptions
 */
@Deprecated public AuditQuery setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Deprecated!
 * @param associationPath The association path
 * @param alias The alias to apply to that association path
 * @param joinType The type of join to use
 * @return {@code this}, for method chaining
 * @deprecated use {@link #createAlias(String,String,JoinType)}
 */
@Deprecated public DetachedCriteria createAlias(String associationPath,String alias,int joinType){
  return createAlias(associationPath,alias,JoinType.parse(joinType));
}
"
"/** 
 * Deprecated!
 * @param associationPath The association path
 * @param alias The alias to apply to that association path
 * @param joinType The type of join to use
 * @param withClause An additional restriction on the join
 * @return {@code this}, for method chaining
 * @deprecated use {@link #createAlias(String,String,JoinType,Criterion)}
 */
@Deprecated public DetachedCriteria createAlias(String associationPath,String alias,int joinType,Criterion withClause){
  return createAlias(associationPath,alias,JoinType.parse(joinType),withClause);
}
"
"/** 
 * Deprecated!
 * @param associationPath The association path
 * @param joinType The type of join to use
 * @return the newly created, nested DetachedCriteria
 * @deprecated use {@link #createCriteria(String,JoinType)}
 */
@Deprecated public DetachedCriteria createCriteria(String associationPath,int joinType){
  return createCriteria(associationPath,JoinType.parse(joinType));
}
"
"/** 
 * Deprecated!
 * @param associationPath The association path
 * @param alias The alias
 * @param joinType The type of join to use
 * @return the newly created, nested DetachedCriteria
 * @deprecated use {@link #createCriteria(String,String,JoinType)}
 */
@Deprecated public DetachedCriteria createCriteria(String associationPath,String alias,int joinType){
  return createCriteria(associationPath,alias,JoinType.parse(joinType));
}
"
"/** 
 * Deprecated!
 * @param associationPath The association path
 * @param alias The alias to associate with this ""join"".
 * @param joinType The type of join to use
 * @param withClause The additional join restriction
 * @return the newly created, nested DetachedCriteria
 * @deprecated use {@link #createCriteria(String,String,JoinType,Criterion)}
 */
@Deprecated public DetachedCriteria createCriteria(String associationPath,String alias,int joinType,Criterion withClause){
  return createCriteria(associationPath,alias,JoinType.parse(joinType),withClause);
}
"
"/** 
 * @deprecated (snce 6.0) SessionDelegatorBaseImpl should take just one argument, the SessionImplementor.Use the  {@link #SessionDelegatorBaseImpl(SessionImplementor)} form instead
 */
@Deprecated public SessionDelegatorBaseImpl(SessionImplementor delegate,Session session){
  if (delegate == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null delegate object"");
  }
  if (session == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null Session"");
  }
  if (delegate != session) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from different Session/SessionImplementor references"");
  }
  this.delegate=delegate;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * Perform resolution of a class name. <p/> Same as  {@link #classForName(String,Class)} except that here we delegate to{@link Class#forName(String)} if the context classloader lookup is unsuccessful.
 * @param name The class name
 * @return The class reference.
 * @throws ClassNotFoundException From {@link Class#forName(String)}.
 * @deprecated Depending on context, either {@link org.hibernate.boot.registry.classloading.spi.ClassLoaderService}or  {@link org.hibernate.boot.spi.ClassLoaderAccess} should be preferred
 */
@Deprecated public static Class classForName(String name) throws ClassNotFoundException {
  try {
    ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
    if (classLoader != null) {
      return classLoader.loadClass(name);
    }
  }
 catch (  Throwable ignore) {
  }
  return Class.forName(name);
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The type
 * @deprecated Use {@link OrdinalParameterDescriptor#getExpectedType()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public Type getOrdinalParameterExpectedType(int position){
  return getOrdinalParameterDescriptor(position).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param position The position
 * @return The source location
 * @deprecated Use {@link OrdinalParameterDescriptor#getSourceLocation()} from the{@link #getOrdinalParameterDescriptor} return instead
 */
@Deprecated public int getOrdinalParameterSourceLocation(int position){
  return getOrdinalParameterDescriptor(position).getSourceLocation();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getExpectedType()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public Type getNamedParameterExpectedType(String name){
  return getNamedParameterDescriptor(name).getExpectedType();
}
"
"/** 
 * Deprecated.
 * @param name The name of the parameter
 * @return The type
 * @deprecated Use {@link NamedParameterDescriptor#getSourceLocations()} from the{@link #getNamedParameterDescriptor} return instead
 */
@Deprecated public int[] getNamedParameterSourceLocations(String name){
  return getNamedParameterDescriptor(name).getSourceLocations();
}
"
"/** 
 * @deprecated Use {@link #getPluralAttributePath()} instead
 */
@Deprecated public PluralAttributePath getCollectionPath(){
  return path;
}
"
"/** 
 * @deprecated prefer {@link #getOptimisticLockStyle}
 */
@Deprecated public int getOptimisticLockMode(){
  return getOptimisticLockStyle().getOldCode();
}
"
"/** 
 * @deprecated prefer {@link #setOptimisticLockStyle}
 */
@Deprecated public void setOptimisticLockMode(int optimisticLockMode){
  setOptimisticLockStyle(OptimisticLockStyle.interpretOldCode(optimisticLockMode));
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated Use {@link ConnectionProviderInitiator#toIsolationNiceName} instead
 */
@Deprecated public static String isolationLevelToString(int isolation){
  return ConnectionProviderInitiator.toIsolationNiceName(isolation);
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated Use {@link ConnectionProviderInitiator#toIsolationNiceName} instead
 */
@Deprecated public static String isolationLevelToString(int isolation){
  return ConnectionProviderInitiator.toIsolationNiceName(isolation);
}
"
"/** 
 * @deprecated Use {@link #applyIntegrator} instead
 */
@Deprecated public BootstrapServiceRegistryBuilder with(Integrator integrator){
  return applyIntegrator(integrator);
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  return new ClassLoaderServiceImpl(providedClassLoaders,TcclLookupPrecedence.AFTER);
}
"
"/** 
 * @deprecated Use {@link #applyClassLoader} instead
 */
@Deprecated public BootstrapServiceRegistryBuilder with(ClassLoader classLoader){
  return applyClassLoader(classLoader);
}
"
"/** 
 * @deprecated Use {@link #applyClassLoaderService} instead
 */
@Deprecated public BootstrapServiceRegistryBuilder with(ClassLoaderService classLoaderService){
  return applyClassLoaderService(classLoaderService);
}
"
"/** 
 * @deprecated Use {@link #applyStrategySelector} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public <T>BootstrapServiceRegistryBuilder withStrategySelector(Class<T> strategy,String name,Class<? extends T> implementation){
  return applyStrategySelector(strategy,name,implementation);
}
"
"/** 
 * @deprecated Use {@link #applyStrategySelectors} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public BootstrapServiceRegistryBuilder withStrategySelectors(StrategyRegistrationProvider strategyRegistrationProvider){
  return applyStrategySelectors(strategyRegistrationProvider);
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  return new ClassLoaderServiceImpl(providedClassLoaders);
}
"
"/** 
 * The class (which implements  {@link org.hibernate.id.IdentifierGenerator}) which acts as this dialects native generation strategy. <p/> Comes into play whenever the user specifies the native generator.
 * @return The native generator class.
 * @deprecated use {@link #getNativeIdentifierGeneratorStrategy()} instead
 */
@Deprecated public Class getNativeIdentifierGeneratorClass(){
  if (getIdentityColumnSupport().supportsIdentityColumns()) {
    return IdentityGenerator.class;
  }
 else {
    return SequenceStyleGenerator.class;
  }
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come beforeQuery other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Some dialects have trouble applying pessimistic locking depending upon what other query options are specified (paging, ordering, etc).  This method allows these dialects to request that locking be applied by subsequent selects.
 * @return {@code true} indicates that the dialect requests that locking be applied by subsequent select;{@code false} (the default) indicates that locking should be applied to the main SQL statement..
 * @deprecated Use {@link #useFollowOnLocking(QueryParameters)} instead.
 */
@Deprecated public boolean useFollowOnLocking(){
  return useFollowOnLocking(null);
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated Use {@link #applyIntegrator} instead
 */
@Deprecated public BootstrapServiceRegistryBuilder with(Integrator integrator){
  return applyIntegrator(integrator);
}
"
"/** 
 * @deprecated Use {@link #applyClassLoader} instead
 */
@Deprecated public BootstrapServiceRegistryBuilder with(ClassLoader classLoader){
  return applyClassLoader(classLoader);
}
"
"/** 
 * @deprecated Use {@link #applyClassLoaderService} instead
 */
@Deprecated public BootstrapServiceRegistryBuilder with(ClassLoaderService classLoaderService){
  return applyClassLoaderService(classLoaderService);
}
"
"/** 
 * @deprecated Use {@link #applyStrategySelector} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public <T>BootstrapServiceRegistryBuilder withStrategySelector(Class<T> strategy,String name,Class<? extends T> implementation){
  return applyStrategySelector(strategy,name,implementation);
}
"
"/** 
 * @deprecated Use {@link #applyStrategySelectors} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public BootstrapServiceRegistryBuilder withStrategySelectors(StrategyRegistrationProvider strategyRegistrationProvider){
  return applyStrategySelectors(strategyRegistrationProvider);
}
"
"/** 
 * No longer used/supported!
 * @param configValues The config values
 * @return The built service
 * @deprecated No longer used/supported!
 */
@Deprecated @SuppressWarnings({""UnusedDeclaration"",""unchecked"",""deprecation""}) public static ClassLoaderServiceImpl fromConfigSettings(Map configValues){
  final List<ClassLoader> providedClassLoaders=new ArrayList<ClassLoader>();
  final Collection<ClassLoader> classLoaders=(Collection<ClassLoader>)configValues.get(AvailableSettings.CLASSLOADERS);
  if (classLoaders != null) {
    for (    ClassLoader classLoader : classLoaders) {
      providedClassLoaders.add(classLoader);
    }
  }
  addIfSet(providedClassLoaders,AvailableSettings.APP_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.RESOURCES_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.HIBERNATE_CLASSLOADER,configValues);
  addIfSet(providedClassLoaders,AvailableSettings.ENVIRONMENT_CLASSLOADER,configValues);
  return new ClassLoaderServiceImpl(providedClassLoaders,TcclLookupPrecedence.AFTER);
}
"
"/** 
 * @deprecated Use {@link #applyIntegrator} instead
 */
@Deprecated public BootstrapServiceRegistryBuilder with(Integrator integrator){
  return applyIntegrator(integrator);
}
"
"/** 
 * @deprecated Use {@link #applyClassLoader} instead
 */
@Deprecated public BootstrapServiceRegistryBuilder with(ClassLoader classLoader){
  return applyClassLoader(classLoader);
}
"
"/** 
 * @deprecated Use {@link #applyClassLoaderService} instead
 */
@Deprecated public BootstrapServiceRegistryBuilder with(ClassLoaderService classLoaderService){
  return applyClassLoaderService(classLoaderService);
}
"
"/** 
 * @deprecated Use {@link #applyStrategySelector} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public <T>BootstrapServiceRegistryBuilder withStrategySelector(Class<T> strategy,String name,Class<? extends T> implementation){
  return applyStrategySelector(strategy,name,implementation);
}
"
"/** 
 * @deprecated Use {@link #applyStrategySelectors} instead
 */
@SuppressWarnings({""UnusedDeclaration""}) @Deprecated public BootstrapServiceRegistryBuilder withStrategySelectors(StrategyRegistrationProvider strategyRegistrationProvider){
  return applyStrategySelectors(strategyRegistrationProvider);
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public AbstractEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,persistenceContext);
}
"
"/** 
 * Perform resolution of a class name. <p/> Same as  {@link #classForName(String,Class)} except that here we delegate to{@link Class#forName(String)} if the context classloader lookup is unsuccessful.
 * @param name The class name
 * @return The class reference.
 * @throws ClassNotFoundException From {@link Class#forName(String)}.
 * @deprecated Depending on context, either {@link org.hibernate.boot.registry.classloading.spi.ClassLoaderService}or  {@link org.hibernate.boot.spi.ClassLoaderAccess} should be preferred
 */
@Deprecated public static Class classForName(String name) throws ClassNotFoundException {
  try {
    ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
    if (classLoader != null) {
      return classLoader.loadClass(name);
    }
  }
 catch (  Throwable ignore) {
  }
  return Class.forName(name);
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * Perform resolution of a class name. <p/> Same as  {@link #classForName(String,Class)} except that here we delegate to{@link Class#forName(String)} if the context classloader lookup is unsuccessful.
 * @param name The class name
 * @return The class reference.
 * @throws ClassNotFoundException From {@link Class#forName(String)}.
 * @deprecated Depending on context, either {@link org.hibernate.boot.registry.classloading.spi.ClassLoaderService}or  {@link org.hibernate.boot.spi.ClassLoaderAccess} should be preferred
 */
@Deprecated public static Class classForName(String name) throws ClassNotFoundException {
  try {
    ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
    if (classLoader != null) {
      return classLoader.loadClass(name);
    }
  }
 catch (  Throwable ignore) {
  }
  return Class.forName(name);
}
"
"/** 
 * The class (which implements  {@link org.hibernate.id.IdentifierGenerator}) which acts as this dialects native generation strategy. <p/> Comes into play whenever the user specifies the native generator.
 * @return The native generator class.
 * @deprecated use {@link #getNativeIdentifierGeneratorStrategy()} instead
 */
@Deprecated public Class getNativeIdentifierGeneratorClass(){
  if (getIdentityColumnSupport().supportsIdentityColumns()) {
    return IdentityGenerator.class;
  }
 else {
    return SequenceStyleGenerator.class;
  }
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come beforeQuery other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Some dialects have trouble applying pessimistic locking depending upon what other query options are specified (paging, ordering, etc).  This method allows these dialects to request that locking be applied by subsequent selects.
 * @return {@code true} indicates that the dialect requests that locking be applied by subsequent select;{@code false} (the default) indicates that locking should be applied to the main SQL statement..
 * @deprecated Use {@link #useFollowOnLocking(QueryParameters)} instead.
 */
@Deprecated public boolean useFollowOnLocking(){
  return useFollowOnLocking(null);
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * @deprecated Should use enhance(String, byte[]) and a proper EnhancementContext
 */
@Deprecated public byte[] enhanceComposite(String className,byte[] originalBytes) throws EnhancementException {
  return enhance(className,originalBytes);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public AbstractEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,persistenceContext);
}
"
"/** 
 * @deprecated the tenantId and entityMode parameters where removed: this constructor accepts but ignores them.Use the other constructor!
 */
@Deprecated public AbstractEntityEntry(final Status status,final Object[] loadedState,final Object rowId,final Serializable id,final Object version,final LockMode lockMode,final boolean existsInDatabase,final EntityPersister persister,final EntityMode entityMode,final String tenantId,final boolean disableVersionIncrement,final boolean lazyPropertiesAreUnfetched,final PersistenceContext persistenceContext){
  this(status,loadedState,rowId,id,version,lockMode,existsInDatabase,persister,disableVersionIncrement,lazyPropertiesAreUnfetched,persistenceContext);
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * The class (which implements  {@link org.hibernate.id.IdentifierGenerator}) which acts as this dialects native generation strategy. <p/> Comes into play whenever the user specifies the native generator.
 * @return The native generator class.
 * @deprecated use {@link #getNativeIdentifierGeneratorStrategy()} instead
 */
@Deprecated public Class getNativeIdentifierGeneratorClass(){
  if (getIdentityColumnSupport().supportsIdentityColumns()) {
    return IdentityGenerator.class;
  }
 else {
    return SequenceStyleGenerator.class;
  }
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come beforeQuery other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Some dialects have trouble applying pessimistic locking depending upon what other query options are specified (paging, ordering, etc).  This method allows these dialects to request that locking be applied by subsequent selects.
 * @return {@code true} indicates that the dialect requests that locking be applied by subsequent select;{@code false} (the default) indicates that locking should be applied to the main SQL statement..
 * @deprecated Use {@link #useFollowOnLocking(QueryParameters)} instead.
 */
@Deprecated public boolean useFollowOnLocking(){
  return useFollowOnLocking(null);
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public String getQualifiedName(Dialect dialect,String defaultCatalog,String defaultSchema){
  if (subselect != null) {
    return ""( "" + subselect + "" )"";
  }
  String quotedName=getQuotedName(dialect);
  String usedSchema=schema == null ? defaultSchema : getQuotedSchema(dialect);
  String usedCatalog=catalog == null ? defaultCatalog : getQuotedCatalog(dialect);
  return qualify(usedCatalog,usedSchema,quotedName);
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public static String qualify(String catalog,String schema,String table){
  StringBuilder qualifiedName=new StringBuilder();
  if (catalog != null) {
    qualifiedName.append(catalog).append('.');
  }
  if (schema != null) {
    qualifiedName.append(schema).append('.');
  }
  return qualifiedName.append(table).toString();
}
"
"/** 
 * @deprecated since 5.2, to be removed in 6.0 with no replacement.
 */
@Deprecated public ModificationStore getStore(){
  return store;
}
"
"/** 
 * @deprecated since 5.2, to be removed in 6.0 with no replacement.
 */
@Deprecated public void setStore(ModificationStore store){
  this.store=store;
}
"
"/** 
 * @deprecated since 5.2, to be removed in 6.0 with no replacement.
 */
@Deprecated public ModificationStore getStore(){
  return store;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * The class (which implements  {@link org.hibernate.id.IdentifierGenerator}) which acts as this dialects native generation strategy. <p/> Comes into play whenever the user specifies the native generator.
 * @return The native generator class.
 * @deprecated use {@link #getNativeIdentifierGeneratorStrategy()} instead
 */
@Deprecated public Class getNativeIdentifierGeneratorClass(){
  if (getIdentityColumnSupport().supportsIdentityColumns()) {
    return IdentityGenerator.class;
  }
 else {
    return SequenceStyleGenerator.class;
  }
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come beforeQuery other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Some dialects have trouble applying pessimistic locking depending upon what other query options are specified (paging, ordering, etc).  This method allows these dialects to request that locking be applied by subsequent selects.
 * @return {@code true} indicates that the dialect requests that locking be applied by subsequent select;{@code false} (the default) indicates that locking should be applied to the main SQL statement..
 * @deprecated Use {@link #useFollowOnLocking(QueryParameters)} instead.
 */
@Deprecated public boolean useFollowOnLocking(){
  return useFollowOnLocking(null);
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Type> collectBindTypes(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindType).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Object> collectBindValues(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindValue).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Type[] collectPositionalBindTypes(){
  Type[] types=new Type[positionalParameterBindings.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindings.entrySet()) {
    final int position=entry.getKey();
    Type type=entry.getValue().getBindType();
    if (type == null) {
      log.debugf(""Binding for positional-parameter [%s] did not define type, using SerializableType"",position);
      type=SerializableType.INSTANCE;
    }
    types[position]=type;
  }
  return types;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Object[] collectPositionalBindValues(){
  Object[] values=new Object[positionalParameterBindings.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindings.entrySet()) {
    final int position=entry.getKey();
    values[position]=entry.getValue().getBindValue();
  }
  return values;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Map<String,TypedValue> collectNamedParameterBindings(){
  Map<String,TypedValue> collectedBindings=new HashMap<>();
  for (  Map.Entry<QueryParameter,QueryParameterBinding> entry : parameterBindingMap.entrySet()) {
    if (entry.getKey().getName() == null) {
      continue;
    }
    Type bindType=entry.getValue().getBindType();
    if (bindType == null) {
      log.debugf(""Binding for named-parameter [%s] did not define type"",entry.getKey().getName());
      bindType=SerializableType.INSTANCE;
    }
    collectedBindings.put(entry.getKey().getName(),new TypedValue(bindType,entry.getValue().getBindValue()));
  }
  return collectedBindings;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(QueryParameter<T> queryParameter){
  QueryParameterListBinding result=parameterListBindingMap.get(queryParameter);
  if (result == null) {
    result=transformQueryParameterBindingToQueryParameterListBinding(queryParameter);
  }
  return result;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(String name){
  final QueryParameter<T> queryParameter=resolveQueryParameter(name);
  return getQueryParameterListBinding(queryParameter);
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public String expandListValuedParameters(String queryString,SharedSessionContractImplementor session){
  if (queryString == null) {
    return null;
  }
  final Dialect dialect=session.getFactory().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect();
  final int inExprLimit=dialect.getInExpressionCountLimit();
  for (  Map.Entry<QueryParameter,QueryParameterListBinding> entry : parameterListBindingMap.entrySet()) {
    final NamedParameterDescriptor sourceParam=(NamedParameterDescriptor)entry.getKey();
    final Collection bindValues=entry.getValue().getBindValues();
    if (inExprLimit > 0 && bindValues.size() > inExprLimit) {
      log.tooManyInExpressions(dialect.getClass().getName(),inExprLimit,sourceParam.getName(),bindValues.size());
    }
    final boolean isJpaPositionalParam=sourceParam.isJpaPositionalParameter();
    final String paramPrefix=isJpaPositionalParam ? ""?"" : ParserHelper.HQL_VARIABLE_PREFIX;
    final String placeholder=paramPrefix + sourceParam.getName();
    final int loc=queryString.indexOf(placeholder);
    if (loc < 0) {
      continue;
    }
    final String beforePlaceholder=queryString.substring(0,loc);
    final String afterPlaceholder=queryString.substring(loc + placeholder.length());
    boolean isEnclosedInParens=StringHelper.getLastNonWhitespaceCharacter(beforePlaceholder) == '(' && StringHelper.getFirstNonWhitespaceCharacter(afterPlaceholder) == ')';
    if (bindValues.size() == 1 && isEnclosedInParens) {
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValues.iterator().next());
      parameterBindingMap.put(sourceParam,syntheticBinding);
      continue;
    }
    StringBuilder expansionList=new StringBuilder();
    int i=0;
    for (    Object bindValue : entry.getValue().getBindValues()) {
      final String syntheticName=(isJpaPositionalParam ? 'x' : """") + sourceParam.getName() + '_'+ i;
      if (i > 0) {
        expansionList.append("", "");
      }
      expansionList.append(ParserHelper.HQL_VARIABLE_PREFIX).append(syntheticName);
      final QueryParameter syntheticParam=new QueryParameterNamedImpl<>(syntheticName,sourceParam.getSourceLocations(),sourceParam.isJpaPositionalParameter(),sourceParam.getType());
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValue);
      parameterBindingMap.put(syntheticParam,syntheticBinding);
      i++;
    }
    queryString=StringHelper.replace(beforePlaceholder,afterPlaceholder,placeholder,expansionList.toString(),true,true);
  }
  return queryString;
}
"
"/** 
 * Perform resolution of a class name. <p/> Same as  {@link #classForName(String,Class)} except that here we delegate to{@link Class#forName(String)} if the context classloader lookup is unsuccessful.
 * @param name The class name
 * @return The class reference.
 * @throws ClassNotFoundException From {@link Class#forName(String)}.
 * @deprecated Depending on context, either {@link org.hibernate.boot.registry.classloading.spi.ClassLoaderService}or  {@link org.hibernate.boot.spi.ClassLoaderAccess} should be preferred
 */
@Deprecated public static Class classForName(String name) throws ClassNotFoundException {
  try {
    ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
    if (classLoader != null) {
      return classLoader.loadClass(name);
    }
  }
 catch (  Throwable ignore) {
  }
  return Class.forName(name);
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated Use {@link org.hibernate.tuple.NonIdentifierAttribute#isDirtyCheckable()} instead
 */
@Deprecated public boolean isDirtyCheckable(boolean hasUninitializedProperties);
"
"/** 
 * Determine if any of the given field values are dirty, returning an array containing indices of the dirty fields. <p/> If it is determined that no fields are dirty, null is returned.
 * @param properties The property definitions
 * @param currentState The current state of the entity
 * @param previousState The baseline state of the entity
 * @param includeColumns Columns to be included in the dirty checking, per property
 * @param anyUninitializedProperties Does the entity currently hold any uninitialized property values?
 * @param session The session from which the dirty check request originated.
 * @return Array containing indices of the dirty properties, or null if no properties considered dirty.
 * @deprecated Use {org.hibernate.type.TypeHelper{@link #findDirty(NonIdentifierAttribute[],Object[],Object[],boolean[][],SharedSessionContractImplementor)} indtead
 */
@Deprecated public static int[] findDirty(final NonIdentifierAttribute[] properties,final Object[] currentState,final Object[] previousState,final boolean[][] includeColumns,final boolean anyUninitializedProperties,final SharedSessionContractImplementor session){
  return findDirty(properties,currentState,previousState,includeColumns,session);
}
"
"/** 
 * Determine if any of the given field values are modified, returning an array containing indices of the modified fields. <p/> If it is determined that no fields are dirty, null is returned.
 * @param properties The property definitions
 * @param currentState The current state of the entity
 * @param previousState The baseline state of the entity
 * @param includeColumns Columns to be included in the mod checking, per property
 * @param includeProperties Array of property indices that identify which properties participate in check
 * @param anyUninitializedProperties Does the entity currently hold any uninitialized property values?
 * @param session The session from which the dirty check request originated.
 * @return Array containing indices of the modified properties, or null if no properties considered modified.
 * @deprecated Use {@link #findModified(NonIdentifierAttribute[],Object[],Object[],boolean[][],boolean[],boolean,SharedSessionContractImplementor)}instead.
 */
@Deprecated public static int[] findModified(final NonIdentifierAttribute[] properties,final Object[] currentState,final Object[] previousState,final boolean[][] includeColumns,final boolean[] includeProperties,final boolean anyUninitializedProperties,final SharedSessionContractImplementor session){
  return findModified(properties,currentState,previousState,includeColumns,includeProperties,session);
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated Use {@link org.hibernate.tuple.NonIdentifierAttribute#isDirtyCheckable()} instead
 */
@Deprecated public boolean isDirtyCheckable(boolean hasUninitializedProperties);
"
"/** 
 * Determine if any of the given field values are dirty, returning an array containing indices of the dirty fields. <p/> If it is determined that no fields are dirty, null is returned.
 * @param properties The property definitions
 * @param currentState The current state of the entity
 * @param previousState The baseline state of the entity
 * @param includeColumns Columns to be included in the dirty checking, per property
 * @param anyUninitializedProperties Does the entity currently hold any uninitialized property values?
 * @param session The session from which the dirty check request originated.
 * @return Array containing indices of the dirty properties, or null if no properties considered dirty.
 * @deprecated Use {org.hibernate.type.TypeHelper{@link #findDirty(NonIdentifierAttribute[],Object[],Object[],boolean[][],SessionImplementor)} instead
 */
@Deprecated public static int[] findDirty(final NonIdentifierAttribute[] properties,final Object[] currentState,final Object[] previousState,final boolean[][] includeColumns,final boolean anyUninitializedProperties,final SessionImplementor session){
  return findDirty(properties,currentState,previousState,includeColumns,session);
}
"
"/** 
 * Determine if any of the given field values are modified, returning an array containing indices of the modified fields. <p/> If it is determined that no fields are dirty, null is returned.
 * @param properties The property definitions
 * @param currentState The current state of the entity
 * @param previousState The baseline state of the entity
 * @param includeColumns Columns to be included in the mod checking, per property
 * @param anyUninitializedProperties Does the entity currently hold any uninitialized property values?
 * @param session The session from which the dirty check request originated.
 * @return Array containing indices of the modified properties, or null if no properties considered modified.
 * @deprecated Use {@link #findModified(NonIdentifierAttribute[],Object[],Object[],boolean[][],boolean,SessionImplementor)}instead.
 */
@Deprecated public static int[] findModified(final NonIdentifierAttribute[] properties,final Object[] currentState,final Object[] previousState,final boolean[][] includeColumns,final boolean anyUninitializedProperties,final SessionImplementor session){
  return findModified(properties,currentState,previousState,includeColumns,session);
}
"
"/** 
 * Determine if any of the given field values are dirty, returning an array containing indices of the dirty fields. <p/> If it is determined that no fields are dirty, null is returned.
 * @param properties The property definitions
 * @param currentState The current state of the entity
 * @param previousState The baseline state of the entity
 * @param includeColumns Columns to be included in the dirty checking, per property
 * @param anyUninitializedProperties Does the entity currently hold any uninitialized property values?
 * @param session The session from which the dirty check request originated.
 * @return Array containing indices of the dirty properties, or null if no properties considered dirty.
 * @deprecated Use {org.hibernate.type.TypeHelper{@link #findDirty(NonIdentifierAttribute[],Object[],Object[],boolean[][],SharedSessionContractImplementor)} indtead
 */
@Deprecated public static int[] findDirty(final NonIdentifierAttribute[] properties,final Object[] currentState,final Object[] previousState,final boolean[][] includeColumns,final boolean anyUninitializedProperties,final SharedSessionContractImplementor session){
  return findDirty(properties,currentState,previousState,includeColumns,session);
}
"
"/** 
 * Determine if any of the given field values are modified, returning an array containing indices of the modified fields. <p/> If it is determined that no fields are dirty, null is returned.
 * @param properties The property definitions
 * @param currentState The current state of the entity
 * @param previousState The baseline state of the entity
 * @param includeColumns Columns to be included in the mod checking, per property
 * @param includeProperties Array of property indices that identify which properties participate in check
 * @param anyUninitializedProperties Does the entity currently hold any uninitialized property values?
 * @param session The session from which the dirty check request originated.
 * @return Array containing indices of the modified properties, or null if no properties considered modified.
 * @deprecated Use {@link #findModified(NonIdentifierAttribute[],Object[],Object[],boolean[][],boolean[],boolean,SharedSessionContractImplementor)}instead.
 */
@Deprecated public static int[] findModified(final NonIdentifierAttribute[] properties,final Object[] currentState,final Object[] previousState,final boolean[][] includeColumns,final boolean[] includeProperties,final boolean anyUninitializedProperties,final SharedSessionContractImplementor session){
  return findModified(properties,currentState,previousState,includeColumns,includeProperties,session);
}
"
"/** 
 * @deprecated (snce 6.0) SessionDelegatorBaseImpl should take just one argument, the SessionImplementor.Use the  {@link #SessionDelegatorBaseImpl(SessionImplementor)} form instead
 */
@Deprecated public SessionDelegatorBaseImpl(SessionImplementor delegate,Session session){
  if (delegate == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null delegate object"");
  }
  if (session == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null Session"");
  }
  if (delegate != session) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from different Session/SessionImplementor references"");
  }
  this.delegate=delegate;
}
"
"/** 
 * The class (which implements  {@link org.hibernate.id.IdentifierGenerator}) which acts as this dialects native generation strategy. <p/> Comes into play whenever the user specifies the native generator.
 * @return The native generator class.
 * @deprecated use {@link #getNativeIdentifierGeneratorStrategy()} instead
 */
@Deprecated public Class getNativeIdentifierGeneratorClass(){
  if (getIdentityColumnSupport().supportsIdentityColumns()) {
    return IdentityGenerator.class;
  }
 else {
    return SequenceStyleGenerator.class;
  }
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come beforeQuery other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Some dialects have trouble applying pessimistic locking depending upon what other query options are specified (paging, ordering, etc).  This method allows these dialects to request that locking be applied by subsequent selects.
 * @return {@code true} indicates that the dialect requests that locking be applied by subsequent select;{@code false} (the default) indicates that locking should be applied to the main SQL statement..
 * @deprecated Use {@link #useFollowOnLocking(QueryParameters)} instead.
 */
@Deprecated public boolean useFollowOnLocking(){
  return useFollowOnLocking(null);
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The class (which implements  {@link org.hibernate.id.IdentifierGenerator}) which acts as this dialects native generation strategy. <p/> Comes into play whenever the user specifies the native generator.
 * @return The native generator class.
 * @deprecated use {@link #getNativeIdentifierGeneratorStrategy()} instead
 */
@Deprecated public Class getNativeIdentifierGeneratorClass(){
  if (getIdentityColumnSupport().supportsIdentityColumns()) {
    return IdentityGenerator.class;
  }
 else {
    return SequenceStyleGenerator.class;
  }
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come beforeQuery other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Some dialects have trouble applying pessimistic locking depending upon what other query options are specified (paging, ordering, etc).  This method allows these dialects to request that locking be applied by subsequent selects.
 * @return {@code true} indicates that the dialect requests that locking be applied by subsequent select;{@code false} (the default) indicates that locking should be applied to the main SQL statement..
 * @deprecated Use {@link #useFollowOnLocking(QueryParameters)} instead.
 */
@Deprecated public boolean useFollowOnLocking(){
  return useFollowOnLocking(null);
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated (snce 6.0) SessionDelegatorBaseImpl should take just one argument, the SessionImplementor.Use the  {@link #SessionDelegatorBaseImpl(SessionImplementor)} form instead
 */
@Deprecated public SessionDelegatorBaseImpl(SessionImplementor delegate,Session session){
  if (delegate == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null delegate object"");
  }
  if (session == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null Session"");
  }
  if (delegate != session) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from different Session/SessionImplementor references"");
  }
  this.delegate=delegate;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Type> collectBindTypes(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindType).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Collection<Object> collectBindValues(){
  return parameterBindingMap.values().stream().map(QueryParameterBinding::getBindValue).collect(Collectors.toList());
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Type[] collectPositionalBindTypes(){
  Type[] types=new Type[positionalParameterBindings.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindings.entrySet()) {
    final int position=entry.getKey();
    Type type=entry.getValue().getBindType();
    if (type == null) {
      log.debugf(""Binding for positional-parameter [%s] did not define type, using SerializableType"",position);
      type=SerializableType.INSTANCE;
    }
    types[position]=type;
  }
  return types;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Object[] collectPositionalBindValues(){
  Object[] values=new Object[positionalParameterBindings.size()];
  for (  Map.Entry<Integer,QueryParameterBinding> entry : positionalParameterBindings.entrySet()) {
    final int position=entry.getKey();
    values[position]=entry.getValue().getBindValue();
  }
  return values;
}
"
"/** 
 * @deprecated (since 5.2) expect a different approach to org.hibernate.engine.spi.QueryParameters in 6.0
 */
@Deprecated public Map<String,TypedValue> collectNamedParameterBindings(){
  Map<String,TypedValue> collectedBindings=new HashMap<>();
  for (  Map.Entry<QueryParameter,QueryParameterBinding> entry : parameterBindingMap.entrySet()) {
    if (entry.getKey().getName() == null) {
      continue;
    }
    Type bindType=entry.getValue().getBindType();
    if (bindType == null) {
      log.debugf(""Binding for named-parameter [%s] did not define type"",entry.getKey().getName());
      bindType=SerializableType.INSTANCE;
    }
    collectedBindings.put(entry.getKey().getName(),new TypedValue(bindType,entry.getValue().getBindValue()));
  }
  return collectedBindings;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(QueryParameter<T> queryParameter){
  QueryParameterListBinding result=parameterListBindingMap.get(queryParameter);
  if (result == null) {
    result=transformQueryParameterBindingToQueryParameterListBinding(queryParameter);
  }
  return result;
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public <T>QueryParameterListBinding<T> getQueryParameterListBinding(String name){
  final QueryParameter<T> queryParameter=resolveQueryParameter(name);
  return getQueryParameterListBinding(queryParameter);
}
"
"/** 
 * @deprecated (since 5.2) expected changes to ""collection-valued parameter binding"" in 6.0
 */
@Deprecated @SuppressWarnings(""unchecked"") public String expandListValuedParameters(String queryString,SharedSessionContractImplementor session){
  if (queryString == null) {
    return null;
  }
  final Dialect dialect=session.getFactory().getServiceRegistry().getService(JdbcServices.class).getJdbcEnvironment().getDialect();
  final int inExprLimit=dialect.getInExpressionCountLimit();
  for (  Map.Entry<QueryParameter,QueryParameterListBinding> entry : parameterListBindingMap.entrySet()) {
    final NamedParameterDescriptor sourceParam=(NamedParameterDescriptor)entry.getKey();
    final Collection bindValues=entry.getValue().getBindValues();
    if (inExprLimit > 0 && bindValues.size() > inExprLimit) {
      log.tooManyInExpressions(dialect.getClass().getName(),inExprLimit,sourceParam.getName(),bindValues.size());
    }
    final boolean isJpaPositionalParam=sourceParam.isJpaPositionalParameter();
    final String paramPrefix=isJpaPositionalParam ? ""?"" : ParserHelper.HQL_VARIABLE_PREFIX;
    final String placeholder=paramPrefix + sourceParam.getName();
    final int loc=queryString.indexOf(placeholder);
    if (loc < 0) {
      continue;
    }
    final String beforePlaceholder=queryString.substring(0,loc);
    final String afterPlaceholder=queryString.substring(loc + placeholder.length());
    boolean isEnclosedInParens=StringHelper.getLastNonWhitespaceCharacter(beforePlaceholder) == '(' && StringHelper.getFirstNonWhitespaceCharacter(afterPlaceholder) == ')';
    if (bindValues.size() == 1 && isEnclosedInParens) {
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValues.iterator().next());
      parameterBindingMap.put(sourceParam,syntheticBinding);
      continue;
    }
    StringBuilder expansionList=new StringBuilder();
    int i=0;
    for (    Object bindValue : entry.getValue().getBindValues()) {
      final String syntheticName=(isJpaPositionalParam ? 'x' : """") + sourceParam.getName() + '_'+ i;
      if (i > 0) {
        expansionList.append("", "");
      }
      expansionList.append(ParserHelper.HQL_VARIABLE_PREFIX).append(syntheticName);
      final QueryParameter syntheticParam=new QueryParameterNamedImpl<>(syntheticName,sourceParam.getSourceLocations(),sourceParam.isJpaPositionalParameter(),sourceParam.getType());
      final QueryParameterBinding syntheticBinding=makeBinding(entry.getValue().getBindType());
      syntheticBinding.setBindValue(bindValue);
      parameterBindingMap.put(syntheticParam,syntheticBinding);
      i++;
    }
    queryString=StringHelper.replace(beforePlaceholder,afterPlaceholder,placeholder,expansionList.toString(),true,true);
  }
  return queryString;
}
"
"/** 
 * The class (which implements  {@link org.hibernate.id.IdentifierGenerator}) which acts as this dialects native generation strategy. <p/> Comes into play whenever the user specifies the native generator.
 * @return The native generator class.
 * @deprecated use {@link #getNativeIdentifierGeneratorStrategy()} instead
 */
@Deprecated public Class getNativeIdentifierGeneratorClass(){
  if (getIdentityColumnSupport().supportsIdentityColumns()) {
    return IdentityGenerator.class;
  }
 else {
    return SequenceStyleGenerator.class;
  }
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Some dialects have trouble applying pessimistic locking depending upon what other query options are specified (paging, ordering, etc).  This method allows these dialects to request that locking be applied by subsequent selects.
 * @return {@code true} indicates that the dialect requests that locking be applied by subsequent select;{@code false} (the default) indicates that locking should be applied to the main SQL statement..
 * @deprecated Use {@link #useFollowOnLocking(QueryParameters)} instead.
 */
@Deprecated public boolean useFollowOnLocking(){
  return useFollowOnLocking(null);
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public String getQualifiedName(Dialect dialect,String defaultCatalog,String defaultSchema){
  if (subselect != null) {
    return ""( "" + subselect + "" )"";
  }
  String quotedName=getQuotedName(dialect);
  String usedSchema=schema == null ? defaultSchema : getQuotedSchema(dialect);
  String usedCatalog=catalog == null ? defaultCatalog : getQuotedCatalog(dialect);
  return qualify(usedCatalog,usedSchema,quotedName);
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public static String qualify(String catalog,String schema,String table){
  StringBuilder qualifiedName=new StringBuilder();
  if (catalog != null) {
    qualifiedName.append(catalog).append('.');
  }
  if (schema != null) {
    qualifiedName.append(schema).append('.');
  }
  return qualifiedName.append(table).toString();
}
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-separated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Join an association using the specified join-type, assigning an alias to the joined association. <p/> The joinType is expected to be one of  {@link #INNER_JOIN} (the default),{@link #FULL_JOIN}, or  {@link #LEFT_JOIN}.
 * @param associationPath A dot-separated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return this (for method chaining)
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,JoinType,Criterion)}
 */
@Deprecated public Criteria createAlias(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, using the specified join type.
 * @param associationPath A dot-separated property path
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createAlias(String,String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-separated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,org.hibernate.sql.JoinType)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType) throws HibernateException ;
"
"/** 
 * Create a new <tt>Criteria</tt>, ""rooted"" at the associated entity, assigning the given alias and using the specified join type.
 * @param associationPath A dot-separated property path
 * @param alias The alias to assign to the joined association (for later reference).
 * @param joinType The type of join to use.
 * @param withClause The criteria to be added to the join condition (<tt>ON</tt> clause)
 * @return the created ""sub criteria""
 * @throws HibernateException Indicates a problem creating the sub criteria
 * @deprecated use {@link #createCriteria(String,String,org.hibernate.sql.JoinType,org.hibernate.criterion.Criterion)}
 */
@Deprecated public Criteria createCriteria(String associationPath,String alias,int joinType,Criterion withClause) throws HibernateException ;
"
"/** 
 * Checks to see if the given mode is the same as  {@link #MANUAL}.
 * @param mode The mode to check
 * @return true/false
 * @deprecated Just use equality check against {@link #MANUAL}.  Legacy from before this was an enum
 */
@Deprecated public static boolean isManualFlushMode(FlushMode mode){
  return MANUAL.level == mode.level;
}
"
"/** 
 * Access to the delayed entity key
 * @return The delayed entity key
 * @deprecated No Hibernate code currently uses this method
 */
@Deprecated @SuppressWarnings(""UnusedDeclaration"") public EntityKey getDelayedEntityKey(){
  return delayedEntityKey;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
  return this;
}
"
"/** 
 * @deprecated No longer supported.
 */
@Deprecated public void add(XmlDocument metadataXml){
}
"
"/** 
 * @deprecated No longer supported
 */
@Deprecated public Configuration addXML(String xml) throws MappingException {
  return this;
}
"
"/** 
 * Read mappings from a DOM <tt>Document</tt>
 * @param doc The DOM document
 * @return this (for method chaining purposes)
 * @throws MappingException Indicates problems reading the DOM or processingthe mapping document.
 * @deprecated Use addURL, addResource, addFile, etc. instead
 */
@Deprecated public Configuration addDocument(org.w3c.dom.Document doc) throws MappingException {
  metadataSources.addDocument(doc);
  return this;
}
"
"/** 
 * @deprecated This form (accepting a ClassLoader) is no longer supported.  Instead, add the ClassLoaderto the ClassLoaderService on the ServiceRegistry associated with this Configuration
 */
@Deprecated public Configuration addResource(String resourceName,ClassLoader classLoader) throws MappingException {
  return addResource(resourceName);
}
"
"/** 
 * @deprecated Does nothing
 */
@Deprecated public void buildMappings(){
}
"
"/** 
 * @deprecated Use {@link ConnectionProviderInitiator#toIsolationNiceName} instead
 */
@Deprecated public static String isolationLevelToString(int isolation){
  return ConnectionProviderInitiator.toIsolationNiceName(isolation);
}
"
"/** 
 * Lol
 * @return duh
 * @deprecated an instance factory method does not make sense
 * @see Projections#projectionList()
 */
@Deprecated public ProjectionList create(){
  return new ProjectionList();
}
"
"/** 
 * The class (which implements  {@link org.hibernate.id.IdentifierGenerator}) which acts as this dialects native generation strategy. <p/> Comes into play whenever the user specifies the native generator.
 * @return The native generator class.
 * @deprecated use {@link #getNativeIdentifierGeneratorStrategy()} instead
 */
@Deprecated public Class getNativeIdentifierGeneratorClass(){
  if (getIdentityColumnSupport().supportsIdentityColumns()) {
    return IdentityGenerator.class;
  }
 else {
    return SequenceStyleGenerator.class;
  }
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Some dialects have trouble applying pessimistic locking depending upon what other query options are specified (paging, ordering, etc).  This method allows these dialects to request that locking be applied by subsequent selects.
 * @return {@code true} indicates that the dialect requests that locking be applied by subsequent select;{@code false} (the default) indicates that locking should be applied to the main SQL statement..
 * @deprecated Use {@link #useFollowOnLocking(QueryParameters)} instead.
 */
@Deprecated public boolean useFollowOnLocking(){
  return useFollowOnLocking(null);
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a the result-set mapping information is not explicitly  provided in the query definition (i.e., no resultset-mapping used).
 * @param name The name of named query
 * @param query The sql query string
 * @param queryReturns The in-lined query return definitions
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,NativeSQLQueryReturn[] queryReturns,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,null,querySpaces,callable,queryReturns);
}
"
"/** 
 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a resultset-mapping reference is used.
 * @param name The name of named query
 * @param query The sql query string
 * @param resultSetRef The resultset-mapping name
 * @param querySpaces Any specified query spaces (used for auto-flushing)
 * @param cacheable Whether the query results are cacheable
 * @param cacheRegion If cacheable, the region into which to store the results
 * @param timeout A JDBC-level timeout to be applied
 * @param fetchSize A JDBC-level fetch-size to be applied
 * @param flushMode The flush mode to use for this query
 * @param cacheMode The cache mode to use during execution and subsequent result loading
 * @param readOnly Whether returned entities should be marked as read-only in the session
 * @param comment Any sql comment to be applied to the query
 * @param parameterTypes parameter type map
 * @param callable Does the query string represent a callable object (i.e., proc)
 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 */
@Deprecated public NamedSQLQueryDefinition(String name,String query,String resultSetRef,List<String> querySpaces,boolean cacheable,String cacheRegion,Integer timeout,Integer fetchSize,FlushMode flushMode,CacheMode cacheMode,boolean readOnly,String comment,Map parameterTypes,boolean callable){
  this(name,query,cacheable,cacheRegion,timeout,fetchSize,flushMode,cacheMode,readOnly,comment,parameterTypes,null,null,resultSetRef,querySpaces,callable,null);
}
"
"/** 
 * Get the mapping from entity instance to entity entry
 * @deprecated Due to the introduction of EntityEntryContext and bytecode enhancement; only valid really forsizing, see  {@link #getNumberOfManagedEntities}.  For iterating the entity/EntityEntry combos, see {@link #reentrantSafeEntityEntries}
 */
@Deprecated public Map getEntityEntries();
"
"/** 
 * Apply an ""ilike"" constraint
 * @deprecated since 5.2, use {@link #ilike(String,MatchMode)}.  To be removed in 6.0.
 */
@Deprecated public AuditCriterion ilike(String value,org.hibernate.criterion.MatchMode matchMode){
  return new IlikeAuditExpression(alias,propertyNameGetter,matchMode.toMatchString(value));
}
"
"/** 
 * Apply an ""ilike"" constraint
 * @deprecated since 5.2, use {@link #ilike(String,MatchMode)}. To be removed in 6.0.
 */
@Deprecated public AuditCriterion ilike(String value,org.hibernate.criterion.MatchMode matchMode){
  return new IlikeAuditExpression(alias,propertyNameGetter,matchMode.toMatchString(value));
}
"
"/** 
 * @deprecated (since 5.2.1), while actually added in 5.2.1, this was added to cleanup theaudit strategy interface temporarily.
 */
@Deprecated public EnversService getEnversService(){
  return enversService;
}
"
"/** 
 * Perform resolution of a class name. <p/> Same as  {@link #classForName(String,Class)} except that here we delegate to{@link Class#forName(String)} if the context classloader lookup is unsuccessful.
 * @param name The class name
 * @return The class reference.
 * @throws ClassNotFoundException From {@link Class#forName(String)}.
 * @deprecated Depending on context, either {@link org.hibernate.boot.registry.classloading.spi.ClassLoaderService}or  {@link org.hibernate.boot.spi.ClassLoaderAccess} should be preferred
 */
@Deprecated public static Class classForName(String name) throws ClassNotFoundException {
  try {
    ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
    if (classLoader != null) {
      return classLoader.loadClass(name);
    }
  }
 catch (  Throwable ignore) {
  }
  return Class.forName(name);
}
"
"/** 
 * Make this go somewhere else.  These aren't really linked this way anymore.  ScrollableResultSetProcessor is not tied in yet, so not sure yet exactly how that will play out.
 * @deprecated Going away!
 */
@Deprecated public ScrollableResultSetProcessor toOnDemandForm();
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public String getQualifiedName(Dialect dialect,String defaultCatalog,String defaultSchema){
  if (subselect != null) {
    return ""( "" + subselect + "" )"";
  }
  String quotedName=getQuotedName(dialect);
  String usedSchema=schema == null ? defaultSchema : getQuotedSchema(dialect);
  String usedCatalog=catalog == null ? defaultCatalog : getQuotedCatalog(dialect);
  return qualify(usedCatalog,usedSchema,quotedName);
}
"
"/** 
 * @deprecated Should use {@link QualifiedObjectNameFormatter#format} on QualifiedObjectNameFormatterobtained from  {@link org.hibernate.engine.jdbc.env.spi.JdbcEnvironment}
 */
@Deprecated public static String qualify(String catalog,String schema,String table){
  StringBuilder qualifiedName=new StringBuilder();
  if (catalog != null) {
    qualifiedName.append(catalog).append('.');
  }
  if (schema != null) {
    qualifiedName.append(schema).append('.');
  }
  return qualifiedName.append(table).toString();
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * Get the current lock mode
 * @return LockMode
 * @deprecated Instead use getLockOptions
 */
@Deprecated public LockMode getLockMode(){
  return lockOptions.getLockMode();
}
"
"/** 
 * Set the lock mode
 * @param lockMode
 * @return this object
 * @deprecated Instead use setLockOptions
 */
@Deprecated public Select setLockMode(LockMode lockMode){
  lockOptions.setLockMode(lockMode);
  return this;
}
"
"/** 
 * Same functionality as  {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)}, except that a SQLFunctionRegistry is not provided (i.e., only the dialect-defined functions are considered).  This is only intended for use by the annotations project until the many-to-many/map-key-from-target-table feature is pulled into core.
 * @deprecated Only intended for annotations usage; use {@link #renderWhereStringTemplate(String,String,Dialect,SQLFunctionRegistry)} instead
 */
@Deprecated @SuppressWarnings({""JavaDoc""}) public static String renderWhereStringTemplate(String sqlWhereString,String placeholder,Dialect dialect){
  return renderWhereStringTemplate(sqlWhereString,placeholder,dialect,new SQLFunctionRegistry(dialect,java.util.Collections.<String,SQLFunction>emptyMap()));
}
"
"/** 
 * Performs order-by template rendering without  {@link ColumnMapper column mapping}.  An <tt>ORDER BY</tt> template has all column references ""qualified"" with a placeholder identified by  {@link Template#TEMPLATE}
 * @param orderByFragment The order-by fragment to render.
 * @param dialect The SQL dialect being used.
 * @param functionRegistry The SQL function registry
 * @return The rendered <tt>ORDER BY</tt> template.
 * @deprecated Use {@link #translateOrderBy} instead
 */
@Deprecated public static String renderOrderByStringTemplate(String orderByFragment,Dialect dialect,SQLFunctionRegistry functionRegistry){
  return renderOrderByStringTemplate(orderByFragment,NoOpColumnMapper.INSTANCE,null,dialect,functionRegistry);
}
"
"/** 
 * Perform resolution of a class name. <p/> Same as  {@link #classForName(String,Class)} except that here we delegate to{@link Class#forName(String)} if the context classloader lookup is unsuccessful.
 * @param name The class name
 * @return The class reference.
 * @throws ClassNotFoundException From {@link Class#forName(String)}.
 * @deprecated Depending on context, either {@link org.hibernate.boot.registry.classloading.spi.ClassLoaderService}or  {@link org.hibernate.boot.spi.ClassLoaderAccess} should be preferred
 */
@Deprecated public static Class classForName(String name) throws ClassNotFoundException {
  try {
    ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
    if (classLoader != null) {
      return classLoader.loadClass(name);
    }
  }
 catch (  Throwable ignore) {
  }
  return Class.forName(name);
}
"
"/** 
 * The class (which implements  {@link org.hibernate.id.IdentifierGenerator}) which acts as this dialects native generation strategy. <p/> Comes into play whenever the user specifies the native generator.
 * @return The native generator class.
 * @deprecated use {@link #getNativeIdentifierGeneratorStrategy()} instead
 */
@Deprecated public Class getNativeIdentifierGeneratorClass(){
  if (getIdentityColumnSupport().supportsIdentityColumns()) {
    return IdentityGenerator.class;
  }
 else {
    return SequenceStyleGenerator.class;
  }
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The class (which implements  {@link org.hibernate.id.IdentifierGenerator}) which acts as this dialects native generation strategy. <p/> Comes into play whenever the user specifies the native generator.
 * @return The native generator class.
 * @deprecated use {@link #getNativeIdentifierGeneratorStrategy()} instead
 */
@Deprecated public Class getNativeIdentifierGeneratorClass(){
  if (getIdentityColumnSupport().supportsIdentityColumns()) {
    return IdentityGenerator.class;
  }
 else {
    return SequenceStyleGenerator.class;
  }
}
"
"/** 
 * Does this dialect support identity column key generation?
 * @return True if IDENTITY columns are supported; false otherwise.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().supportsIdentityColumns()} does not delegateto this method, then this method is ignored.
 */
@Deprecated public boolean supportsIdentityColumns(){
  return false;
}
"
"/** 
 * Does the dialect support some form of inserting and selecting the generated IDENTITY value all in the same statement.
 * @return True if the dialect supports selecting the justgenerated IDENTITY in the insert statement.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().supportsInsertSelectIdentity()} does not delegateto this method, then this method is ignored.
 */
@Deprecated public boolean supportsInsertSelectIdentity(){
  return false;
}
"
"/** 
 * Whether this dialect have an Identity clause added to the data type or a completely separate identity data type
 * @return boolean
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().hasDataTypeInIdentityColumn()} does not delegateto this method, then this method is ignored.
 */
@Deprecated public boolean hasDataTypeInIdentityColumn(){
  return true;
}
"
"/** 
 * Provided we  {@link #supportsInsertSelectIdentity}, then attach the ""select identity"" clause to the  insert statement. <p/> Note, if  {@link #supportsInsertSelectIdentity} == false thenthe insert-string should be returned without modification.
 * @param insertString The insert command
 * @return The insert command with any necessary identity selectclause attached.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().appendIdentitySelectToInsert(String)} does not delegateto this method, then this method is ignored.
 */
@Deprecated public String appendIdentitySelectToInsert(String insertString){
  return insertString;
}
"
"/** 
 * Get the select command to use to retrieve the last generated IDENTITY value for a particular table
 * @param table The table into which the insert was done
 * @param column The PK column.
 * @param type The {@link java.sql.Types} type code.
 * @return The appropriate select command
 * @throws MappingException If IDENTITY generation is not supported.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().getIdentitySelectString(String,String,int)} does not delegateto this method, then this method is ignored.
 */
@Deprecated public String getIdentitySelectString(String table,String column,int type) throws MappingException {
  return getIdentitySelectString();
}
"
"/** 
 * The syntax used during DDL to define a column as being an IDENTITY of a particular type.
 * @param type The {@link java.sql.Types} type code.
 * @return The appropriate DDL fragment.
 * @throws MappingException If IDENTITY generation is not supported.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().getIdentityColumnString(int)} does not delegateto this method, then this method is ignored.
 */
@Deprecated public String getIdentityColumnString(int type) throws MappingException {
  return getIdentityColumnString();
}
"
"/** 
 * The keyword used to insert a generated value into an identity column (or null). Need if the dialect does not support inserts that specify no column values.
 * @return The appropriate keyword.
 * @deprecated {@link #getIdentityColumnSupport()} should be overridden instead;if  {@code getIdentityColumnSupport().getIdentityInsertString()} does not delegateto this method, then this method is ignored.
 */
@Deprecated public String getIdentityInsertString(){
  return null;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #buildLimitHandler(String,RowSelection)} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * Wrap the given value in the given Java numeric class.
 * @param value The primitive value to wrap.
 * @param clazz The Java numeric type in which to wrap the value.
 * @return The wrapped type.
 * @throws IdentifierGenerationException Indicates an unhandled 'clazz'.
 * @deprecated Use the {@link #getIntegralDataTypeHolder holders} instead.
 */
@Deprecated public static Number createNumber(long value,Class clazz) throws IdentifierGenerationException {
  if (clazz == Long.class) {
    return value;
  }
 else   if (clazz == Integer.class) {
    return (int)value;
  }
 else   if (clazz == Short.class) {
    return (short)value;
  }
 else {
    throw new IdentifierGenerationException(""unrecognized id type : "" + clazz.getName());
  }
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyInsertGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated no simple, direct replacement
 */
@Deprecated public ValueInclusion[] getPropertyUpdateGenerationInclusions(){
  return null;
}
"
"/** 
 * @deprecated Use {@link #ManyToOneType(TypeFactory.TypeScope,String,boolean,String,boolean,boolean,boolean,boolean) } instead.
 */
@Deprecated public ManyToOneType(TypeFactory.TypeScope scope,String referencedEntityName,String uniqueKeyPropertyName,boolean lazy,boolean unwrapProxy,boolean isEmbeddedInXML,boolean ignoreNotFound,boolean isLogicalOneToOne){
  this(scope,referencedEntityName,uniqueKeyPropertyName == null,uniqueKeyPropertyName,lazy,unwrapProxy,ignoreNotFound,isLogicalOneToOne);
}
"
"/** 
 * @deprecated Use {@link #connection()} instead
 */
@Override @Deprecated public SharedSessionBuilder transactionContext(){
  return connection();
}
"
"/** 
 * @deprecated (snce 6.0) SessionDelegatorBaseImpl should take just one argument, the SessionImplementor.Use the  {@link #SessionDelegatorBaseImpl(SessionImplementor)} form instead
 */
@Deprecated public SessionDelegatorBaseImpl(SessionImplementor delegate,Session session){
  if (delegate == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null delegate object"");
  }
  if (session == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null Session"");
  }
  if (delegate != session) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from different Session/SessionImplementor references"");
  }
  this.delegate=delegate;
}
"
"/** 
 * @deprecated (since 6.0) SessionDelegatorBaseImpl should take just one argument, the SessionImplementor.Use the  {@link #SessionDelegatorBaseImpl(SessionImplementor)} form instead
 */
@Deprecated public SessionDelegatorBaseImpl(SessionImplementor delegate,Session session){
  if (delegate == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null delegate object"");
  }
  if (session == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null Session"");
  }
  if (delegate != session) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from different Session/SessionImplementor references"");
  }
  this.delegate=delegate;
}
"
"/** 
 * Kept for compatibility reason but should be removed as soon as possible.
 * @deprecated use {@link #delegate()} instead
 */
@Deprecated public MetadataBuilderImplementor getDelegate(){
  return delegate;
}
"
"/** 
 * @deprecated (since 6.0) SessionDelegatorBaseImpl should take just one argument, the SessionImplementor.Use the  {@link #SessionDelegatorBaseImpl(SessionImplementor)} form instead
 */
@Deprecated public SessionDelegatorBaseImpl(SessionImplementor delegate,Session session){
  if (delegate == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null delegate object"");
  }
  if (session == null) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from a null Session"");
  }
  if (delegate != session) {
    throw new IllegalArgumentException(""Unable to create a SessionDelegatorBaseImpl from different Session/SessionImplementor references"");
  }
  this.delegate=delegate;
}
"
"/** 
 * Access to the delayed entity key
 * @return The delayed entity key
 * @deprecated No Hibernate code currently uses this method
 */
@Deprecated @SuppressWarnings(""UnusedDeclaration"") public EntityKey getDelayedEntityKey(){
  return delayedEntityKey;
}
"
"/** 
 * @param owner The owner
 * @deprecated Inject the owner into constructor.
 */
@Deprecated public void setOwner(PersistentClass owner){
  this.owner=owner;
}
"
"/** 
 * Perform resolution of a class name. <p/> Same as  {@link #classForName(String,Class)} except that here we delegate to{@link Class#forName(String)} if the context classloader lookup is unsuccessful.
 * @param name The class name
 * @return The class reference.
 * @throws ClassNotFoundException From {@link Class#forName(String)}.
 * @deprecated Depending on context, either {@link org.hibernate.boot.registry.classloading.spi.ClassLoaderService}or  {@link org.hibernate.boot.spi.ClassLoaderAccess} should be preferred
 */
@Deprecated public static Class classForName(String name) throws ClassNotFoundException {
  try {
    ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
    if (classLoader != null) {
      return classLoader.loadClass(name);
    }
  }
 catch (  Throwable ignore) {
  }
  return Class.forName(name);
}
"
"/** 
 * The class (which implements  {@link org.hibernate.id.IdentifierGenerator}) which acts as this dialects native generation strategy. <p/> Comes into play whenever the user specifies the native generator.
 * @return The native generator class.
 * @deprecated use {@link #getNativeIdentifierGeneratorStrategy()} instead
 */
@Deprecated public Class getNativeIdentifierGeneratorClass(){
  if (getIdentityColumnSupport().supportsIdentityColumns()) {
    return IdentityGenerator.class;
  }
 else {
    return SequenceStyleGenerator.class;
  }
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Some dialects have trouble applying pessimistic locking depending upon what other query options are specified (paging, ordering, etc).  This method allows these dialects to request that locking be applied by subsequent selects.
 * @return {@code true} indicates that the dialect requests that locking be applied by subsequent select;{@code false} (the default) indicates that locking should be applied to the main SQL statement..
 * @deprecated Use {@link #useFollowOnLocking(QueryParameters)} instead.
 */
@Deprecated public boolean useFollowOnLocking(){
  return useFollowOnLocking(null);
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
"/** 
 * The class (which implements  {@link org.hibernate.id.IdentifierGenerator}) which acts as this dialects native generation strategy. <p/> Comes into play whenever the user specifies the native generator.
 * @return The native generator class.
 * @deprecated use {@link #getNativeIdentifierGeneratorStrategy()} instead
 */
@Deprecated public Class getNativeIdentifierGeneratorClass(){
  if (getIdentityColumnSupport().supportsIdentityColumns()) {
    return IdentityGenerator.class;
  }
 else {
    return SequenceStyleGenerator.class;
  }
}
"
"/** 
 * The multiline script used to create a sequence.
 * @param sequenceName The name of the sequence
 * @return The sequence creation commands
 * @throws MappingException If sequences are not supported.
 * @deprecated Use {@link #getCreateSequenceString(String,int,int)} instead
 */
@Deprecated public String[] getCreateSequenceStrings(String sequenceName) throws MappingException {
  return new String[]{getCreateSequenceString(sequenceName)};
}
"
"/** 
 * Does this dialect support some form of limiting query results via a SQL clause?
 * @return True if this dialect supports some form of LIMIT.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimit(){
  return false;
}
"
"/** 
 * Does this dialect's LIMIT support (if any) additionally support specifying an offset?
 * @return True if the dialect supports an offset within the limit support.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsLimitOffset(){
  return supportsLimit();
}
"
"/** 
 * Does this dialect support bind variables (i.e., prepared statement parameters) for its limit/offset?
 * @return True if bind variables can be used; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean supportsVariableLimit(){
  return supportsLimit();
}
"
"/** 
 * ANSI SQL defines the LIMIT clause to be in the form LIMIT offset, limit. Does this dialect require us to bind the parameters in reverse order?
 * @return true if the correct order is limit, offset
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersInReverseOrder(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause come at the start of the <tt>SELECT</tt> statement, rather than at the end?
 * @return true if limit parameters should come before other parameters
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean bindLimitParametersFirst(){
  return false;
}
"
"/** 
 * Does the <tt>LIMIT</tt> clause take a ""maximum"" row number instead of a total number of returned rows? <p/> This is easiest understood via an example.  Consider you have a table with 20 rows, but you only want to retrieve rows number 11 through 20. Generally, a limit with offset would say that the offset = 11 and the limit = 10 (we only want 10 rows at a time); this is specifying the total number of returned rows.  Some dialects require that we instead specify offset = 11 and limit = 20, where 20 is the ""last"" row we want relative to offset (i.e. total number of rows = 20 - 11 = 9) <p/> So essentially, is limit relative from offset?  Or is limit absolute?
 * @return True if limit is relative from offset; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean useMaxForLimit(){
  return false;
}
"
"/** 
 * Generally, if there is no limit applied to a Hibernate query we do not apply any limits to the SQL query.  This option forces that the limit be written to the SQL query.
 * @return True to force limit into SQL query even if none specified in Hibernate query; false otherwise.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public boolean forceLimitUsage(){
  return false;
}
"
"/** 
 * Given a limit and an offset, apply the limit clause to the query.
 * @param query The query to which to apply the limit.
 * @param offset The offset of the limit
 * @param limit The limit of the limit ;)
 * @return The modified query statement with the limit applied.
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public String getLimitString(String query,int offset,int limit){
  return getLimitString(query,(offset > 0 || forceLimitUsage()));
}
"
"/** 
 * Hibernate APIs explicitly state that setFirstResult() should be a zero-based offset. Here we allow the Dialect a chance to convert that value based on what the underlying db or driver will expect. <p/> NOTE: what gets passed into  {@link #getLimitString(String,int,int)} is the zero-based offset.  Dialects whichdo not  {@link #supportsVariableLimit} should take care to perform any needed first-row-conversion calls priorto injecting the limit values into the SQL string.
 * @param zeroBasedFirstResult The user-supplied, zero-based first row offset.
 * @return The corresponding db/dialect specific offset.
 * @see org.hibernate.Query#setFirstResult
 * @see org.hibernate.Criteria#setFirstResult
 * @deprecated {@link #getLimitHandler()} should be overridden instead.
 */
@Deprecated public int convertToFirstRowValue(int zeroBasedFirstResult){
  return zeroBasedFirstResult;
}
"
"/** 
 * Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>, whereby a ""lock hint"" is appends to the table name in the from clause. <p/> contributed by <a href=""http://sourceforge.net/users/heschulz"">Helge Schulz</a>
 * @param mode The lock mode to apply
 * @param tableName The name of the table to which to apply the lock hint.
 * @return The table with any required lock hints.
 * @deprecated use {@code appendLockHint(LockOptions,String)} instead
 */
@Deprecated public String appendLockHint(LockMode mode,String tableName){
  return appendLockHint(new LockOptions(mode),tableName);
}
"
"/** 
 * Build an instance of the SQLExceptionConverter preferred by this dialect for converting SQLExceptions into Hibernate's JDBCException hierarchy. <p/> The preferred method is to not override this method; if possible, {@link #buildSQLExceptionConversionDelegate()} should be overriddeninstead. If this method is not overridden, the default SQLExceptionConverter implementation executes 3 SQLException converter delegates: <ol> <li>a ""static"" delegate based on the JDBC 4 defined SQLException hierarchy;</li> <li>the vendor-specific delegate returned by  {@link #buildSQLExceptionConversionDelegate()}; (it is strongly recommended that specific Dialect implementations override  {@link #buildSQLExceptionConversionDelegate()})</li> <li>a delegate that interprets SQLState codes for either X/Open or SQL-2003 codes, depending on java.sql.DatabaseMetaData#getSQLStateType</li> </ol> <p/> If this method is overridden, it is strongly recommended that the returned  {@link SQLExceptionConverter} interpret SQL errors based onvendor-specific error codes rather than the SQLState since the interpretation is more accurate when using vendor-specific ErrorCodes.
 * @return The Dialect's preferred SQLExceptionConverter, or null toindicate that the default  {@link SQLExceptionConverter} should be used.
 * @see {@link #buildSQLExceptionConversionDelegate()}
 * @deprecated {@link #buildSQLExceptionConversionDelegate()} should beoverridden instead.
 */
@Deprecated public SQLExceptionConverter buildSQLExceptionConverter(){
  return null;
}
"
"/** 
 * @deprecated These are only ever used (if at all) from the code that handles identifier quoting.  Sosee  {@link #buildIdentifierHelper} instead
 */
@Deprecated public Set<String> getKeywords(){
  return sqlKeywords;
}
"
"/** 
 * Some dialects have trouble applying pessimistic locking depending upon what other query options are specified (paging, ordering, etc).  This method allows these dialects to request that locking be applied by subsequent selects.
 * @return {@code true} indicates that the dialect requests that locking be applied by subsequent select;{@code false} (the default) indicates that locking should be applied to the main SQL statement..
 * @deprecated Use {@link #useFollowOnLocking(QueryParameters)} instead.
 */
@Deprecated public boolean useFollowOnLocking(){
  return useFollowOnLocking(null);
}
"
"/** 
 * Does this dialect support the <tt>UNIQUE</tt> column syntax?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUnique(){
  return true;
}
"
"/** 
 * Does this dialect support adding Unique constraints via create and alter table ?
 * @return boolean
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsUniqueConstraintInCreateAlterTable(){
  return true;
}
"
"/** 
 * The syntax used to add a unique constraint to a table.
 * @param constraintName The name of the unique constraint.
 * @return The ""add unique"" fragment
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public String getAddUniqueConstraintString(String constraintName){
  return "" add constraint "" + constraintName + "" unique "";
}
"
"/** 
 * Is the combination of not-null and unique supported?
 * @return deprecated
 * @deprecated {@link #getUniqueDelegate()} should be overridden instead.
 */
@Deprecated public boolean supportsNotNullUnique(){
  return true;
}
"
