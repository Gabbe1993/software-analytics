"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
public static Set createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet(initialCapacity);
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
public static Map createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Set createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Set createCopyOnWriteSet(){
  return new CopyOnWriteArraySet();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 required JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 required JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Determine if the given target type is assignable from the given value type, assuming setting by reflection. Considers primitive wrapper classes as assignable to the corresponding primitive types.
 * @param targetType the target type
 * @param valueType the value type that should be assigned to the target type
 * @return if the target type is assignable from the value type
 * @deprecated as of Spring 2.0, in favor of <code>ClassUtils.isAssignable</code>
 * @see org.springframework.util.ClassUtils#isAssignable(Class,Class)
 */
public static boolean isAssignable(Class targetType,Class valueType){
  return ClassUtils.isAssignable(targetType,valueType);
}
"
"/** 
 * Determine if the given type is assignable from the given value, assuming setting by reflection. Considers primitive wrapper classes as assignable to the corresponding primitive types.
 * @param type the target type
 * @param value the value that should be assigned to the type
 * @return if the type is assignable from the value
 * @deprecated as of Spring 2.0, in favor of <code>ClassUtils.isAssignableValue</code>
 * @see org.springframework.util.ClassUtils#isAssignableValue(Class,Object)
 */
public static boolean isAssignable(Class type,Object value){
  return ClassUtils.isAssignableValue(type,value);
}
"
"/** 
 * @deprecated in favor of <code>convertIfNecessary</code>
 * @see #convertIfNecessary(Object,Class)
 */
public Object doTypeConversionIfNecessary(Object value,Class requiredType) throws TypeMismatchException {
  return convertIfNecessary(value,requiredType,null);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link #registerAutoProxyCreatorIfNecessary(ParserContext,Element)} and{@link AopConfigUtils#registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry,Object)}
 */
public static void registerAutoProxyCreatorIfNecessary(ParserContext parserContext,Object source){
  BeanDefinition beanDefinition=AopConfigUtils.registerAutoProxyCreatorIfNecessary(parserContext.getRegistry(),source);
  registerComponentIfNecessary(beanDefinition,parserContext);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link AopConfigUtils#forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry)}
 */
public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry){
  AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
}
"
"/** 
 * Override settings in this bean definition (assumably a copied parent from a parent-child inheritance relationship) from the given bean definition (assumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Set the name of the factory bean to use for this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
public BeanDefinitionBuilder setFactoryBean(String factoryBean,String factoryMethod){
  this.beanDefinition.setFactoryBeanName(factoryBean);
  this.beanDefinition.setFactoryMethodName(factoryMethod);
  return this;
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Set whether or not this definition describes a singleton bean, as alternative to  {@link #setScope}.
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
public BeanDefinitionBuilder setSingleton(boolean singleton){
  this.beanDefinition.setSingleton(singleton);
  return this;
}
"
"/** 
 * Set the source of this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
public BeanDefinitionBuilder setSource(Object source){
  this.beanDefinition.setSource(source);
  return this;
}
"
"/** 
 * Set the description associated with this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
public BeanDefinitionBuilder setResourceDescription(String resourceDescription){
  this.beanDefinition.setResourceDescription(resourceDescription);
  return this;
}
"
"/** 
 * Create a new GenericBeanDefinition for the given class name, parent, constructor arguments, and property values.
 * @param className the name of the bean class, if any
 * @param parentName the name of the parent bean, if any
 * @param cargs the constructor arguments, if any
 * @param pvs the property values, if any
 * @param classLoader the ClassLoader to use for loading bean classes(can be <code>null</code> to just register bean classes by name)
 * @return the bean definition
 * @throws ClassNotFoundException if the bean class could not be loaded
 * @deprecated in favor of <code>createBeanDefinition(String, String, ClassLoader)</code>
 * @see #createBeanDefinition(String,String,ClassLoader)
 */
public static AbstractBeanDefinition createBeanDefinition(String className,String parentName,ConstructorArgumentValues cargs,MutablePropertyValues pvs,ClassLoader classLoader) throws ClassNotFoundException {
  AbstractBeanDefinition bd=createBeanDefinition(parentName,className,classLoader);
  bd.setConstructorArgumentValues(cargs);
  bd.setPropertyValues(pvs);
  return bd;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Determine the target class of the given bean instance, which might be an AOP proxy. <p>Returns the target class for an AOP proxy and the plain class else.
 * @param candidate the instance to check (might be an AOP proxy)
 * @return the target class (or the plain class of the given object as fallback)
 * @deprecated as of Spring 2.0.3, in favor of <code>AopUtils.getTargetClass</code>
 * @see org.springframework.aop.support.AopUtils#getTargetClass(Object)
 */
public static Class getTargetClass(Object candidate){
  Assert.notNull(candidate,""Candidate object must not be null"");
  if (AopUtils.isCglibProxy(candidate)) {
    return candidate.getClass().getSuperclass();
  }
  if (candidate instanceof Advised) {
    return ((Advised)candidate).getTargetSource().getTargetClass();
  }
  return candidate.getClass();
}
"
"/** 
 * Set if the XML parser should validate the document and thus enforce a DTD.
 * @deprecated as of Spring 2.0: superseded by ""validationMode""
 * @see #setValidationMode
 */
public void setValidating(boolean validating){
  this.validationMode=(validating ? VALIDATION_AUTO : VALIDATION_NONE);
}
"
"/** 
 * Set the XmlBeanDefinitionParser implementation to use, responsible for the actual parsing of XML bean definitions.
 * @deprecated as of Spring 2.0: superseded by ""documentReaderClass""
 * @see #setDocumentReaderClass
 * @see XmlBeanDefinitionParser
 */
public void setParserClass(Class parserClass){
  if (this.parserClass == null || !XmlBeanDefinitionParser.class.isAssignableFrom(parserClass)) {
    throw new IllegalArgumentException(""'parserClass' must be an XmlBeanDefinitionParser"");
  }
  this.parserClass=parserClass;
}
"
"/** 
 * Apply the given method invocation to the given RMI stub. <p>Delegates to the corresponding method if the RMI stub does not directly implement the invoked method. This typically happens when a non-RMI service interface is used for an RMI service. The methods of such a service interface have to match the RMI stub methods, but they typically don't declare <code>java.rmi.RemoteException</code>: A RemoteException thrown by the RMI stub will be automatically converted to Spring's RemoteAccessException.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
public static Object invoke(MethodInvocation invocation,Remote stub,String serviceName) throws Throwable {
  try {
    return invokeRemoteMethod(invocation,stub);
  }
 catch (  InvocationTargetException ex) {
    Throwable targetEx=ex.getTargetException();
    if (targetEx instanceof RemoteException) {
      RemoteException rex=(RemoteException)targetEx;
      throw convertRmiAccessException(invocation.getMethod(),rex,serviceName);
    }
 else {
      throw targetEx;
    }
  }
}
"
"/** 
 * Perform a raw method invocation on the given RMI stub, letting reflection exceptions through as-is.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
public static Object doInvoke(MethodInvocation invocation,Remote stub) throws InvocationTargetException {
  return invokeRemoteMethod(invocation,stub);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link #registerAutoProxyCreatorIfNecessary(ParserContext,Element)} and{@link AopConfigUtils#registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry,Object)}
 */
@Deprecated public static void registerAutoProxyCreatorIfNecessary(ParserContext parserContext,Object source){
  BeanDefinition beanDefinition=AopConfigUtils.registerAutoProxyCreatorIfNecessary(parserContext.getRegistry(),source);
  registerComponentIfNecessary(beanDefinition,parserContext);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link AopConfigUtils#forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry)}
 */
@Deprecated public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry){
  AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
}
"
"/** 
 * Determine the target class of the given bean instance, which might be an AOP proxy. <p>Returns the target class for an AOP proxy and the plain class else.
 * @param candidate the instance to check (might be an AOP proxy)
 * @return the target class (or the plain class of the given object as fallback)
 * @deprecated as of Spring 2.0.3, in favor of <code>AopUtils.getTargetClass</code>
 * @see org.springframework.aop.support.AopUtils#getTargetClass(Object)
 */
@Deprecated public static Class getTargetClass(Object candidate){
  Assert.notNull(candidate,""Candidate object must not be null"");
  if (AopUtils.isCglibProxy(candidate)) {
    return candidate.getClass().getSuperclass();
  }
  if (candidate instanceof Advised) {
    return ((Advised)candidate).getTargetSource().getTargetClass();
  }
  return candidate.getClass();
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(String,Object)}
 */
public ModelMap addObject(String modelName,Object modelObject){
  return addAttribute(modelName,modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(Object)}
 */
public ModelMap addObject(Object modelObject){
  return addAttribute(modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Collection)}
 */
public ModelMap addAllObjects(Collection objects){
  return addAllAttributes(objects);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Map)}
 */
public ModelMap addAllObjects(Map objects){
  return addAllAttributes(objects);
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(String,Object)}
 */
public ModelMap addObject(String modelName,Object modelObject){
  return addAttribute(modelName,modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(Object)}
 */
public ModelMap addObject(Object modelObject){
  return addAttribute(modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Collection)}
 */
public ModelMap addAllObjects(Collection objects){
  return addAllAttributes(objects);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Map)}
 */
public ModelMap addAllObjects(Map objects){
  return addAllAttributes(objects);
}
"
"/** 
 * Determine if the given target type is assignable from the given value type, assuming setting by reflection. Considers primitive wrapper classes as assignable to the corresponding primitive types.
 * @param targetType the target type
 * @param valueType the value type that should be assigned to the target type
 * @return if the target type is assignable from the value type
 * @deprecated as of Spring 2.0, in favor of <code>ClassUtils.isAssignable</code>
 * @see org.springframework.util.ClassUtils#isAssignable(Class,Class)
 */
@Deprecated public static boolean isAssignable(Class targetType,Class valueType){
  return ClassUtils.isAssignable(targetType,valueType);
}
"
"/** 
 * Determine if the given type is assignable from the given value, assuming setting by reflection. Considers primitive wrapper classes as assignable to the corresponding primitive types.
 * @param type the target type
 * @param value the value that should be assigned to the type
 * @return if the type is assignable from the value
 * @deprecated as of Spring 2.0, in favor of <code>ClassUtils.isAssignableValue</code>
 * @see org.springframework.util.ClassUtils#isAssignableValue(Class,Object)
 */
@Deprecated public static boolean isAssignable(Class type,Object value){
  return ClassUtils.isAssignableValue(type,value);
}
"
"/** 
 * @deprecated in favor of <code>convertIfNecessary</code>
 * @see #convertIfNecessary(Object,Class)
 */
@Deprecated public Object doTypeConversionIfNecessary(Object value,Class requiredType) throws TypeMismatchException {
  return convertIfNecessary(value,requiredType,null);
}
"
"/** 
 * Override settings in this bean definition (assumably a copied parent from a parent-child inheritance relationship) from the given bean definition (assumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Set the name of the factory bean to use for this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setFactoryBean(String factoryBean,String factoryMethod){
  this.beanDefinition.setFactoryBeanName(factoryBean);
  this.beanDefinition.setFactoryMethodName(factoryMethod);
  return this;
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Set whether or not this definition describes a singleton bean, as alternative to  {@link #setScope}.
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public BeanDefinitionBuilder setSingleton(boolean singleton){
  this.beanDefinition.setSingleton(singleton);
  return this;
}
"
"/** 
 * Set the source of this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setSource(Object source){
  this.beanDefinition.setSource(source);
  return this;
}
"
"/** 
 * Set the description associated with this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setResourceDescription(String resourceDescription){
  this.beanDefinition.setResourceDescription(resourceDescription);
  return this;
}
"
"/** 
 * Create a new GenericBeanDefinition for the given class name, parent, constructor arguments, and property values.
 * @param className the name of the bean class, if any
 * @param parentName the name of the parent bean, if any
 * @param cargs the constructor arguments, if any
 * @param pvs the property values, if any
 * @param classLoader the ClassLoader to use for loading bean classes(can be <code>null</code> to just register bean classes by name)
 * @return the bean definition
 * @throws ClassNotFoundException if the bean class could not be loaded
 * @deprecated in favor of <code>createBeanDefinition(String, String, ClassLoader)</code>
 * @see #createBeanDefinition(String,String,ClassLoader)
 */
@Deprecated public static AbstractBeanDefinition createBeanDefinition(String className,String parentName,ConstructorArgumentValues cargs,MutablePropertyValues pvs,ClassLoader classLoader) throws ClassNotFoundException {
  AbstractBeanDefinition bd=createBeanDefinition(parentName,className,classLoader);
  bd.setConstructorArgumentValues(cargs);
  bd.setPropertyValues(pvs);
  return bd;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Set if the XML parser should validate the document and thus enforce a DTD.
 * @deprecated as of Spring 2.0: superseded by ""validationMode""
 * @see #setValidationMode
 */
@Deprecated public void setValidating(boolean validating){
  this.validationMode=(validating ? VALIDATION_AUTO : VALIDATION_NONE);
}
"
"/** 
 * Set the XmlBeanDefinitionParser implementation to use, responsible for the actual parsing of XML bean definitions.
 * @deprecated as of Spring 2.0: superseded by ""documentReaderClass""
 * @see #setDocumentReaderClass
 * @see XmlBeanDefinitionParser
 */
@Deprecated public void setParserClass(Class parserClass){
  if (this.parserClass == null || !XmlBeanDefinitionParser.class.isAssignableFrom(parserClass)) {
    throw new IllegalArgumentException(""'parserClass' must be an XmlBeanDefinitionParser"");
  }
  this.parserClass=parserClass;
}
"
"/** 
 * Constructor for CannotGetJdbcConnectionException.
 * @param msg the detail message
 * @param ex ClassNotFoundException root cause
 * @deprecated since Spring 2.5, in favor of throwing anIllegalStateException in case of the driver not being found
 */
public CannotGetJdbcConnectionException(String msg,ClassNotFoundException ex){
  super(msg,ex);
}
"
"/** 
 * Create a new DriverManagerDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @deprecated since Spring 2.5. DriverManagerDataSource is primarilyintended for accessing <i>pre-registered</i> JDBC drivers. If you need to register a new driver, consider using {@link SimpleDriverDataSource} instead.
 */
public DriverManagerDataSource(String driverClassName,String url,String username,String password){
  setDriverClassName(driverClassName);
  setUrl(url);
  setUsername(username);
  setPassword(password);
}
"
"/** 
 * Create a new SingleConnectionDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @param suppressClose if the returned Connection should be aclose-suppressing proxy or the physical Connection
 * @deprecated since Spring 2.5. Driver parameter usage is generally not recommendedfor a SingleConnectionDataSource. If you insist on using driver parameters directly, set up the Driver class manually before invoking this DataSource.
 * @see java.sql.DriverManager#getConnection(String,String,String)
 */
public SingleConnectionDataSource(String driverClassName,String url,String username,String password,boolean suppressClose){
  super(driverClassName,url,username,password);
  this.suppressClose=suppressClose;
}
"
"/** 
 * Set a List of <code>TemplateLoader<code>s that will be used to search for templates. For example, one or more custom loaders such as database loaders could be configured and injected here.
 * @deprecated as of Spring 2.0.1, in favor of the ""preTemplateLoaders""and ""postTemplateLoaders"" properties
 * @see #setPreTemplateLoaders
 * @see #setPostTemplateLoaders
 */
public void setTemplateLoaders(TemplateLoader[] templateLoaders){
  if (templateLoaders != null) {
    this.templateLoaders.addAll(Arrays.asList(templateLoaders));
  }
}
"
"/** 
 * Execute the action specified by the given action object within a Session.
 * @param action callback object that specifies the Hibernate action
 * @param enforceNativeSession whether to enforce exposure of the nativeHibernate Session to callback code
 * @return a result object returned by the action, or <code>null</code>
 * @throws org.springframework.dao.DataAccessException in case of Hibernate errors
 * @deprecated as of Spring 2.5, in favor of {@link #executeWithNativeSession}
 */
public Object execute(HibernateCallback action,boolean enforceNativeSession) throws DataAccessException {
  return doExecute(action,false,enforceNativeSession);
}
"
"/** 
 * @deprecated as of iBATIS 2.3.0
 */
public PaginatedList queryForPaginatedList(String statementName,int pageSize) throws DataAccessException {
  return queryForPaginatedList(statementName,null,pageSize);
}
"
"/** 
 * @deprecated as of iBATIS 2.3.0
 */
public PaginatedList queryForPaginatedList(final String statementName,final Object parameterObject,final int pageSize) throws DataAccessException {
  if (!this.lazyLoadingAvailable) {
    throw new InvalidDataAccessApiUsageException(""SqlMapClient needs to have DataSource to allow for lazy loading"" + "" - specify SqlMapClientFactoryBean's 'dataSource' property"");
  }
  return (PaginatedList)execute(new SqlMapClientCallback(){
    public Object doInSqlMapClient(    SqlMapExecutor executor) throws SQLException {
      return executor.queryForPaginatedList(statementName,parameterObject,pageSize);
    }
  }
);
}
"
"/** 
 * @deprecated in favor of {@link #makePersistent(Object)}. To be removed in Spring 3.0.
 */
public Object attachCopy(Object detachedEntity){
  return makePersistent(detachedEntity);
}
"
"/** 
 * @deprecated in favor of {@link #makePersistentAll(java.util.Collection)}. To be removed in Spring 3.0.
 */
public Collection attachCopyAll(Collection detachedEntities){
  return makePersistentAll(detachedEntities);
}
"
"/** 
 * @deprecated in favor of addUserRole
 * @see #addUserRole
 */
public void addRole(String role){
  addUserRole(role);
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Set createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Set createCopyOnWriteSet(){
  return new CopyOnWriteArraySet();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 required JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 required JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * @deprecated in favor of <code>convertIfNecessary</code>
 * @see #convertIfNecessary(Object,Class)
 */
@Deprecated public Object doTypeConversionIfNecessary(Object value,Class requiredType) throws TypeMismatchException {
  return convertIfNecessary(value,requiredType,null);
}
"
"/** 
 * Override settings in this bean definition (assumably a copied parent from a parent-child inheritance relationship) from the given bean definition (assumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Set createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Set createCopyOnWriteSet(){
  return new CopyOnWriteArraySet();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 required JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 required JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Apply the given method invocation to the given RMI stub. <p>Delegates to the corresponding method if the RMI stub does not directly implement the invoked method. This typically happens when a non-RMI service interface is used for an RMI service. The methods of such a service interface have to match the RMI stub methods, but they typically don't declare <code>java.rmi.RemoteException</code>: A RemoteException thrown by the RMI stub will be automatically converted to Spring's RemoteAccessException.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object invoke(MethodInvocation invocation,Remote stub,String serviceName) throws Throwable {
  try {
    return invokeRemoteMethod(invocation,stub);
  }
 catch (  InvocationTargetException ex) {
    Throwable targetEx=ex.getTargetException();
    if (targetEx instanceof RemoteException) {
      RemoteException rex=(RemoteException)targetEx;
      throw convertRmiAccessException(invocation.getMethod(),rex,serviceName);
    }
 else {
      throw targetEx;
    }
  }
}
"
"/** 
 * Perform a raw method invocation on the given RMI stub, letting reflection exceptions through as-is.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object doInvoke(MethodInvocation invocation,Remote stub) throws InvocationTargetException {
  return invokeRemoteMethod(invocation,stub);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(String,Object)}
 */
@Deprecated public ModelMap addObject(String modelName,Object modelObject){
  return addAttribute(modelName,modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(Object)}
 */
@Deprecated public ModelMap addObject(Object modelObject){
  return addAttribute(modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Collection)}
 */
@Deprecated public ModelMap addAllObjects(Collection objects){
  return addAllAttributes(objects);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Map)}
 */
@Deprecated public ModelMap addAllObjects(Map objects){
  return addAllAttributes(objects);
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Set createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Set createCopyOnWriteSet(){
  return new CopyOnWriteArraySet();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 required JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 required JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Constructor for CannotGetJdbcConnectionException.
 * @param msg the detail message
 * @param ex ClassNotFoundException root cause
 * @deprecated since Spring 2.5, in favor of throwing anIllegalStateException in case of the driver not being found
 */
@Deprecated public CannotGetJdbcConnectionException(String msg,ClassNotFoundException ex){
  super(msg,ex);
}
"
"/** 
 * Create a new DriverManagerDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @deprecated since Spring 2.5. DriverManagerDataSource is primarilyintended for accessing <i>pre-registered</i> JDBC drivers. If you need to register a new driver, consider using {@link SimpleDriverDataSource} instead.
 */
@Deprecated public DriverManagerDataSource(String driverClassName,String url,String username,String password){
  setDriverClassName(driverClassName);
  setUrl(url);
  setUsername(username);
  setPassword(password);
}
"
"/** 
 * Create a new SingleConnectionDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @param suppressClose if the returned Connection should be aclose-suppressing proxy or the physical Connection
 * @deprecated since Spring 2.5. Driver parameter usage is generally not recommendedfor a SingleConnectionDataSource. If you insist on using driver parameters directly, set up the Driver class manually before invoking this DataSource.
 * @see java.sql.DriverManager#getConnection(String,String,String)
 */
@Deprecated public SingleConnectionDataSource(String driverClassName,String url,String username,String password,boolean suppressClose){
  super(driverClassName,url,username,password);
  this.suppressClose=suppressClose;
}
"
"/** 
 * Execute the action specified by the given action object within a Session.
 * @param action callback object that specifies the Hibernate action
 * @param enforceNativeSession whether to enforce exposure of the nativeHibernate Session to callback code
 * @return a result object returned by the action, or <code>null</code>
 * @throws org.springframework.dao.DataAccessException in case of Hibernate errors
 * @deprecated as of Spring 2.5, in favor of {@link #executeWithNativeSession}
 */
@Deprecated public Object execute(HibernateCallback action,boolean enforceNativeSession) throws DataAccessException {
  return doExecute(action,false,enforceNativeSession);
}
"
"/** 
 * @deprecated as of iBATIS 2.3.0
 */
@Deprecated public PaginatedList queryForPaginatedList(String statementName,int pageSize) throws DataAccessException {
  return queryForPaginatedList(statementName,null,pageSize);
}
"
"/** 
 * @deprecated as of iBATIS 2.3.0
 */
@Deprecated public PaginatedList queryForPaginatedList(final String statementName,final Object parameterObject,final int pageSize) throws DataAccessException {
  if (!this.lazyLoadingAvailable) {
    throw new InvalidDataAccessApiUsageException(""SqlMapClient needs to have DataSource to allow for lazy loading"" + "" - specify SqlMapClientFactoryBean's 'dataSource' property"");
  }
  return (PaginatedList)execute(new SqlMapClientCallback(){
    public Object doInSqlMapClient(    SqlMapExecutor executor) throws SQLException {
      return executor.queryForPaginatedList(statementName,parameterObject,pageSize);
    }
  }
);
}
"
"/** 
 * @deprecated in favor of {@link #makePersistent(Object)}. To be removed in Spring 3.0.
 */
@Deprecated public Object attachCopy(Object detachedEntity){
  return makePersistent(detachedEntity);
}
"
"/** 
 * @deprecated in favor of {@link #makePersistentAll(java.util.Collection)}. To be removed in Spring 3.0.
 */
@Deprecated public Collection attachCopyAll(Collection detachedEntities){
  return makePersistentAll(detachedEntities);
}
"
"/** 
 * Set a List of <code>TemplateLoader<code>s that will be used to search for templates. For example, one or more custom loaders such as database loaders could be configured and injected here.
 * @deprecated as of Spring 2.0.1, in favor of the ""preTemplateLoaders""and ""postTemplateLoaders"" properties
 * @see #setPreTemplateLoaders
 * @see #setPostTemplateLoaders
 */
@Deprecated public void setTemplateLoaders(TemplateLoader[] templateLoaders){
  if (templateLoaders != null) {
    this.templateLoaders.addAll(Arrays.asList(templateLoaders));
  }
}
"
"/** 
 * @deprecated in favor of addUserRole
 * @see #addUserRole
 */
public void addRole(String role){
  addUserRole(role);
}
"
"/** 
 * @deprecated in favor of addUserRole
 * @see #addUserRole
 */
public void addRole(String role){
  addUserRole(role);
}
"
"/** 
 * Override settings in this bean definition (assumably a copied parent from a parent-child inheritance relationship) from the given bean definition (assumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Return the ContextLoader used by this listener.
 * @return the current ContextLoader
 * @deprecated in favor of simply subclassing ContextLoaderListener itself(which extends ContextLoader, as of Spring 3.0)
 */
@Deprecated public ContextLoader getContextLoader(){
  return this.contextLoader;
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(String,Object)}
 */
@Deprecated public ModelMap addObject(String modelName,Object modelObject){
  return addAttribute(modelName,modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(Object)}
 */
@Deprecated public ModelMap addObject(Object modelObject){
  return addAttribute(modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Collection)}
 */
@Deprecated public ModelMap addAllObjects(Collection objects){
  return addAllAttributes(objects);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Map)}
 */
@Deprecated public ModelMap addAllObjects(Map objects){
  return addAllAttributes(objects);
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Set createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Set createCopyOnWriteSet(){
  return new CopyOnWriteArraySet();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.4.
 * @return <code>true</code> if the current JVM is at least Java 1.4
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_14
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava14(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.5 (Java 5).
 * @return <code>true</code> if the current JVM is at least Java 1.5
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava15(){
  return true;
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Create a new DriverManagerDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @deprecated since Spring 2.5. DriverManagerDataSource is primarilyintended for accessing <i>pre-registered</i> JDBC drivers. If you need to register a new driver, consider using {@link SimpleDriverDataSource} instead.
 */
@Deprecated public DriverManagerDataSource(String driverClassName,String url,String username,String password){
  setDriverClassName(driverClassName);
  setUrl(url);
  setUsername(username);
  setPassword(password);
}
"
"/** 
 * Override settings in this bean definition (assumably a copied parent from a parent-child inheritance relationship) from the given bean definition (assumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Execute the action specified by the given action object within a Session.
 * @param action callback object that specifies the Hibernate action
 * @param enforceNativeSession whether to enforce exposure of the nativeHibernate Session to callback code
 * @return a result object returned by the action, or <code>null</code>
 * @throws org.springframework.dao.DataAccessException in case of Hibernate errors
 * @deprecated as of Spring 2.5, in favor of {@link #executeWithNativeSession}
 */
@Deprecated public Object execute(HibernateCallback action,boolean enforceNativeSession) throws DataAccessException {
  return doExecute(action,false,enforceNativeSession);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Set a List of <code>TemplateLoader<code>s that will be used to search for templates. For example, one or more custom loaders such as database loaders could be configured and injected here.
 * @deprecated as of Spring 2.0.1, in favor of the ""preTemplateLoaders""and ""postTemplateLoaders"" properties
 * @see #setPreTemplateLoaders
 * @see #setPostTemplateLoaders
 */
@Deprecated public void setTemplateLoaders(TemplateLoader[] templateLoaders){
  if (templateLoaders != null) {
    this.templateLoaders.addAll(Arrays.asList(templateLoaders));
  }
}
"
"/** 
 * Create a new SingleConnectionDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @param suppressClose if the returned Connection should be aclose-suppressing proxy or the physical Connection
 * @deprecated since Spring 2.5. Driver parameter usage is generally not recommendedfor a SingleConnectionDataSource. If you insist on using driver parameters directly, set up the Driver class manually before invoking this DataSource.
 * @see java.sql.DriverManager#getConnection(String,String,String)
 */
@Deprecated public SingleConnectionDataSource(String driverClassName,String url,String username,String password,boolean suppressClose){
  super(driverClassName,url,username,password);
  this.suppressClose=suppressClose;
}
"
"/** 
 * Execute the action specified by the given action object within a Session.
 * @param action callback object that specifies the Hibernate action
 * @param enforceNativeSession whether to enforce exposure of the nativeHibernate Session to callback code
 * @return a result object returned by the action, or <code>null</code>
 * @throws org.springframework.dao.DataAccessException in case of Hibernate errors
 * @deprecated as of Spring 2.5, in favor of {@link #executeWithNativeSession}
 */
@Deprecated public Object execute(HibernateCallback action,boolean enforceNativeSession) throws DataAccessException {
  return doExecute(action,false,enforceNativeSession);
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a List result.
 * @param action callback object that specifies the data access action
 * @return the List result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public List executeWithListResult(SqlMapClientCallback<List> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a Map result.
 * @param action callback object that specifies the data access action
 * @return the Map result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public Map executeWithMapResult(SqlMapClientCallback<Map> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * @deprecated {@link XMLInputStream} 
 */
public static org.springframework.oxm.xmlbeans.FlightDocument parse(org.apache.xmlbeans.xml.stream.XMLInputStream xis) throws org.apache.xmlbeans.XmlException, org.apache.xmlbeans.xml.stream.XMLStreamException {
  return (org.springframework.oxm.xmlbeans.FlightDocument)org.apache.xmlbeans.XmlBeans.getContextTypeLoader().parse(xis,type,null);
}
"
"/** 
 * @deprecated {@link XMLInputStream} 
 */
public static org.springframework.oxm.xmlbeans.FlightDocument parse(org.apache.xmlbeans.xml.stream.XMLInputStream xis,org.apache.xmlbeans.XmlOptions options) throws org.apache.xmlbeans.XmlException, org.apache.xmlbeans.xml.stream.XMLStreamException {
  return (org.springframework.oxm.xmlbeans.FlightDocument)org.apache.xmlbeans.XmlBeans.getContextTypeLoader().parse(xis,type,options);
}
"
"/** 
 * @deprecated {@link XMLInputStream} 
 */
public static org.apache.xmlbeans.xml.stream.XMLInputStream newValidatingXMLInputStream(org.apache.xmlbeans.xml.stream.XMLInputStream xis) throws org.apache.xmlbeans.XmlException, org.apache.xmlbeans.xml.stream.XMLStreamException {
  return org.apache.xmlbeans.XmlBeans.getContextTypeLoader().newValidatingXMLInputStream(xis,type,null);
}
"
"/** 
 * @deprecated {@link XMLInputStream} 
 */
public static org.apache.xmlbeans.xml.stream.XMLInputStream newValidatingXMLInputStream(org.apache.xmlbeans.xml.stream.XMLInputStream xis,org.apache.xmlbeans.XmlOptions options) throws org.apache.xmlbeans.XmlException, org.apache.xmlbeans.xml.stream.XMLStreamException {
  return org.apache.xmlbeans.XmlBeans.getContextTypeLoader().newValidatingXMLInputStream(xis,type,options);
}
"
"/** 
 * @deprecated {@link XMLInputStream} 
 */
public static org.springframework.oxm.xmlbeans.FlightType parse(org.apache.xmlbeans.xml.stream.XMLInputStream xis) throws org.apache.xmlbeans.XmlException, org.apache.xmlbeans.xml.stream.XMLStreamException {
  return (org.springframework.oxm.xmlbeans.FlightType)org.apache.xmlbeans.XmlBeans.getContextTypeLoader().parse(xis,type,null);
}
"
"/** 
 * @deprecated {@link XMLInputStream} 
 */
public static org.springframework.oxm.xmlbeans.FlightType parse(org.apache.xmlbeans.xml.stream.XMLInputStream xis,org.apache.xmlbeans.XmlOptions options) throws org.apache.xmlbeans.XmlException, org.apache.xmlbeans.xml.stream.XMLStreamException {
  return (org.springframework.oxm.xmlbeans.FlightType)org.apache.xmlbeans.XmlBeans.getContextTypeLoader().parse(xis,type,options);
}
"
"/** 
 * @deprecated {@link XMLInputStream} 
 */
public static org.apache.xmlbeans.xml.stream.XMLInputStream newValidatingXMLInputStream(org.apache.xmlbeans.xml.stream.XMLInputStream xis) throws org.apache.xmlbeans.XmlException, org.apache.xmlbeans.xml.stream.XMLStreamException {
  return org.apache.xmlbeans.XmlBeans.getContextTypeLoader().newValidatingXMLInputStream(xis,type,null);
}
"
"/** 
 * @deprecated {@link XMLInputStream} 
 */
public static org.apache.xmlbeans.xml.stream.XMLInputStream newValidatingXMLInputStream(org.apache.xmlbeans.xml.stream.XMLInputStream xis,org.apache.xmlbeans.XmlOptions options) throws org.apache.xmlbeans.XmlException, org.apache.xmlbeans.xml.stream.XMLStreamException {
  return org.apache.xmlbeans.XmlBeans.getContextTypeLoader().newValidatingXMLInputStream(xis,type,options);
}
"
"/** 
 * @deprecated {@link XMLInputStream} 
 */
public static org.springframework.oxm.xmlbeans.FlightsDocument parse(org.apache.xmlbeans.xml.stream.XMLInputStream xis) throws org.apache.xmlbeans.XmlException, org.apache.xmlbeans.xml.stream.XMLStreamException {
  return (org.springframework.oxm.xmlbeans.FlightsDocument)org.apache.xmlbeans.XmlBeans.getContextTypeLoader().parse(xis,type,null);
}
"
"/** 
 * @deprecated {@link XMLInputStream} 
 */
public static org.springframework.oxm.xmlbeans.FlightsDocument parse(org.apache.xmlbeans.xml.stream.XMLInputStream xis,org.apache.xmlbeans.XmlOptions options) throws org.apache.xmlbeans.XmlException, org.apache.xmlbeans.xml.stream.XMLStreamException {
  return (org.springframework.oxm.xmlbeans.FlightsDocument)org.apache.xmlbeans.XmlBeans.getContextTypeLoader().parse(xis,type,options);
}
"
"/** 
 * @deprecated {@link XMLInputStream} 
 */
public static org.apache.xmlbeans.xml.stream.XMLInputStream newValidatingXMLInputStream(org.apache.xmlbeans.xml.stream.XMLInputStream xis) throws org.apache.xmlbeans.XmlException, org.apache.xmlbeans.xml.stream.XMLStreamException {
  return org.apache.xmlbeans.XmlBeans.getContextTypeLoader().newValidatingXMLInputStream(xis,type,null);
}
"
"/** 
 * @deprecated {@link XMLInputStream} 
 */
public static org.apache.xmlbeans.xml.stream.XMLInputStream newValidatingXMLInputStream(org.apache.xmlbeans.xml.stream.XMLInputStream xis,org.apache.xmlbeans.XmlOptions options) throws org.apache.xmlbeans.XmlException, org.apache.xmlbeans.xml.stream.XMLStreamException {
  return org.apache.xmlbeans.XmlBeans.getContextTypeLoader().newValidatingXMLInputStream(xis,type,options);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link #registerAutoProxyCreatorIfNecessary(ParserContext,Element)} and{@link AopConfigUtils#registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry,Object)}
 */
@Deprecated public static void registerAutoProxyCreatorIfNecessary(ParserContext parserContext,Object source){
  BeanDefinition beanDefinition=AopConfigUtils.registerAutoProxyCreatorIfNecessary(parserContext.getRegistry(),source);
  registerComponentIfNecessary(beanDefinition,parserContext);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link AopConfigUtils#forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry)}
 */
@Deprecated public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry){
  AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
}
"
"/** 
 * Add all of the given advisors to this proxy configuration.
 * @param advisors the advisors to register
 * @deprecated as of Spring 3.0, in favor of {@link #addAdvisors}
 */
@Deprecated public void addAllAdvisors(Advisor[] advisors){
  addAdvisors(Arrays.asList(advisors));
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <K,V>Map<K,V> createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <K,V>ConcurrentMap<K,V> createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <K,V>Map<K,V> createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <K,V>ConcurrentMap<K,V> createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(String,Object)}
 */
@Deprecated public ModelMap addObject(String modelName,Object modelObject){
  return addAttribute(modelName,modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(Object)}
 */
@Deprecated public ModelMap addObject(Object modelObject){
  return addAttribute(modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Collection)}
 */
@Deprecated public ModelMap addAllObjects(Collection objects){
  return addAllAttributes(objects);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Map)}
 */
@Deprecated public ModelMap addAllObjects(Map objects){
  return addAllAttributes(objects);
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Add all of the given advisors to this proxy configuration.
 * @param advisors the advisors to register
 * @deprecated as of Spring 3.0, in favor of {@link #addAdvisors}
 */
@Deprecated public void addAllAdvisors(Advisor[] advisors){
  addAdvisors(Arrays.asList(advisors));
}
"
"/** 
 * Override settings in this bean definition (assumably a copied parent from a parent-child inheritance relationship) from the given bean definition (assumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Return the ContextLoader used by this listener.
 * @return the current ContextLoader
 * @deprecated in favor of simply subclassing ContextLoaderListener itself(which extends ContextLoader, as of Spring 3.0)
 */
@Deprecated public ContextLoader getContextLoader(){
  return this.contextLoader;
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Set a List of <code>TemplateLoader<code>s that will be used to search for templates. For example, one or more custom loaders such as database loaders could be configured and injected here.
 * @deprecated as of Spring 2.0.1, in favor of the ""preTemplateLoaders""and ""postTemplateLoaders"" properties
 * @see #setPreTemplateLoaders
 * @see #setPostTemplateLoaders
 */
@Deprecated public void setTemplateLoaders(TemplateLoader[] templateLoaders){
  if (templateLoaders != null) {
    this.templateLoaders.addAll(Arrays.asList(templateLoaders));
  }
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.4.
 * @return <code>true</code> if the current JVM is at least Java 1.4
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_14
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava14(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.5 (Java 5).
 * @return <code>true</code> if the current JVM is at least Java 1.5
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava15(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.6 (Java 6).
 * @return <code>true</code> if the current JVM is at least Java 1.6
 * @deprecated as of Spring 3.0, in favor of reflective checks forthe specific Java 1.6 classes of interest
 * @see #getMajorJavaVersion()
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava16(){
  return (majorJavaVersion >= JAVA_16);
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Override settings in this bean definition (assumably a copied parent from a parent-child inheritance relationship) from the given bean definition (assumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Override settings in this bean definition (assumably a copied parent from a parent-child inheritance relationship) from the given bean definition (assumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Register the given custom property editor for all properties of the given type, indicating that the given instance is a shared editor that might be used concurrently.
 * @param requiredType the type of the property
 * @param propertyEditor the shared editor to register
 * @deprecated as of Spring 3.0, in favor of PropertyEditorRegistrars or ConversionService usage
 */
@Deprecated public void registerSharedEditor(Class requiredType,PropertyEditor propertyEditor){
  registerCustomEditor(requiredType,null,propertyEditor);
  if (this.sharedEditors == null) {
    this.sharedEditors=new HashSet<PropertyEditor>();
  }
  this.sharedEditors.add(propertyEditor);
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Add all of the given advisors to this proxy configuration.
 * @param advisors the advisors to register
 * @deprecated as of Spring 3.0, in favor of {@link #addAdvisors}
 */
@Deprecated public void addAllAdvisors(Advisor[] advisors){
  addAdvisors(Arrays.asList(advisors));
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Create a new SingleConnectionDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @param suppressClose if the returned Connection should be aclose-suppressing proxy or the physical Connection
 * @deprecated since Spring 2.5. Driver parameter usage is generally not recommendedfor a SingleConnectionDataSource. If you insist on using driver parameters directly, set up the Driver class manually before invoking this DataSource.
 * @see java.sql.DriverManager#getConnection(String,String,String)
 */
@Deprecated public SingleConnectionDataSource(String driverClassName,String url,String username,String password,boolean suppressClose){
  super(driverClassName,url,username,password);
  this.suppressClose=suppressClose;
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Override settings in this bean definition (assumably a copied parent from a parent-child inheritance relationship) from the given bean definition (assumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Overloaded version of <code>addPropertyValue</code> that takes a property name and a property value.
 * @param propertyName name of the property
 * @param propertyValue value of the property
 * @see #addPropertyValue(PropertyValue)
 * @deprecated as of Spring 3.0, in favor of the chaining-capable {@link #add}
 */
@Deprecated public void addPropertyValue(String propertyName,Object propertyValue){
  addPropertyValue(new PropertyValue(propertyName,propertyValue));
}
"
"/** 
 * Set the name of the factory bean to use for this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setFactoryBean(String factoryBean,String factoryMethod){
  this.beanDefinition.setFactoryBeanName(factoryBean);
  this.beanDefinition.setFactoryMethodName(factoryMethod);
  return this;
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Set whether or not this definition describes a singleton bean, as alternative to  {@link #setScope}.
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public BeanDefinitionBuilder setSingleton(boolean singleton){
  this.beanDefinition.setSingleton(singleton);
  return this;
}
"
"/** 
 * Set the source of this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setSource(Object source){
  this.beanDefinition.setSource(source);
  return this;
}
"
"/** 
 * Set the description associated with this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setResourceDescription(String resourceDescription){
  this.beanDefinition.setResourceDescription(resourceDescription);
  return this;
}
"
"/** 
 * Override settings in this bean definition (assumably a copied parent from a parent-child inheritance relationship) from the given bean definition (assumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Override settings in this bean definition (assumably a copied parent from a parent-child inheritance relationship) from the given bean definition (assumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Add all of the given advisors to this proxy configuration.
 * @param advisors the advisors to register
 * @deprecated as of Spring 3.0, in favor of {@link #addAdvisors}
 */
@Deprecated public void addAllAdvisors(Advisor[] advisors){
  addAdvisors(Arrays.asList(advisors));
}
"
"/** 
 * Register the given custom property editor for all properties of the given type, indicating that the given instance is a shared editor that might be used concurrently.
 * @param requiredType the type of the property
 * @param propertyEditor the shared editor to register
 * @deprecated as of Spring 3.0, in favor of PropertyEditorRegistrars or ConversionService usage
 */
@Deprecated public void registerSharedEditor(Class requiredType,PropertyEditor propertyEditor){
  registerCustomEditor(requiredType,null,propertyEditor);
  if (this.sharedEditors == null) {
    this.sharedEditors=new HashSet<PropertyEditor>();
  }
  this.sharedEditors.add(propertyEditor);
}
"
"/** 
 * Override settings in this bean definition (assumably a copied parent from a parent-child inheritance relationship) from the given bean definition (assumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Set the name of the factory bean to use for this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setFactoryBean(String factoryBean,String factoryMethod){
  this.beanDefinition.setFactoryBeanName(factoryBean);
  this.beanDefinition.setFactoryMethodName(factoryMethod);
  return this;
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Set whether or not this definition describes a singleton bean, as alternative to  {@link #setScope}.
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public BeanDefinitionBuilder setSingleton(boolean singleton){
  this.beanDefinition.setSingleton(singleton);
  return this;
}
"
"/** 
 * Set the source of this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setSource(Object source){
  this.beanDefinition.setSource(source);
  return this;
}
"
"/** 
 * Set the description associated with this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setResourceDescription(String resourceDescription){
  this.beanDefinition.setResourceDescription(resourceDescription);
  return this;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Create a new SingleConnectionDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @param suppressClose if the returned Connection should be aclose-suppressing proxy or the physical Connection
 * @deprecated since Spring 2.5. Driver parameter usage is generally not recommendedfor a SingleConnectionDataSource. If you insist on using driver parameters directly, set up the Driver class manually before invoking this DataSource.
 * @see java.sql.DriverManager#getConnection(String,String,String)
 */
@Deprecated public SingleConnectionDataSource(String driverClassName,String url,String username,String password,boolean suppressClose){
  super(driverClassName,url,username,password);
  this.suppressClose=suppressClose;
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Register the given custom property editor for all properties of the given type, indicating that the given instance is a shared editor that might be used concurrently.
 * @param requiredType the type of the property
 * @param propertyEditor the shared editor to register
 * @deprecated as of Spring 3.0, in favor of PropertyEditorRegistrars or ConversionService usage
 */
@Deprecated public void registerSharedEditor(Class requiredType,PropertyEditor propertyEditor){
  registerCustomEditor(requiredType,null,propertyEditor);
  if (this.sharedEditors == null) {
    this.sharedEditors=new HashSet<PropertyEditor>();
  }
  this.sharedEditors.add(propertyEditor);
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a List result.
 * @param action callback object that specifies the data access action
 * @return the List result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public List executeWithListResult(SqlMapClientCallback<List> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a Map result.
 * @param action callback object that specifies the data access action
 * @return the Map result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public Map executeWithMapResult(SqlMapClientCallback<Map> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Add a  {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.
 * @deprecated in favor of {@link #addDeclaredRowMapper(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public void addDeclaredRowMapper(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,(RowMapper)rowMapper);
}
"
"/** 
 * @deprecated in favor of {@link #returningResultSet(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public SimpleJdbcCall returningResultSet(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,rowMapper);
  return this;
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Register the given custom property editor for all properties of the given type, indicating that the given instance is a shared editor that might be used concurrently.
 * @param requiredType the type of the property
 * @param propertyEditor the shared editor to register
 * @deprecated as of Spring 3.0, in favor of PropertyEditorRegistrars or ConversionService usage
 */
@Deprecated public void registerSharedEditor(Class requiredType,PropertyEditor propertyEditor){
  registerCustomEditor(requiredType,null,propertyEditor);
  if (this.sharedEditors == null) {
    this.sharedEditors=new HashSet<PropertyEditor>();
  }
  this.sharedEditors.add(propertyEditor);
}
"
"/** 
 * Add all of the given advisors to this proxy configuration.
 * @param advisors the advisors to register
 * @deprecated as of Spring 3.0, in favor of {@link #addAdvisors}
 */
@Deprecated public void addAllAdvisors(Advisor[] advisors){
  addAdvisors(Arrays.asList(advisors));
}
"
"/** 
 * Set a List of <code>TemplateLoader<code>s that will be used to search for templates. For example, one or more custom loaders such as database loaders could be configured and injected here.
 * @deprecated as of Spring 2.0.1, in favor of the ""preTemplateLoaders""and ""postTemplateLoaders"" properties
 * @see #setPreTemplateLoaders
 * @see #setPostTemplateLoaders
 */
@Deprecated public void setTemplateLoaders(TemplateLoader[] templateLoaders){
  if (templateLoaders != null) {
    this.templateLoaders.addAll(Arrays.asList(templateLoaders));
  }
}
"
"/** 
 * Add a  {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.
 * @deprecated in favor of {@link #addDeclaredRowMapper(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public void addDeclaredRowMapper(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,(RowMapper)rowMapper);
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Register the given custom property editor for all properties of the given type, indicating that the given instance is a shared editor that might be used concurrently.
 * @param requiredType the type of the property
 * @param propertyEditor the shared editor to register
 * @deprecated as of Spring 3.0, in favor of PropertyEditorRegistrars or ConversionService usage
 */
@Deprecated public void registerSharedEditor(Class requiredType,PropertyEditor propertyEditor){
  registerCustomEditor(requiredType,null,propertyEditor);
  if (this.sharedEditors == null) {
    this.sharedEditors=new HashSet<PropertyEditor>();
  }
  this.sharedEditors.add(propertyEditor);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link #registerAutoProxyCreatorIfNecessary(ParserContext,Element)} and{@link AopConfigUtils#registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry,Object)}
 */
@Deprecated public static void registerAutoProxyCreatorIfNecessary(ParserContext parserContext,Object source){
  BeanDefinition beanDefinition=AopConfigUtils.registerAutoProxyCreatorIfNecessary(parserContext.getRegistry(),source);
  registerComponentIfNecessary(beanDefinition,parserContext);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link AopConfigUtils#forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry)}
 */
@Deprecated public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry){
  AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Override settings in this bean definition (assumably a copied parent from a parent-child inheritance relationship) from the given bean definition (assumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Create a new SingleConnectionDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @param suppressClose if the returned Connection should be aclose-suppressing proxy or the physical Connection
 * @deprecated since Spring 2.5. Driver parameter usage is generally not recommendedfor a SingleConnectionDataSource. If you insist on using driver parameters directly, set up the Driver class manually before invoking this DataSource.
 * @see java.sql.DriverManager#getConnection(String,String,String)
 */
@Deprecated public SingleConnectionDataSource(String driverClassName,String url,String username,String password,boolean suppressClose){
  super(driverClassName,url,username,password);
  this.suppressClose=suppressClose;
}
"
"/** 
 * Create a new ResourceEditorRegistrar for the given  {@link ResourceLoader}using a  {@link DefaultEnvironment}.
 * @param resourceLoader the ResourceLoader (or ResourcePatternResolver)to create editors for (usually an ApplicationContext)
 * @see org.springframework.core.io.support.ResourcePatternResolver
 * @see org.springframework.context.ApplicationContext
 * @deprecated as of Spring 3.1 in favor of{@link ResourceEditorRegistrar#ResourceEditorRegistrar(ResourceLoader,Environment)}
 */
@Deprecated public ResourceEditorRegistrar(ResourceLoader resourceLoader){
  this(resourceLoader,new DefaultEnvironment());
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader} and a {@link DefaultEnvironment}.
 * @param resourceLoader the <code>ResourceLoader</code> to use
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,Environment)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader){
  this(resourceLoader,new DefaultEnvironment(),true);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader} and a {@link DefaultEnvironment}.
 * @param resourceLoader the <code>ResourceLoader</code> to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding property could be found in the DefaultEnvironment
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,Environment,boolean)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader,boolean ignoreUnresolvablePlaceholders){
  this(resourceLoader,new DefaultEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link DefaultEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,Environment)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver){
  this(resourcePatternResolver,new DefaultEnvironment(),true);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link DefaultEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding system property could be found
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,Environment,boolean)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver,boolean ignoreUnresolvablePlaceholders){
  this(resourcePatternResolver,new DefaultEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader} and a {@link DefaultEnvironment}.
 * @param resourceLoader the <code>ResourceLoader</code> to use
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,Environment)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader){
  this(resourceLoader,new DefaultEnvironment(),true);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader} and a {@link DefaultEnvironment}.
 * @param resourceLoader the <code>ResourceLoader</code> to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding property could be found in the DefaultEnvironment
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,Environment,boolean)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader,boolean ignoreUnresolvablePlaceholders){
  this(resourceLoader,new DefaultEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link DefaultEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,Environment)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver){
  this(resourcePatternResolver,new DefaultEnvironment(),true);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link DefaultEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding system property could be found
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,Environment,boolean)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver,boolean ignoreUnresolvablePlaceholders){
  this(resourcePatternResolver,new DefaultEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Create a new ResourceEditorRegistrar for the given  {@link ResourceLoader}using a  {@link DefaultEnvironment}.
 * @param resourceLoader the ResourceLoader (or ResourcePatternResolver)to create editors for (usually an ApplicationContext)
 * @see org.springframework.core.io.support.ResourcePatternResolver
 * @see org.springframework.context.ApplicationContext
 * @deprecated as of Spring 3.1 in favor of{@link ResourceEditorRegistrar#ResourceEditorRegistrar(ResourceLoader,Environment)}
 */
@Deprecated public ResourceEditorRegistrar(ResourceLoader resourceLoader){
  this(resourceLoader,new DefaultEnvironment());
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader} and a {@link DefaultEnvironment}.
 * @param resourceLoader the <code>ResourceLoader</code> to use
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader){
  this(resourceLoader,new DefaultEnvironment(),true);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader}.
 * @param resourceLoader the <code>ResourceLoader</code> to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding property could be found
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver,boolean)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader,boolean ignoreUnresolvablePlaceholders){
  this(resourceLoader,new DefaultEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link DefaultEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,Environment)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver){
  this(resourcePatternResolver,new DefaultEnvironment(),true);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link DefaultEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding system property could be found
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,Environment,boolean)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver,boolean ignoreUnresolvablePlaceholders){
  this(resourcePatternResolver,new DefaultEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Set the name of the factory bean to use for this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setFactoryBean(String factoryBean,String factoryMethod){
  this.beanDefinition.setFactoryBeanName(factoryBean);
  this.beanDefinition.setFactoryMethodName(factoryMethod);
  return this;
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Set whether or not this definition describes a singleton bean, as alternative to  {@link #setScope}.
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public BeanDefinitionBuilder setSingleton(boolean singleton){
  this.beanDefinition.setSingleton(singleton);
  return this;
}
"
"/** 
 * Set the source of this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setSource(Object source){
  this.beanDefinition.setSource(source);
  return this;
}
"
"/** 
 * Set the description associated with this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setResourceDescription(String resourceDescription){
  this.beanDefinition.setResourceDescription(resourceDescription);
  return this;
}
"
"/** 
 * @deprecated since Spring 3.1 in favor of{@link #registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry,ComponentRegistrar,Object,Boolean,Boolean)}
 */
@Deprecated public static void registerAutoProxyCreatorIfNecessary(ParserContext parserContext,Element sourceElement){
  BeanDefinition beanDefinition=AopConfigUtils.registerAutoProxyCreatorIfNecessary(parserContext.getRegistry(),parserContext.extractSource(sourceElement));
  useClassProxyingIfNecessary(parserContext.getRegistry(),sourceElement);
  registerComponentIfNecessary(beanDefinition,parserContext);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link #registerAutoProxyCreatorIfNecessary(ParserContext,Element)} and{@link AopConfigUtils#registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry,Object)}
 */
@Deprecated public static void registerAutoProxyCreatorIfNecessary(ParserContext parserContext,Object source){
  BeanDefinition beanDefinition=AopConfigUtils.registerAutoProxyCreatorIfNecessary(parserContext.getRegistry(),source);
  registerComponentIfNecessary(beanDefinition,parserContext);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link AopConfigUtils#forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry)}
 */
@Deprecated public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry){
  AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
}
"
"/** 
 * Set the name of the factory bean to use for this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setFactoryBean(String factoryBean,String factoryMethod){
  this.beanDefinition.setFactoryBeanName(factoryBean);
  this.beanDefinition.setFactoryMethodName(factoryMethod);
  return this;
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Set whether or not this definition describes a singleton bean, as alternative to  {@link #setScope}.
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public BeanDefinitionBuilder setSingleton(boolean singleton){
  this.beanDefinition.setSingleton(singleton);
  return this;
}
"
"/** 
 * Set the source of this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setSource(Object source){
  this.beanDefinition.setSource(source);
  return this;
}
"
"/** 
 * Set the description associated with this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setResourceDescription(String resourceDescription){
  this.beanDefinition.setResourceDescription(resourceDescription);
  return this;
}
"
"/** 
 * Create a new default ConversionService instance that can be safely modified.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#DefaultConversionService()}
 */
public static GenericConversionService createDefaultConversionService(){
  return new DefaultConversionService();
}
"
"/** 
 * Populate the given ConversionService instance with all applicable default converters.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#addDefaultConverters}
 */
public static void addDefaultConverters(GenericConversionService conversionService){
  DefaultConversionService.addDefaultConverters(conversionService);
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link DefaultEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new DefaultEnvironment());
}
"
"/** 
 * @deprecated since Spring 3.1 in favor of{@link #registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry,ComponentRegistrar,Object,Boolean,Boolean)}
 */
@Deprecated public static void registerAutoProxyCreatorIfNecessary(ParserContext parserContext,Element sourceElement){
  BeanDefinition beanDefinition=AopConfigUtils.registerAutoProxyCreatorIfNecessary(parserContext.getRegistry(),parserContext.extractSource(sourceElement));
  useClassProxyingIfNecessary(parserContext.getRegistry(),sourceElement);
  registerComponentIfNecessary(beanDefinition,new ComponentRegistrarAdapter(parserContext));
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link #registerAutoProxyCreatorIfNecessary(ParserContext,Element)} and{@link AopConfigUtils#registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry,Object)}
 */
@Deprecated public static void registerAutoProxyCreatorIfNecessary(ParserContext parserContext,Object source){
  BeanDefinition beanDefinition=AopConfigUtils.registerAutoProxyCreatorIfNecessary(parserContext.getRegistry(),source);
  registerComponentIfNecessary(beanDefinition,new ComponentRegistrarAdapter(parserContext));
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link AopConfigUtils#forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry)}
 */
@Deprecated public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry){
  AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
}
"
"/** 
 * @deprecated since Spring 3.1 in favor of{@link #registerWithGeneratedName(BeanDefinition,BeanDefinitionRegistry)}and its more general signature.
 */
@Deprecated public static String registerWithGeneratedName(AbstractBeanDefinition definition,BeanDefinitionRegistry registry) throws BeanDefinitionStoreException {
  return registerWithGeneratedName((BeanDefinition)definition,registry);
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link DefaultEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new DefaultEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link DefaultEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new DefaultEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Return the CacheProvider for the currently configured Hibernate SessionFactory, to be used by LocalCacheProviderProxy. <p>This instance will be set before initialization of the corresponding SessionFactory, and reset immediately afterwards. It is thus only available during configuration.
 * @see #setCacheProvider
 * @deprecated as of Spring 3.1 in favor of Hibernate's {@link RegionFactory} SPI
 */
@Deprecated public static org.hibernate.cache.CacheProvider getConfigTimeCacheProvider(){
  return configTimeCacheProviderHolder.get();
}
"
"/** 
 * Return the CacheProvider for the currently configured Hibernate SessionFactory, to be used by LocalCacheProviderProxy. <p>This instance will be set before initialization of the corresponding SessionFactory, and reset immediately afterwards. It is thus only available during configuration.
 * @see #setCacheProvider
 * @deprecated as of Spring 3.1 in favor of Hibernate's {@link RegionFactory} SPI
 */
@Deprecated public static org.hibernate.cache.CacheProvider getConfigTimeCacheProvider(){
  return configTimeCacheProviderHolder.get();
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link #registerAutoProxyCreatorIfNecessary(ParserContext,Element)} and{@link AopConfigUtils#registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry,Object)}
 */
@Deprecated public static void registerAutoProxyCreatorIfNecessary(ParserContext parserContext,Object source){
  BeanDefinition beanDefinition=AopConfigUtils.registerAutoProxyCreatorIfNecessary(parserContext.getRegistry(),source);
  registerComponentIfNecessary(beanDefinition,parserContext);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link AopConfigUtils#forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry)}
 */
@Deprecated public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry){
  AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Create a new ResourceEditorRegistrar for the given  {@link ResourceLoader}using a  {@link StandardEnvironment}.
 * @param resourceLoader the ResourceLoader (or ResourcePatternResolver)to create editors for (usually an ApplicationContext)
 * @see org.springframework.core.io.support.ResourcePatternResolver
 * @see org.springframework.context.ApplicationContext
 * @deprecated as of Spring 3.1 in favor of{@link ResourceEditorRegistrar#ResourceEditorRegistrar(ResourceLoader,Environment)}
 */
@Deprecated public ResourceEditorRegistrar(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment());
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader} and a {@link StandardEnvironment}.
 * @param resourceLoader the <code>ResourceLoader</code> to use
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader}.
 * @param resourceLoader the <code>ResourceLoader</code> to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding property could be found
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver,boolean)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader,boolean ignoreUnresolvablePlaceholders){
  this(resourceLoader,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,Environment)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver){
  this(resourcePatternResolver,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding system property could be found
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,Environment,boolean)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver,boolean ignoreUnresolvablePlaceholders){
  this(resourcePatternResolver,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Create a new default GenericConversionService instance that can be safely modified.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#DefaultConversionService()}
 */
public static GenericConversionService createDefaultConversionService(){
  return new DefaultConversionService();
}
"
"/** 
 * Populate the given GenericConversionService instance with the set of default converters.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#addDefaultConverters(ConverterRegistry)}
 */
public static void addDefaultConverters(GenericConversionService conversionService){
  DefaultConversionService.addDefaultConverters(conversionService);
}
"
"/** 
 * Return the ContextLoader used by this listener.
 * @return the current ContextLoader
 * @deprecated in favor of simply subclassing ContextLoaderListener itself(which extends ContextLoader, as of Spring 3.0)
 */
@Deprecated public ContextLoader getContextLoader(){
  return this.contextLoader;
}
"
"/** 
 * Register the given custom property editor for all properties of the given type, indicating that the given instance is a shared editor that might be used concurrently.
 * @param requiredType the type of the property
 * @param propertyEditor the shared editor to register
 * @deprecated as of Spring 3.0, in favor of PropertyEditorRegistrars or ConversionService usage
 */
@Deprecated public void registerSharedEditor(Class<?> requiredType,PropertyEditor propertyEditor){
  registerCustomEditor(requiredType,null,propertyEditor);
  if (this.sharedEditors == null) {
    this.sharedEditors=new HashSet<PropertyEditor>();
  }
  this.sharedEditors.add(propertyEditor);
}
"
"/** 
 * Create a new ResourceEditorRegistrar for the given  {@link ResourceLoader}using a  {@link StandardEnvironment}.
 * @param resourceLoader the ResourceLoader (or ResourcePatternResolver)to create editors for (usually an ApplicationContext)
 * @see org.springframework.core.io.support.ResourcePatternResolver
 * @see org.springframework.context.ApplicationContext
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditorRegistrar(ResourceLoader,Environment)}
 */
@Deprecated public ResourceEditorRegistrar(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment());
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,Environment)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver){
  this(resourcePatternResolver,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding system property could be found
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,Environment,boolean)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver,boolean ignoreUnresolvablePlaceholders){
  this(resourcePatternResolver,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Register the given custom property editor for all properties of the given type, indicating that the given instance is a shared editor that might be used concurrently.
 * @param requiredType the type of the property
 * @param propertyEditor the shared editor to register
 * @deprecated as of Spring 3.0, in favor of PropertyEditorRegistrars or ConversionService usage
 */
@Deprecated public void registerSharedEditor(Class<?> requiredType,PropertyEditor propertyEditor){
  registerCustomEditor(requiredType,null,propertyEditor);
  if (this.sharedEditors == null) {
    this.sharedEditors=new HashSet<PropertyEditor>();
  }
  this.sharedEditors.add(propertyEditor);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver){
  this(resourcePatternResolver,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding system property could be found
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver,boolean)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver,boolean ignoreUnresolvablePlaceholders){
  this(resourcePatternResolver,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() mapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() mapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() mapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() mapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() mapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() mapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Create a new ResourceEditorRegistrar for the given  {@link ResourceLoader}using a  {@link StandardEnvironment}.
 * @param resourceLoader the ResourceLoader (or ResourcePatternResolver)to create editors for (usually an ApplicationContext)
 * @see org.springframework.core.io.support.ResourcePatternResolver
 * @see org.springframework.context.ApplicationContext
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditorRegistrar(ResourceLoader,Environment)}
 */
@Deprecated public ResourceEditorRegistrar(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment());
}
"
"/** 
 * Sets the attributes in the model that should be rendered by this view.  When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Returns the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
public Set<String> getRenderedAttributes(){
  return modelKeys;
}
"
"/** 
 * Sets the attributes in the model that should be rendered by this view.  When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Returns the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
public Set<String> getRenderedAttributes(){
  return modelKeys;
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Check whether the specified class is a CGLIB-generated class.
 * @param clazz the class to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)}
 */
@Deprecated public static boolean isCglibProxyClass(Class<?> clazz){
  return ClassUtils.isCglibProxyClass(clazz);
}
"
"/** 
 * Check whether the specified class name is a CGLIB-generated class.
 * @param className the class name to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)}
 */
@Deprecated public static boolean isCglibProxyClassName(String className){
  return ClassUtils.isCglibProxyClassName(className);
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() mapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() mapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Return the CacheProvider for the currently configured Hibernate SessionFactory, to be used by LocalCacheProviderProxy. <p>This instance will be set before initialization of the corresponding SessionFactory, and reset immediately afterwards. It is thus only available during configuration.
 * @see #setCacheProvider
 * @deprecated as of Spring 3.1 in favor of Hibernate's {@link RegionFactory} SPI
 */
@Deprecated public static org.hibernate.cache.CacheProvider getConfigTimeCacheProvider(){
  return configTimeCacheProviderHolder.get();
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Override settings in this bean definition (assumably a copied parent from a parent-child inheritance relationship) from the given bean definition (assumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Apply the given method invocation to the given RMI stub. <p>Delegates to the corresponding method if the RMI stub does not directly implement the invoked method. This typically happens when a non-RMI service interface is used for an RMI service. The methods of such a service interface have to match the RMI stub methods, but they typically don't declare <code>java.rmi.RemoteException</code>: A RemoteException thrown by the RMI stub will be automatically converted to Spring's RemoteAccessException.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object invoke(MethodInvocation invocation,Remote stub,String serviceName) throws Throwable {
  try {
    return invokeRemoteMethod(invocation,stub);
  }
 catch (  InvocationTargetException ex) {
    Throwable targetEx=ex.getTargetException();
    if (targetEx instanceof RemoteException) {
      RemoteException rex=(RemoteException)targetEx;
      throw convertRmiAccessException(invocation.getMethod(),rex,serviceName);
    }
 else {
      throw targetEx;
    }
  }
}
"
"/** 
 * Perform a raw method invocation on the given RMI stub, letting reflection exceptions through as-is.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object doInvoke(MethodInvocation invocation,Remote stub) throws InvocationTargetException {
  return invokeRemoteMethod(invocation,stub);
}
"
"/** 
 * Apply the given method invocation to the given RMI stub. <p>Delegates to the corresponding method if the RMI stub does not directly implement the invoked method. This typically happens when a non-RMI service interface is used for an RMI service. The methods of such a service interface have to match the RMI stub methods, but they typically don't declare <code>java.rmi.RemoteException</code>: A RemoteException thrown by the RMI stub will be automatically converted to Spring's RemoteAccessException.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object invoke(MethodInvocation invocation,Remote stub,String serviceName) throws Throwable {
  try {
    return invokeRemoteMethod(invocation,stub);
  }
 catch (  InvocationTargetException ex) {
    Throwable targetEx=ex.getTargetException();
    if (targetEx instanceof RemoteException) {
      RemoteException rex=(RemoteException)targetEx;
      throw convertRmiAccessException(invocation.getMethod(),rex,serviceName);
    }
 else {
      throw targetEx;
    }
  }
}
"
"/** 
 * Perform a raw method invocation on the given RMI stub, letting reflection exceptions through as-is.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object doInvoke(MethodInvocation invocation,Remote stub) throws InvocationTargetException {
  return invokeRemoteMethod(invocation,stub);
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Add a  {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.
 * @deprecated in favor of {@link #addDeclaredRowMapper(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public void addDeclaredRowMapper(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,(RowMapper)rowMapper);
}
"
"/** 
 * Add a  {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.
 * @deprecated in favor of {@link #addDeclaredRowMapper(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public void addDeclaredRowMapper(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,(RowMapper)rowMapper);
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Encodes the given source URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&""  characters in query parameter names and query parameter values because they cannot  be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromUri(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param uri the URI to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
public static String encodeUri(String uri,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(uri,""'uri' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=URI_PATTERN.matcher(uri);
  if (m.matches()) {
    String scheme=m.group(2);
    String authority=m.group(3);
    String userinfo=m.group(5);
    String host=m.group(6);
    String port=m.group(8);
    String path=m.group(9);
    String query=m.group(11);
    String fragment=m.group(13);
    return encodeUriComponents(scheme,authority,userinfo,host,port,path,query,fragment,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + uri + ""] is not a valid URI"");
  }
}
"
"/** 
 * Encodes the given HTTP URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not support fragments ( {@code #}), as these are not supposed to be sent to the server, but retained by the client. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&""  characters in query parameter names and query parameter values because they cannot  be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param httpUrl the HTTP URL to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URL
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
public static String encodeHttpUrl(String httpUrl,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(httpUrl,""'httpUrl' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=HTTP_URL_PATTERN.matcher(httpUrl);
  if (m.matches()) {
    String scheme=m.group(1);
    String authority=m.group(2);
    String userinfo=m.group(4);
    String host=m.group(5);
    String portString=m.group(7);
    String path=m.group(8);
    String query=m.group(10);
    return encodeUriComponents(scheme,authority,userinfo,host,portString,path,query,null,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + httpUrl + ""] is not a valid HTTP URL"");
  }
}
"
"/** 
 * Encodes the given source URI components into an encoded String. All various URI components are optional, but encoded according to their respective valid character sets.
 * @param scheme the scheme
 * @param authority the authority
 * @param userInfo the user info
 * @param host the host
 * @param port the port
 * @param path the path
 * @param query the query
 * @param fragment the fragment
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}
 */
public static String encodeUriComponents(String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,String encoding) throws UnsupportedEncodingException {
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  StringBuilder sb=new StringBuilder();
  if (scheme != null) {
    sb.append(encodeScheme(scheme,encoding));
    sb.append(':');
  }
  if (authority != null) {
    sb.append(""//"");
    if (userInfo != null) {
      sb.append(encodeUserInfo(userInfo,encoding));
      sb.append('@');
    }
    if (host != null) {
      sb.append(encodeHost(host,encoding));
    }
    if (port != null) {
      sb.append(':');
      sb.append(encodePort(port,encoding));
    }
  }
  sb.append(encodePath(path,encoding));
  if (query != null) {
    sb.append('?');
    sb.append(encodeQuery(query,encoding));
  }
  if (fragment != null) {
    sb.append('#');
    sb.append(encodeFragment(fragment,encoding));
  }
  return sb.toString();
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Encodes the given source URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&""  characters in query parameter names and query parameter values because they cannot  be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromUri(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param uri the URI to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
public static String encodeUri(String uri,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(uri,""'uri' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=URI_PATTERN.matcher(uri);
  if (m.matches()) {
    String scheme=m.group(2);
    String authority=m.group(3);
    String userinfo=m.group(5);
    String host=m.group(6);
    String port=m.group(8);
    String path=m.group(9);
    String query=m.group(11);
    String fragment=m.group(13);
    return encodeUriComponents(scheme,authority,userinfo,host,port,path,query,fragment,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + uri + ""] is not a valid URI"");
  }
}
"
"/** 
 * Encodes the given HTTP URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not support fragments ( {@code #}), as these are not supposed to be sent to the server, but retained by the client. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&""  characters in query parameter names and query parameter values because they cannot  be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param httpUrl the HTTP URL to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URL
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
public static String encodeHttpUrl(String httpUrl,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(httpUrl,""'httpUrl' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=HTTP_URL_PATTERN.matcher(httpUrl);
  if (m.matches()) {
    String scheme=m.group(1);
    String authority=m.group(2);
    String userinfo=m.group(4);
    String host=m.group(5);
    String portString=m.group(7);
    String path=m.group(8);
    String query=m.group(10);
    return encodeUriComponents(scheme,authority,userinfo,host,portString,path,query,null,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + httpUrl + ""] is not a valid HTTP URL"");
  }
}
"
"/** 
 * Encodes the given source URI components into an encoded String. All various URI components are optional, but encoded according to their respective valid character sets.
 * @param scheme the scheme
 * @param authority the authority
 * @param userInfo the user info
 * @param host the host
 * @param port the port
 * @param path the path
 * @param query the query
 * @param fragment the fragment
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}
 */
public static String encodeUriComponents(String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,String encoding) throws UnsupportedEncodingException {
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  StringBuilder sb=new StringBuilder();
  if (scheme != null) {
    sb.append(encodeScheme(scheme,encoding));
    sb.append(':');
  }
  if (authority != null) {
    sb.append(""//"");
    if (userInfo != null) {
      sb.append(encodeUserInfo(userInfo,encoding));
      sb.append('@');
    }
    if (host != null) {
      sb.append(encodeHost(host,encoding));
    }
    if (port != null) {
      sb.append(':');
      sb.append(encodePort(port,encoding));
    }
  }
  sb.append(encodePath(path,encoding));
  if (query != null) {
    sb.append('?');
    sb.append(encodeQuery(query,encoding));
  }
  if (fragment != null) {
    sb.append('#');
    sb.append(encodeFragment(fragment,encoding));
  }
  return sb.toString();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(org.hibernate.cache.CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Create a new ResourceEditorRegistrar for the given  {@link ResourceLoader}using a  {@link StandardEnvironment}.
 * @param resourceLoader the ResourceLoader (or ResourcePatternResolver)to create editors for (usually an ApplicationContext)
 * @see org.springframework.core.io.support.ResourcePatternResolver
 * @see org.springframework.context.ApplicationContext
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditorRegistrar(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditorRegistrar(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Return the ContextLoader used by this listener.
 * @return the current ContextLoader
 * @deprecated in favor of simply subclassing ContextLoaderListener itself(which extends ContextLoader, as of Spring 3.0)
 */
@Deprecated public ContextLoader getContextLoader(){
  return this.contextLoader;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Create a new ResourceEditorRegistrar for the given  {@link ResourceLoader}using a  {@link StandardEnvironment}.
 * @param resourceLoader the ResourceLoader (or ResourcePatternResolver)to create editors for (usually an ApplicationContext)
 * @see org.springframework.core.io.support.ResourcePatternResolver
 * @see org.springframework.context.ApplicationContext
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditorRegistrar(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditorRegistrar(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}.
 * @throws IllegalStateException if this type is not a java.util.Map.
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Return the ContextLoader used by this listener.
 * @return the current ContextLoader
 * @deprecated in favor of simply subclassing ContextLoaderListener itself(which extends ContextLoader, as of Spring 3.0)
 */
@Deprecated public ContextLoader getContextLoader(){
  return this.contextLoader;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Override settings in this bean definition (presumably a copied parent from a parent-child inheritance relationship) from the given bean definition (presumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param beanFactory the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.2 in favor of{@link BeanFactoryUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
public static PlatformTransactionManager getTransactionManager(BeanFactory beanFactory,String qualifier){
  return BeanFactoryUtils.qualifiedBeanOfType(beanFactory,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param bf the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.2 in favor of{@link BeanFactoryUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
public static PlatformTransactionManager getTransactionManager(ConfigurableListableBeanFactory bf,String qualifier){
  return BeanFactoryUtils.qualifiedBeanOfType(bf,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Check whether the specified class is a CGLIB-generated class.
 * @param clazz the class to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)}
 */
@Deprecated public static boolean isCglibProxyClass(Class<?> clazz){
  return ClassUtils.isCglibProxyClass(clazz);
}
"
"/** 
 * Check whether the specified class name is a CGLIB-generated class.
 * @param className the class name to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)}
 */
@Deprecated public static boolean isCglibProxyClassName(String className){
  return ClassUtils.isCglibProxyClassName(className);
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param beanFactory the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.2 in favor of{@link BeanFactoryAnnotationUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
public static PlatformTransactionManager getTransactionManager(BeanFactory beanFactory,String qualifier){
  return BeanFactoryAnnotationUtils.qualifiedBeanOfType(beanFactory,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param bf the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.2 in favor of{@link BeanFactoryAnnotationUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
public static PlatformTransactionManager getTransactionManager(ConfigurableListableBeanFactory bf,String qualifier){
  return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Check whether the specified class is a CGLIB-generated class.
 * @param clazz the class to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)}
 */
@Deprecated public static boolean isCglibProxyClass(Class<?> clazz){
  return ClassUtils.isCglibProxyClass(clazz);
}
"
"/** 
 * Check whether the specified class name is a CGLIB-generated class.
 * @param className the class name to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)}
 */
@Deprecated public static boolean isCglibProxyClassName(String className){
  return ClassUtils.isCglibProxyClassName(className);
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param beanFactory the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.2 in favor of{@link BeanFactoryUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
public static PlatformTransactionManager getTransactionManager(BeanFactory beanFactory,String qualifier){
  return BeanFactoryUtils.qualifiedBeanOfType(beanFactory,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param bf the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.2 in favor of{@link BeanFactoryUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
public static PlatformTransactionManager getTransactionManager(ConfigurableListableBeanFactory bf,String qualifier){
  return BeanFactoryUtils.qualifiedBeanOfType(bf,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is <code>true</code> (the default), a request for  {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setFavorPathExtension(boolean favorPathExtension){
  this.favorPathExtension=favorPathExtension;
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setUseJaf(boolean useJaf){
  this.useJaf=useJaf;
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is <code>true</code>, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setFavorParameter(boolean favorParameter){
  this.favorParameter=favorParameter;
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setParameterName(String parameterName){
  this.parameterName=parameterName;
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.ignoreAcceptHeader=ignoreAcceptHeader;
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setMediaTypes(Map<String,String> mediaTypes){
  this.mediaTypes=mediaTypes;
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setDefaultContentType(MediaType defaultContentType){
  this.defaultContentType=defaultContentType;
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is <code>true</code> (the default), a request for  {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setFavorPathExtension(boolean favorPathExtension){
  this.favorPathExtension=favorPathExtension;
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setUseJaf(boolean useJaf){
  this.useJaf=useJaf;
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is <code>true</code>, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setFavorParameter(boolean favorParameter){
  this.favorParameter=favorParameter;
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setParameterName(String parameterName){
  this.parameterName=parameterName;
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.ignoreAcceptHeader=ignoreAcceptHeader;
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    for (    Map.Entry<String,String> entry : mediaTypes.entrySet()) {
      String extension=entry.getKey().toLowerCase(Locale.ENGLISH);
      MediaType mediaType=MediaType.parseMediaType(entry.getValue());
      this.mediaTypes.put(extension,mediaType);
    }
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setDefaultContentType(MediaType defaultContentType){
  this.defaultContentType=defaultContentType;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param beanFactory the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.2 in favor of{@link BeanFactoryUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
public static PlatformTransactionManager getTransactionManager(BeanFactory beanFactory,String qualifier){
  return BeanFactoryUtils.qualifiedBeanOfType(beanFactory,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param bf the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.2 in favor of{@link BeanFactoryUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
public static PlatformTransactionManager getTransactionManager(ConfigurableListableBeanFactory bf,String qualifier){
  return BeanFactoryUtils.qualifiedBeanOfType(bf,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Check whether the specified class is a CGLIB-generated class.
 * @param clazz the class to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)}
 */
@Deprecated public static boolean isCglibProxyClass(Class<?> clazz){
  return ClassUtils.isCglibProxyClass(clazz);
}
"
"/** 
 * Check whether the specified class name is a CGLIB-generated class.
 * @param className the class name to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)}
 */
@Deprecated public static boolean isCglibProxyClassName(String className){
  return ClassUtils.isCglibProxyClassName(className);
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param beanFactory the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.1.2 in favor of{@link BeanFactoryAnnotationUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
public static PlatformTransactionManager getTransactionManager(BeanFactory beanFactory,String qualifier){
  return BeanFactoryAnnotationUtils.qualifiedBeanOfType(beanFactory,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param bf the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.1.2 in favor of{@link BeanFactoryAnnotationUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
public static PlatformTransactionManager getTransactionManager(ConfigurableListableBeanFactory bf,String qualifier){
  return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param beanFactory the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.2 in favor of{@link BeanFactoryAnnotationUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
public static PlatformTransactionManager getTransactionManager(BeanFactory beanFactory,String qualifier){
  return BeanFactoryAnnotationUtils.qualifiedBeanOfType(beanFactory,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param bf the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.2 in favor of{@link BeanFactoryAnnotationUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
public static PlatformTransactionManager getTransactionManager(ConfigurableListableBeanFactory bf,String qualifier){
  return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param beanFactory the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.1.2 in favor of{@link BeanFactoryAnnotationUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
public static PlatformTransactionManager getTransactionManager(BeanFactory beanFactory,String qualifier){
  return BeanFactoryAnnotationUtils.qualifiedBeanOfType(beanFactory,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param bf the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.1.2 in favor of{@link BeanFactoryAnnotationUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
public static PlatformTransactionManager getTransactionManager(ConfigurableListableBeanFactory bf,String qualifier){
  return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Construct a new  {@link ContextConfigurationAttributes} instance for the{@linkplain Class test class} that declared the{@link ContextConfiguration @ContextConfiguration} annotation and itscorresponding attributes.
 * @param declaringClass the test class that declared {@code @ContextConfiguration}
 * @param locations the resource locations declared via {@code @ContextConfiguration}
 * @param classes the annotated classes declared via {@code @ContextConfiguration}
 * @param inheritLocations the {@code inheritLocations} flag declared via {@code @ContextConfiguration}
 * @param contextLoaderClass the {@code ContextLoader} class declared via {@code @ContextConfiguration}
 * @throws IllegalArgumentException if the {@code declaringClass} or {@code contextLoaderClass} is{@code null}, or if the  {@code locations} and {@code classes} are both non-empty
 * @deprecated as of Spring 3.2, use{@link #ContextConfigurationAttributes(Class,String[],Class[],boolean,Class[],boolean,Class)}instead
 */
@Deprecated public ContextConfigurationAttributes(Class<?> declaringClass,String[] locations,Class<?>[] classes,boolean inheritLocations,Class<? extends ContextLoader> contextLoaderClass){
  this(declaringClass,locations,classes,inheritLocations,null,true,contextLoaderClass);
}
"
"/** 
 * Construct a new  {@link ContextConfigurationAttributes} instance for the{@linkplain Class test class} that declared the{@link ContextConfiguration @ContextConfiguration} annotation and itscorresponding attributes.
 * @param declaringClass the test class that declared {@code @ContextConfiguration}
 * @param locations the resource locations declared via {@code @ContextConfiguration}
 * @param classes the annotated classes declared via {@code @ContextConfiguration}
 * @param inheritLocations the {@code inheritLocations} flag declared via {@code @ContextConfiguration}
 * @param contextLoaderClass the {@code ContextLoader} class declared via {@code @ContextConfiguration}
 * @throws IllegalArgumentException if the {@code declaringClass} or {@code contextLoaderClass} is{@code null}, or if the  {@code locations} and {@code classes} are both non-empty
 * @deprecated as of Spring 3.2, use{@link #ContextConfigurationAttributes(Class,String[],Class[],boolean,Class[],boolean,Class)}instead
 */
@Deprecated public ContextConfigurationAttributes(Class<?> declaringClass,String[] locations,Class<?>[] classes,boolean inheritLocations,Class<? extends ContextLoader> contextLoaderClass){
  this(declaringClass,locations,classes,inheritLocations,null,true,contextLoaderClass);
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Encodes the given source URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&""  characters in query parameter names and query parameter values because they cannot  be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromUri(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param uri the URI to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeUri(String uri,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(uri,""'uri' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=URI_PATTERN.matcher(uri);
  if (m.matches()) {
    String scheme=m.group(2);
    String authority=m.group(3);
    String userinfo=m.group(5);
    String host=m.group(6);
    String port=m.group(8);
    String path=m.group(9);
    String query=m.group(11);
    String fragment=m.group(13);
    return encodeUriComponents(scheme,authority,userinfo,host,port,path,query,fragment,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + uri + ""] is not a valid URI"");
  }
}
"
"/** 
 * Encodes the given HTTP URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not support fragments ( {@code #}), as these are not supposed to be sent to the server, but retained by the client. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&""  characters in query parameter names and query parameter values because they cannot  be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param httpUrl the HTTP URL to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URL
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeHttpUrl(String httpUrl,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(httpUrl,""'httpUrl' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=HTTP_URL_PATTERN.matcher(httpUrl);
  if (m.matches()) {
    String scheme=m.group(1);
    String authority=m.group(2);
    String userinfo=m.group(4);
    String host=m.group(5);
    String portString=m.group(7);
    String path=m.group(8);
    String query=m.group(10);
    return encodeUriComponents(scheme,authority,userinfo,host,portString,path,query,null,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + httpUrl + ""] is not a valid HTTP URL"");
  }
}
"
"/** 
 * Encodes the given source URI components into an encoded String. All various URI components are optional, but encoded according to their respective valid character sets.
 * @param scheme the scheme
 * @param authority the authority
 * @param userInfo the user info
 * @param host the host
 * @param port the port
 * @param path the path
 * @param query the query
 * @param fragment the fragment
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}
 */
@Deprecated public static String encodeUriComponents(String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,String encoding) throws UnsupportedEncodingException {
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  StringBuilder sb=new StringBuilder();
  if (scheme != null) {
    sb.append(encodeScheme(scheme,encoding));
    sb.append(':');
  }
  if (authority != null) {
    sb.append(""//"");
    if (userInfo != null) {
      sb.append(encodeUserInfo(userInfo,encoding));
      sb.append('@');
    }
    if (host != null) {
      sb.append(encodeHost(host,encoding));
    }
    if (port != null) {
      sb.append(':');
      sb.append(encodePort(port,encoding));
    }
  }
  sb.append(encodePath(path,encoding));
  if (query != null) {
    sb.append('?');
    sb.append(encodeQuery(query,encoding));
  }
  if (fragment != null) {
    sb.append('#');
    sb.append(encodeFragment(fragment,encoding));
  }
  return sb.toString();
}
"
"/** 
 * Encodes the given source URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&""  characters in query parameter names and query parameter values because they cannot  be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromUri(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param uri the URI to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeUri(String uri,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(uri,""'uri' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=URI_PATTERN.matcher(uri);
  if (m.matches()) {
    String scheme=m.group(2);
    String authority=m.group(3);
    String userinfo=m.group(5);
    String host=m.group(6);
    String port=m.group(8);
    String path=m.group(9);
    String query=m.group(11);
    String fragment=m.group(13);
    return encodeUriComponents(scheme,authority,userinfo,host,port,path,query,fragment,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + uri + ""] is not a valid URI"");
  }
}
"
"/** 
 * Encodes the given HTTP URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not support fragments ( {@code #}), as these are not supposed to be sent to the server, but retained by the client. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&""  characters in query parameter names and query parameter values because they cannot  be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param httpUrl the HTTP URL to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URL
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeHttpUrl(String httpUrl,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(httpUrl,""'httpUrl' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=HTTP_URL_PATTERN.matcher(httpUrl);
  if (m.matches()) {
    String scheme=m.group(1);
    String authority=m.group(2);
    String userinfo=m.group(4);
    String host=m.group(5);
    String portString=m.group(7);
    String path=m.group(8);
    String query=m.group(10);
    return encodeUriComponents(scheme,authority,userinfo,host,portString,path,query,null,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + httpUrl + ""] is not a valid HTTP URL"");
  }
}
"
"/** 
 * Encodes the given source URI components into an encoded String. All various URI components are optional, but encoded according to their respective valid character sets.
 * @param scheme the scheme
 * @param authority the authority
 * @param userInfo the user info
 * @param host the host
 * @param port the port
 * @param path the path
 * @param query the query
 * @param fragment the fragment
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}
 */
@Deprecated public static String encodeUriComponents(String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,String encoding) throws UnsupportedEncodingException {
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  StringBuilder sb=new StringBuilder();
  if (scheme != null) {
    sb.append(encodeScheme(scheme,encoding));
    sb.append(':');
  }
  if (authority != null) {
    sb.append(""//"");
    if (userInfo != null) {
      sb.append(encodeUserInfo(userInfo,encoding));
      sb.append('@');
    }
    if (host != null) {
      sb.append(encodeHost(host,encoding));
    }
    if (port != null) {
      sb.append(':');
      sb.append(encodePort(port,encoding));
    }
  }
  sb.append(encodePath(path,encoding));
  if (query != null) {
    sb.append('?');
    sb.append(encodeQuery(query,encoding));
  }
  if (fragment != null) {
    sb.append('#');
    sb.append(encodeFragment(fragment,encoding));
  }
  return sb.toString();
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is <code>true</code> (the default), a request for  {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorParameter(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is <code>true</code>, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    this.cnManagerFactoryBean.getMediaTypes().putAll(mediaTypes);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Replacement for <code>Class.forName()</code> that also returns Class instances for primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return <code>false</code> if either the class or one of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Expect that the specified request header contains a subtring
 * @deprecated in favor of {@link #header(String,Matcher)}
 */
public static RequestMatcher headerContains(final String header,final String substring){
  Assert.notNull(header,""'header' must not be null"");
  Assert.notNull(substring,""'substring' must not be null"");
  return new RequestMatcher(){
    public void match(    ClientHttpRequest request) throws AssertionError {
      List<String> actualHeaders=request.getHeaders().get(header);
      AssertionErrors.assertTrue(""Expected header <"" + header + ""> in request"",actualHeaders != null);
      boolean foundMatch=false;
      for (      String headerValue : actualHeaders) {
        if (headerValue.contains(substring)) {
          foundMatch=true;
          break;
        }
      }
      AssertionErrors.assertTrue(""Expected value containing <"" + substring + ""> in header <""+ header+ "">"",foundMatch);
    }
  }
;
}
"
"/** 
 * Expect the given request body content.
 * @deprecated in favor of {@link #content()} as well as {@code jsonPath(..)}, and  {@code xpath(..)} methods in this class
 */
public static RequestMatcher body(final String body){
  Assert.notNull(body,""'body' must not be null"");
  return new RequestMatcher(){
    public void match(    ClientHttpRequest request) throws AssertionError, IOException {
      MockClientHttpRequest mockRequest=(MockClientHttpRequest)request;
      AssertionErrors.assertEquals(""Unexpected body content"",body,mockRequest.getBodyAsString());
    }
  }
;
}
"
"/** 
 * Respond with a given body, headers, status code, and status text.
 * @param body the body of the response ""UTF-8"" encoded
 * @param headers the response headers
 * @param statusCode the response status code
 * @param statusText the response status text
 * @deprecated in favor of methods returning DefaultResponseCreator
 */
public static ResponseCreator withResponse(final String body,final HttpHeaders headers,final HttpStatus statusCode,final String statusText){
  return new ResponseCreator(){
    public MockClientHttpResponse createResponse(    ClientHttpRequest request) throws IOException {
      MockClientHttpResponse response=new MockClientHttpResponse(body.getBytes(""UTF-8""),statusCode);
      response.getHeaders().putAll(headers);
      return response;
    }
  }
;
}
"
"/** 
 * Respond with the given body, headers, and a status code of 200 (OK).
 * @param body the body of the response ""UTF-8"" encoded
 * @param headers the response headers
 * @deprecated in favor of methods 'withXyz' in this class returning DefaultResponseCreator
 */
public static ResponseCreator withResponse(String body,HttpHeaders headers){
  return withResponse(body,headers,HttpStatus.OK,"""");
}
"
"/** 
 * Respond with a given body, headers, status code, and text.
 * @param body a {@link Resource} containing the body of the response
 * @param headers the response headers
 * @param statusCode the response status code
 * @param statusText the response status text
 * @deprecated in favor of methods 'withXyz' in this class returning DefaultResponseCreator
 */
public static ResponseCreator withResponse(final Resource body,final HttpHeaders headers,final HttpStatus statusCode,String statusText){
  return new ResponseCreator(){
    public MockClientHttpResponse createResponse(    ClientHttpRequest request) throws IOException {
      MockClientHttpResponse response=new MockClientHttpResponse(body.getInputStream(),statusCode);
      response.getHeaders().putAll(headers);
      return response;
    }
  }
;
}
"
"/** 
 * Respond with the given body, headers, and a status code of 200 (OK).
 * @param body the body of the response
 * @param headers the response headers
 * @deprecated in favor of methods 'withXyz' in this class returning DefaultResponseCreator
 */
public static ResponseCreator withResponse(final Resource body,final HttpHeaders headers){
  return withResponse(body,headers,HttpStatus.OK,"""");
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE
 */
public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of HttpStatus.METHOD_FAILURE
 */
public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of HttpStatus.DESTINATION_LOCKED
 */
public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Expect that the specified request header contains a subtring
 * @deprecated in favor of {@link #header(String,Matcher)}
 */
public static RequestMatcher headerContains(final String header,final String substring){
  Assert.notNull(header,""'header' must not be null"");
  Assert.notNull(substring,""'substring' must not be null"");
  return new RequestMatcher(){
    public void match(    ClientHttpRequest request) throws AssertionError {
      List<String> actualHeaders=request.getHeaders().get(header);
      AssertionErrors.assertTrue(""Expected header <"" + header + ""> in request"",actualHeaders != null);
      boolean foundMatch=false;
      for (      String headerValue : actualHeaders) {
        if (headerValue.contains(substring)) {
          foundMatch=true;
          break;
        }
      }
      AssertionErrors.assertTrue(""Expected value containing <"" + substring + ""> in header <""+ header+ "">"",foundMatch);
    }
  }
;
}
"
"/** 
 * Expect the given request body content.
 * @deprecated in favor of {@link #content()} as well as {@code jsonPath(..)}, and  {@code xpath(..)} methods in this class
 */
public static RequestMatcher body(final String body){
  Assert.notNull(body,""'body' must not be null"");
  return new RequestMatcher(){
    public void match(    ClientHttpRequest request) throws AssertionError, IOException {
      MockClientHttpRequest mockRequest=(MockClientHttpRequest)request;
      AssertionErrors.assertEquals(""Unexpected body content"",body,mockRequest.getBodyAsString());
    }
  }
;
}
"
"/** 
 * Respond with a given body, headers, status code, and status text.
 * @param body the body of the response ""UTF-8"" encoded
 * @param headers the response headers
 * @param statusCode the response status code
 * @param statusText the response status text
 * @deprecated in favor of methods returning DefaultResponseCreator
 */
public static ResponseCreator withResponse(final String body,final HttpHeaders headers,final HttpStatus statusCode,final String statusText){
  return new ResponseCreator(){
    public MockClientHttpResponse createResponse(    ClientHttpRequest request) throws IOException {
      MockClientHttpResponse response=new MockClientHttpResponse(body.getBytes(""UTF-8""),statusCode);
      response.getHeaders().putAll(headers);
      return response;
    }
  }
;
}
"
"/** 
 * Respond with the given body, headers, and a status code of 200 (OK).
 * @param body the body of the response ""UTF-8"" encoded
 * @param headers the response headers
 * @deprecated in favor of methods 'withXyz' in this class returning DefaultResponseCreator
 */
public static ResponseCreator withResponse(String body,HttpHeaders headers){
  return withResponse(body,headers,HttpStatus.OK,"""");
}
"
"/** 
 * Respond with a given body, headers, status code, and text.
 * @param body a {@link Resource} containing the body of the response
 * @param headers the response headers
 * @param statusCode the response status code
 * @param statusText the response status text
 * @deprecated in favor of methods 'withXyz' in this class returning DefaultResponseCreator
 */
public static ResponseCreator withResponse(final Resource body,final HttpHeaders headers,final HttpStatus statusCode,String statusText){
  return new ResponseCreator(){
    public MockClientHttpResponse createResponse(    ClientHttpRequest request) throws IOException {
      MockClientHttpResponse response=new MockClientHttpResponse(body.getInputStream(),statusCode);
      response.getHeaders().putAll(headers);
      return response;
    }
  }
;
}
"
"/** 
 * Respond with the given body, headers, and a status code of 200 (OK).
 * @param body the body of the response
 * @param headers the response headers
 * @deprecated in favor of methods 'withXyz' in this class returning DefaultResponseCreator
 */
public static ResponseCreator withResponse(final Resource body,final HttpHeaders headers){
  return withResponse(body,headers,HttpStatus.OK,"""");
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Encodes the given source URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&""  characters in query parameter names and query parameter values because they cannot  be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromUri(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param uri the URI to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeUri(String uri,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(uri,""'uri' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=URI_PATTERN.matcher(uri);
  if (m.matches()) {
    String scheme=m.group(2);
    String authority=m.group(3);
    String userinfo=m.group(5);
    String host=m.group(6);
    String port=m.group(8);
    String path=m.group(9);
    String query=m.group(11);
    String fragment=m.group(13);
    return encodeUriComponents(scheme,authority,userinfo,host,port,path,query,fragment,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + uri + ""] is not a valid URI"");
  }
}
"
"/** 
 * Encodes the given HTTP URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not support fragments ( {@code #}), as these are not supposed to be sent to the server, but retained by the client. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&""  characters in query parameter names and query parameter values because they cannot  be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param httpUrl the HTTP URL to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URL
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeHttpUrl(String httpUrl,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(httpUrl,""'httpUrl' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=HTTP_URL_PATTERN.matcher(httpUrl);
  if (m.matches()) {
    String scheme=m.group(1);
    String authority=m.group(2);
    String userinfo=m.group(4);
    String host=m.group(5);
    String portString=m.group(7);
    String path=m.group(8);
    String query=m.group(10);
    return encodeUriComponents(scheme,authority,userinfo,host,portString,path,query,null,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + httpUrl + ""] is not a valid HTTP URL"");
  }
}
"
"/** 
 * Encodes the given source URI components into an encoded String. All various URI components are optional, but encoded according to their respective valid character sets.
 * @param scheme the scheme
 * @param authority the authority
 * @param userInfo the user info
 * @param host the host
 * @param port the port
 * @param path the path
 * @param query the query
 * @param fragment the fragment
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}
 */
@Deprecated public static String encodeUriComponents(String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,String encoding) throws UnsupportedEncodingException {
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  StringBuilder sb=new StringBuilder();
  if (scheme != null) {
    sb.append(encodeScheme(scheme,encoding));
    sb.append(':');
  }
  if (authority != null) {
    sb.append(""//"");
    if (userInfo != null) {
      sb.append(encodeUserInfo(userInfo,encoding));
      sb.append('@');
    }
    if (host != null) {
      sb.append(encodeHost(host,encoding));
    }
    if (port != null) {
      sb.append(':');
      sb.append(encodePort(port,encoding));
    }
  }
  sb.append(encodePath(path,encoding));
  if (query != null) {
    sb.append('?');
    sb.append(encodeQuery(query,encoding));
  }
  if (fragment != null) {
    sb.append('#');
    sb.append(encodeFragment(fragment,encoding));
  }
  return sb.toString();
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Encodes the given source URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&""  characters in query parameter names and query parameter values because they cannot  be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromUri(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param uri the URI to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeUri(String uri,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(uri,""'uri' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=URI_PATTERN.matcher(uri);
  if (m.matches()) {
    String scheme=m.group(2);
    String authority=m.group(3);
    String userinfo=m.group(5);
    String host=m.group(6);
    String port=m.group(8);
    String path=m.group(9);
    String query=m.group(11);
    String fragment=m.group(13);
    return encodeUriComponents(scheme,authority,userinfo,host,port,path,query,fragment,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + uri + ""] is not a valid URI"");
  }
}
"
"/** 
 * Encodes the given HTTP URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not support fragments ( {@code #}), as these are not supposed to be sent to the server, but retained by the client. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&""  characters in query parameter names and query parameter values because they cannot  be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param httpUrl the HTTP URL to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URL
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeHttpUrl(String httpUrl,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(httpUrl,""'httpUrl' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=HTTP_URL_PATTERN.matcher(httpUrl);
  if (m.matches()) {
    String scheme=m.group(1);
    String authority=m.group(2);
    String userinfo=m.group(4);
    String host=m.group(5);
    String portString=m.group(7);
    String path=m.group(8);
    String query=m.group(10);
    return encodeUriComponents(scheme,authority,userinfo,host,portString,path,query,null,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + httpUrl + ""] is not a valid HTTP URL"");
  }
}
"
"/** 
 * Encodes the given source URI components into an encoded String. All various URI components are optional, but encoded according to their respective valid character sets.
 * @param scheme the scheme
 * @param authority the authority
 * @param userInfo the user info
 * @param host the host
 * @param port the port
 * @param path the path
 * @param query the query
 * @param fragment the fragment
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}
 */
@Deprecated public static String encodeUriComponents(String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,String encoding) throws UnsupportedEncodingException {
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  StringBuilder sb=new StringBuilder();
  if (scheme != null) {
    sb.append(encodeScheme(scheme,encoding));
    sb.append(':');
  }
  if (authority != null) {
    sb.append(""//"");
    if (userInfo != null) {
      sb.append(encodeUserInfo(userInfo,encoding));
      sb.append('@');
    }
    if (host != null) {
      sb.append(encodeHost(host,encoding));
    }
    if (port != null) {
      sb.append(':');
      sb.append(encodePort(port,encoding));
    }
  }
  sb.append(encodePath(path,encoding));
  if (query != null) {
    sb.append('?');
    sb.append(encodeQuery(query,encoding));
  }
  if (fragment != null) {
    sb.append('#');
    sb.append(encodeFragment(fragment,encoding));
  }
  return sb.toString();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE
 */
public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of HttpStatus.METHOD_FAILURE
 */
public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of HttpStatus.DESTINATION_LOCKED
 */
public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is <code>true</code> (the default), a request for  {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorParameter(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is <code>true</code>, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    this.cnManagerFactoryBean.getMediaTypes().putAll(mediaTypes);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Set the registration behavior by the name of the corresponding constant, e.g. ""REGISTRATION_IGNORE_EXISTING"".
 * @see #setRegistrationBehavior
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehaviorName(String registrationBehavior){
  setRegistrationBehavior(constants.asNumber(registrationBehavior).intValue());
}
"
"/** 
 * Specify what action should be taken when attempting to register an MBean under an  {@link javax.management.ObjectName} that already exists.<p>Default is REGISTRATION_FAIL_ON_EXISTING.
 * @see #setRegistrationBehaviorName(String)
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehavior(int registrationBehavior){
  setRegistrationPolicy(RegistrationPolicy.valueOf(registrationBehavior));
}
"
"/** 
 * Set the registration behavior by the name of the corresponding constant, e.g. ""REGISTRATION_IGNORE_EXISTING"".
 * @see #setRegistrationBehavior
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehaviorName(String registrationBehavior){
  setRegistrationBehavior(constants.asNumber(registrationBehavior).intValue());
}
"
"/** 
 * Specify what action should be taken when attempting to register an MBean under an  {@link javax.management.ObjectName} that already exists.<p>Default is REGISTRATION_FAIL_ON_EXISTING.
 * @see #setRegistrationBehaviorName(String)
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehavior(int registrationBehavior){
  setRegistrationPolicy(RegistrationPolicy.valueOf(registrationBehavior));
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE
 */
public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of HttpStatus.METHOD_FAILURE
 */
public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of HttpStatus.DESTINATION_LOCKED
 */
public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE
 */
public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of HttpStatus.METHOD_FAILURE
 */
public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of HttpStatus.DESTINATION_LOCKED
 */
public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Check whether the specified class is a CGLIB-generated class.
 * @param clazz the class to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)}
 */
@Deprecated public static boolean isCglibProxyClass(Class<?> clazz){
  return ClassUtils.isCglibProxyClass(clazz);
}
"
"/** 
 * Check whether the specified class name is a CGLIB-generated class.
 * @param className the class name to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)}
 */
@Deprecated public static boolean isCglibProxyClassName(String className){
  return ClassUtils.isCglibProxyClassName(className);
}
"
"/** 
 * Check whether the specified class is a CGLIB-generated class.
 * @param clazz the class to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)}
 */
@Deprecated public static boolean isCglibProxyClass(Class<?> clazz){
  return ClassUtils.isCglibProxyClass(clazz);
}
"
"/** 
 * Check whether the specified class name is a CGLIB-generated class.
 * @param className the class name to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)}
 */
@Deprecated public static boolean isCglibProxyClassName(String className){
  return ClassUtils.isCglibProxyClassName(className);
}
"
"/** 
 * Merge the specified Velocity template with the given model and write the result to the given Writer.
 * @param velocityEngine VelocityEngine to work with
 * @param templateLocation the location of template, relative to Velocity's resource loader path
 * @param model the Map that contains model names as keys and model objects as values
 * @param writer the Writer to write the result to
 * @throws VelocityException if the template wasn't found or rendering failed
 * @deprecated Use {@link #mergeTemplate(VelocityEngine,String,String,Map,Writer)}instead, following Velocity 1.6's corresponding deprecation in its own API.
 */
@Deprecated public static void mergeTemplate(VelocityEngine velocityEngine,String templateLocation,Map<String,Object> model,Writer writer) throws VelocityException {
  try {
    VelocityContext velocityContext=new VelocityContext(model);
    velocityEngine.mergeTemplate(templateLocation,velocityContext,writer);
  }
 catch (  VelocityException ex) {
    throw ex;
  }
catch (  RuntimeException ex) {
    throw ex;
  }
catch (  Exception ex) {
    logger.error(""Why does VelocityEngine throw a generic checked exception, after all?"",ex);
    throw new VelocityException(ex.toString());
  }
}
"
"/** 
 * Merge the specified Velocity template with the given model into a String. <p>When using this method to prepare a text for a mail to be sent with Spring's mail support, consider wrapping VelocityException in MailPreparationException.
 * @param velocityEngine VelocityEngine to work with
 * @param templateLocation the location of template, relative to Velocity's resource loader path
 * @param model the Map that contains model names as keys and model objects as values
 * @return the result as String
 * @throws VelocityException if the template wasn't found or rendering failed
 * @see org.springframework.mail.MailPreparationException
 * @deprecated Use {@link #mergeTemplateIntoString(VelocityEngine,String,String,Map)}instead, following Velocity 1.6's corresponding deprecation in its own API.
 */
@Deprecated public static String mergeTemplateIntoString(VelocityEngine velocityEngine,String templateLocation,Map<String,Object> model) throws VelocityException {
  StringWriter result=new StringWriter();
  mergeTemplate(velocityEngine,templateLocation,model,result);
  return result.toString();
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a List result.
 * @param action callback object that specifies the data access action
 * @return the List result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public List executeWithListResult(SqlMapClientCallback<List> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a Map result.
 * @param action callback object that specifies the data access action
 * @return the Map result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public Map executeWithMapResult(SqlMapClientCallback<Map> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(org.hibernate.cache.CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is <code>true</code> (the default), a request for  {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorParameter(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is <code>true</code>, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    this.cnManagerFactoryBean.getMediaTypes().putAll(mediaTypes);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Override settings in this bean definition (presumably a copied parent from a parent-child inheritance relationship) from the given bean definition (presumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Replacement for  {@code Class.forName()} that also returns Class instancesfor primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return  {@code false} if either the class orone of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link #registerAutoProxyCreatorIfNecessary(ParserContext,Element)} and{@link AopConfigUtils#registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry,Object)}
 */
@Deprecated public static void registerAutoProxyCreatorIfNecessary(ParserContext parserContext,Object source){
  BeanDefinition beanDefinition=AopConfigUtils.registerAutoProxyCreatorIfNecessary(parserContext.getRegistry(),source);
  registerComponentIfNecessary(beanDefinition,parserContext);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link AopConfigUtils#forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry)}
 */
@Deprecated public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry){
  AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
}
"
"/** 
 * Add all of the given advisors to this proxy configuration.
 * @param advisors the advisors to register
 * @deprecated as of Spring 3.0, in favor of {@link #addAdvisors}
 */
@Deprecated public void addAllAdvisors(Advisor[] advisors){
  addAdvisors(Arrays.asList(advisors));
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(String,Object)}
 */
@Deprecated public ModelMap addObject(String modelName,Object modelObject){
  return addAttribute(modelName,modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(Object)}
 */
@Deprecated public ModelMap addObject(Object modelObject){
  return addAttribute(modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Collection)}
 */
@Deprecated public ModelMap addAllObjects(Collection objects){
  return addAllAttributes(objects);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Map)}
 */
@Deprecated public ModelMap addAllObjects(Map objects){
  return addAllAttributes(objects);
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Check whether the specified class is a CGLIB-generated class.
 * @param clazz the class to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)}
 */
@Deprecated public static boolean isCglibProxyClass(Class<?> clazz){
  return ClassUtils.isCglibProxyClass(clazz);
}
"
"/** 
 * Check whether the specified class name is a CGLIB-generated class.
 * @param className the class name to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)}
 */
@Deprecated public static boolean isCglibProxyClassName(String className){
  return ClassUtils.isCglibProxyClassName(className);
}
"
"/** 
 * Constructor for CannotGetJdbcConnectionException.
 * @param msg the detail message
 * @param ex ClassNotFoundException root cause
 * @deprecated since Spring 2.5, in favor of throwing anIllegalStateException in case of the driver not being found
 */
@Deprecated public CannotGetJdbcConnectionException(String msg,ClassNotFoundException ex){
  super(msg,ex);
}
"
"/** 
 * Register the given custom property editor for all properties of the given type, indicating that the given instance is a shared editor that might be used concurrently.
 * @param requiredType the type of the property
 * @param propertyEditor the shared editor to register
 * @deprecated as of Spring 3.0, in favor of PropertyEditorRegistrars or ConversionService usage
 */
@Deprecated public void registerSharedEditor(Class<?> requiredType,PropertyEditor propertyEditor){
  registerCustomEditor(requiredType,null,propertyEditor);
  if (this.sharedEditors == null) {
    this.sharedEditors=new HashSet<PropertyEditor>();
  }
  this.sharedEditors.add(propertyEditor);
}
"
"/** 
 * Override settings in this bean definition (presumably a copied parent from a parent-child inheritance relationship) from the given bean definition (presumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Set the name of the factory bean to use for this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setFactoryBean(String factoryBean,String factoryMethod){
  this.beanDefinition.setFactoryBeanName(factoryBean);
  this.beanDefinition.setFactoryMethodName(factoryMethod);
  return this;
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Set whether or not this definition describes a singleton bean, as alternative to  {@link #setScope}.
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public BeanDefinitionBuilder setSingleton(boolean singleton){
  this.beanDefinition.setSingleton(singleton);
  return this;
}
"
"/** 
 * Set the source of this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setSource(Object source){
  this.beanDefinition.setSource(source);
  return this;
}
"
"/** 
 * Set the description associated with this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setResourceDescription(String resourceDescription){
  this.beanDefinition.setResourceDescription(resourceDescription);
  return this;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Create a new ResourceEditorRegistrar for the given  {@link ResourceLoader}using a  {@link StandardEnvironment}.
 * @param resourceLoader the ResourceLoader (or ResourcePatternResolver)to create editors for (usually an ApplicationContext)
 * @see org.springframework.core.io.support.ResourcePatternResolver
 * @see org.springframework.context.ApplicationContext
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditorRegistrar(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditorRegistrar(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment());
}
"
"/** 
 * Set a List of  {@code TemplateLoader}s that will be used to search for templates. For example, one or more custom loaders such as database loaders could be configured and injected here.
 * @deprecated as of Spring 2.0.1, in favor of the ""preTemplateLoaders""and ""postTemplateLoaders"" properties
 * @see #setPreTemplateLoaders
 * @see #setPostTemplateLoaders
 */
@Deprecated public void setTemplateLoaders(TemplateLoader[] templateLoaders){
  if (templateLoaders != null) {
    this.templateLoaders.addAll(Arrays.asList(templateLoaders));
  }
}
"
"/** 
 * Set the registration behavior by the name of the corresponding constant, e.g. ""REGISTRATION_IGNORE_EXISTING"".
 * @see #setRegistrationBehavior
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehaviorName(String registrationBehavior){
  setRegistrationBehavior(constants.asNumber(registrationBehavior).intValue());
}
"
"/** 
 * Specify what action should be taken when attempting to register an MBean under an  {@link javax.management.ObjectName} that already exists.<p>Default is REGISTRATION_FAIL_ON_EXISTING.
 * @see #setRegistrationBehaviorName(String)
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehavior(int registrationBehavior){
  setRegistrationPolicy(RegistrationPolicy.valueOf(registrationBehavior));
}
"
"/** 
 * Apply the given method invocation to the given RMI stub. <p>Delegates to the corresponding method if the RMI stub does not directly implement the invoked method. This typically happens when a non-RMI service interface is used for an RMI service. The methods of such a service interface have to match the RMI stub methods, but they typically don't declare {@code java.rmi.RemoteException}: A RemoteException thrown by the RMI stub will be automatically converted to Spring's RemoteAccessException.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object invoke(MethodInvocation invocation,Remote stub,String serviceName) throws Throwable {
  try {
    return invokeRemoteMethod(invocation,stub);
  }
 catch (  InvocationTargetException ex) {
    Throwable targetEx=ex.getTargetException();
    if (targetEx instanceof RemoteException) {
      RemoteException rex=(RemoteException)targetEx;
      throw convertRmiAccessException(invocation.getMethod(),rex,serviceName);
    }
 else {
      throw targetEx;
    }
  }
}
"
"/** 
 * Perform a raw method invocation on the given RMI stub, letting reflection exceptions through as-is.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object doInvoke(MethodInvocation invocation,Remote stub) throws InvocationTargetException {
  return invokeRemoteMethod(invocation,stub);
}
"
"/** 
 * @deprecated in favor of {@link #returningResultSet(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public SimpleJdbcCall returningResultSet(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,rowMapper);
  return this;
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(String,Object)}
 */
@Deprecated public ModelMap addObject(String modelName,Object modelObject){
  return addAttribute(modelName,modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(Object)}
 */
@Deprecated public ModelMap addObject(Object modelObject){
  return addAttribute(modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Collection)}
 */
@Deprecated public ModelMap addAllObjects(Collection objects){
  return addAllAttributes(objects);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Map)}
 */
@Deprecated public ModelMap addAllObjects(Map objects){
  return addAllAttributes(objects);
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.4.
 * @return {@code true} if the current JVM is at least Java 1.4
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_14
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava14(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.5 (Java 5).
 * @return {@code true} if the current JVM is at least Java 1.5
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava15(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.6 (Java 6).
 * @return {@code true} if the current JVM is at least Java 1.6
 * @deprecated as of Spring 3.0, in favor of reflective checks forthe specific Java 1.6 classes of interest
 * @see #getMajorJavaVersion()
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava16(){
  return (majorJavaVersion >= JAVA_16);
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader} and a {@link StandardEnvironment}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding property could be found
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver,boolean)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader,boolean ignoreUnresolvablePlaceholders){
  this(resourceLoader,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver){
  this(resourcePatternResolver,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding system property could be found
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver,boolean)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver,boolean ignoreUnresolvablePlaceholders){
  this(resourcePatternResolver,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Replacement for  {@code Class.forName()} that also returns Class instancesfor primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return  {@code false} if either the class orone of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Add a  {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.
 * @deprecated in favor of {@link #addDeclaredRowMapper(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public void addDeclaredRowMapper(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,(RowMapper)rowMapper);
}
"
"/** 
 * @deprecated in favor of {@link #returningResultSet(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public SimpleJdbcCall returningResultSet(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,rowMapper);
  return this;
}
"
"/** 
 * Create a new DriverManagerDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @deprecated since Spring 2.5. DriverManagerDataSource is primarilyintended for accessing <i>pre-registered</i> JDBC drivers. If you need to register a new driver, consider using {@link SimpleDriverDataSource} instead.
 */
@Deprecated public DriverManagerDataSource(String driverClassName,String url,String username,String password){
  setDriverClassName(driverClassName);
  setUrl(url);
  setUsername(username);
  setPassword(password);
}
"
"/** 
 * Create a new SingleConnectionDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @param suppressClose if the returned Connection should be aclose-suppressing proxy or the physical Connection
 * @deprecated since Spring 2.5. Driver parameter usage is generally not recommendedfor a SingleConnectionDataSource. If you insist on using driver parameters directly, set up the Driver class manually before invoking this DataSource.
 * @see java.sql.DriverManager#getConnection(String,String,String)
 */
@Deprecated public SingleConnectionDataSource(String driverClassName,String url,String username,String password,boolean suppressClose){
  super(driverClassName,url,username,password);
  this.suppressClose=suppressClose;
}
"
"/** 
 * Encodes the given source URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromUri(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param uri the URI to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeUri(String uri,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(uri,""'uri' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=URI_PATTERN.matcher(uri);
  if (m.matches()) {
    String scheme=m.group(2);
    String authority=m.group(3);
    String userinfo=m.group(5);
    String host=m.group(6);
    String port=m.group(8);
    String path=m.group(9);
    String query=m.group(11);
    String fragment=m.group(13);
    return encodeUriComponents(scheme,authority,userinfo,host,port,path,query,fragment,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + uri + ""] is not a valid URI"");
  }
}
"
"/** 
 * Encodes the given HTTP URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not support fragments ( {@code #}), as these are not supposed to be sent to the server, but retained by the client. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param httpUrl the HTTP URL to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URL
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeHttpUrl(String httpUrl,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(httpUrl,""'httpUrl' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=HTTP_URL_PATTERN.matcher(httpUrl);
  if (m.matches()) {
    String scheme=m.group(1);
    String authority=m.group(2);
    String userinfo=m.group(4);
    String host=m.group(5);
    String portString=m.group(7);
    String path=m.group(8);
    String query=m.group(10);
    return encodeUriComponents(scheme,authority,userinfo,host,portString,path,query,null,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + httpUrl + ""] is not a valid HTTP URL"");
  }
}
"
"/** 
 * Encodes the given source URI components into an encoded String. All various URI components are optional, but encoded according to their respective valid character sets.
 * @param scheme the scheme
 * @param authority the authority
 * @param userInfo the user info
 * @param host the host
 * @param port the port
 * @param path the path
 * @param query the query
 * @param fragment the fragment
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}
 */
@Deprecated public static String encodeUriComponents(String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,String encoding) throws UnsupportedEncodingException {
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  StringBuilder sb=new StringBuilder();
  if (scheme != null) {
    sb.append(encodeScheme(scheme,encoding));
    sb.append(':');
  }
  if (authority != null) {
    sb.append(""//"");
    if (userInfo != null) {
      sb.append(encodeUserInfo(userInfo,encoding));
      sb.append('@');
    }
    if (host != null) {
      sb.append(encodeHost(host,encoding));
    }
    if (port != null) {
      sb.append(':');
      sb.append(encodePort(port,encoding));
    }
  }
  sb.append(encodePath(path,encoding));
  if (query != null) {
    sb.append('?');
    sb.append(encodeQuery(query,encoding));
  }
  if (fragment != null) {
    sb.append('#');
    sb.append(encodeFragment(fragment,encoding));
  }
  return sb.toString();
}
"
"/** 
 * Override settings in this bean definition (presumably a copied parent from a parent-child inheritance relationship) from the given bean definition (presumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
@Deprecated public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(org.hibernate.cache.CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a List result.
 * @param action callback object that specifies the data access action
 * @return the List result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public List executeWithListResult(SqlMapClientCallback<List> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a Map result.
 * @param action callback object that specifies the data access action
 * @return the Map result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public Map executeWithMapResult(SqlMapClientCallback<Map> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
@Deprecated public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Create a new default GenericConversionService instance that can be safely modified.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#DefaultConversionService()}
 */
@Deprecated public static GenericConversionService createDefaultConversionService(){
  return new DefaultConversionService();
}
"
"/** 
 * Populate the given GenericConversionService instance with the set of default converters.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#addDefaultConverters(ConverterRegistry)}
 */
@Deprecated public static void addDefaultConverters(GenericConversionService conversionService){
  DefaultConversionService.addDefaultConverters(conversionService);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of HttpStatus.METHOD_FAILURE
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of HttpStatus.DESTINATION_LOCKED
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param beanFactory the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.1.2 in favor of{@link BeanFactoryAnnotationUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
@Deprecated public static PlatformTransactionManager getTransactionManager(BeanFactory beanFactory,String qualifier){
  return BeanFactoryAnnotationUtils.qualifiedBeanOfType(beanFactory,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param bf the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.1.2 in favor of{@link BeanFactoryAnnotationUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
@Deprecated public static PlatformTransactionManager getTransactionManager(ConfigurableListableBeanFactory bf,String qualifier){
  return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorParameter(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    this.cnManagerFactoryBean.getMediaTypes().putAll(mediaTypes);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(String,Object)}
 */
@Deprecated public ModelMap addObject(String modelName,Object modelObject){
  return addAttribute(modelName,modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(Object)}
 */
@Deprecated public ModelMap addObject(Object modelObject){
  return addAttribute(modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Collection)}
 */
@Deprecated public ModelMap addAllObjects(Collection objects){
  return addAllAttributes(objects);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Map)}
 */
@Deprecated public ModelMap addAllObjects(Map objects){
  return addAllAttributes(objects);
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a new default GenericConversionService instance that can be safely modified.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#DefaultConversionService()}
 */
@Deprecated public static GenericConversionService createDefaultConversionService(){
  return new DefaultConversionService();
}
"
"/** 
 * Populate the given GenericConversionService instance with the set of default converters.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#addDefaultConverters(ConverterRegistry)}
 */
@Deprecated public static void addDefaultConverters(GenericConversionService conversionService){
  DefaultConversionService.addDefaultConverters(conversionService);
}
"
"/** 
 * Replacement for  {@code Class.forName()} that also returns Class instancesfor primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return  {@code false} if either the class orone of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Constructor for CannotGetJdbcConnectionException.
 * @param msg the detail message
 * @param ex ClassNotFoundException root cause
 * @deprecated since Spring 2.5, in favor of throwing anIllegalStateException in case of the driver not being found
 */
@Deprecated public CannotGetJdbcConnectionException(String msg,ClassNotFoundException ex){
  super(msg,ex);
}
"
"/** 
 * Return the ContextLoader used by this listener.
 * @return the current ContextLoader
 * @deprecated in favor of simply subclassing ContextLoaderListener itself(which extends ContextLoader, as of Spring 3.0)
 */
@Deprecated public ContextLoader getContextLoader(){
  return this.contextLoader;
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of HttpStatus.METHOD_FAILURE
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of HttpStatus.DESTINATION_LOCKED
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Encodes the given source URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromUri(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param uri the URI to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeUri(String uri,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(uri,""'uri' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=URI_PATTERN.matcher(uri);
  if (m.matches()) {
    String scheme=m.group(2);
    String authority=m.group(3);
    String userinfo=m.group(5);
    String host=m.group(6);
    String port=m.group(8);
    String path=m.group(9);
    String query=m.group(11);
    String fragment=m.group(13);
    return encodeUriComponents(scheme,authority,userinfo,host,port,path,query,fragment,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + uri + ""] is not a valid URI"");
  }
}
"
"/** 
 * Encodes the given HTTP URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not support fragments ( {@code #}), as these are not supposed to be sent to the server, but retained by the client. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param httpUrl the HTTP URL to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URL
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeHttpUrl(String httpUrl,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(httpUrl,""'httpUrl' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=HTTP_URL_PATTERN.matcher(httpUrl);
  if (m.matches()) {
    String scheme=m.group(1);
    String authority=m.group(2);
    String userinfo=m.group(4);
    String host=m.group(5);
    String portString=m.group(7);
    String path=m.group(8);
    String query=m.group(10);
    return encodeUriComponents(scheme,authority,userinfo,host,portString,path,query,null,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + httpUrl + ""] is not a valid HTTP URL"");
  }
}
"
"/** 
 * Encodes the given source URI components into an encoded String. All various URI components are optional, but encoded according to their respective valid character sets.
 * @param scheme the scheme
 * @param authority the authority
 * @param userInfo the user info
 * @param host the host
 * @param port the port
 * @param path the path
 * @param query the query
 * @param fragment the fragment
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}
 */
@Deprecated public static String encodeUriComponents(String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,String encoding) throws UnsupportedEncodingException {
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  StringBuilder sb=new StringBuilder();
  if (scheme != null) {
    sb.append(encodeScheme(scheme,encoding));
    sb.append(':');
  }
  if (authority != null) {
    sb.append(""//"");
    if (userInfo != null) {
      sb.append(encodeUserInfo(userInfo,encoding));
      sb.append('@');
    }
    if (host != null) {
      sb.append(encodeHost(host,encoding));
    }
    if (port != null) {
      sb.append(':');
      sb.append(encodePort(port,encoding));
    }
  }
  sb.append(encodePath(path,encoding));
  if (query != null) {
    sb.append('?');
    sb.append(encodeQuery(query,encoding));
  }
  if (fragment != null) {
    sb.append('#');
    sb.append(encodeFragment(fragment,encoding));
  }
  return sb.toString();
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param beanFactory the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.1.2 in favor of{@link BeanFactoryAnnotationUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
@Deprecated public static PlatformTransactionManager getTransactionManager(BeanFactory beanFactory,String qualifier){
  return BeanFactoryAnnotationUtils.qualifiedBeanOfType(beanFactory,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param bf the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.1.2 in favor of{@link BeanFactoryAnnotationUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
@Deprecated public static PlatformTransactionManager getTransactionManager(ConfigurableListableBeanFactory bf,String qualifier){
  return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE
 */
public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of HttpStatus.METHOD_FAILURE
 */
public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of HttpStatus.DESTINATION_LOCKED
 */
public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorParameter(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    this.cnManagerFactoryBean.getMediaTypes().putAll(mediaTypes);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorParameter(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    this.cnManagerFactoryBean.getMediaTypes().putAll(mediaTypes);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link #registerAutoProxyCreatorIfNecessary(ParserContext,Element)} and{@link AopConfigUtils#registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry,Object)}
 */
@Deprecated public static void registerAutoProxyCreatorIfNecessary(ParserContext parserContext,Object source){
  BeanDefinition beanDefinition=AopConfigUtils.registerAutoProxyCreatorIfNecessary(parserContext.getRegistry(),source);
  registerComponentIfNecessary(beanDefinition,parserContext);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link AopConfigUtils#forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry)}
 */
@Deprecated public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry){
  AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
}
"
"/** 
 * Add all of the given advisors to this proxy configuration.
 * @param advisors the advisors to register
 * @deprecated as of Spring 3.0, in favor of {@link #addAdvisors}
 */
@Deprecated public void addAllAdvisors(Advisor[] advisors){
  addAdvisors(Arrays.asList(advisors));
}
"
"/** 
 * Check whether the specified class is a CGLIB-generated class.
 * @param clazz the class to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)}
 */
@Deprecated public static boolean isCglibProxyClass(Class<?> clazz){
  return ClassUtils.isCglibProxyClass(clazz);
}
"
"/** 
 * Check whether the specified class name is a CGLIB-generated class.
 * @param className the class name to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)}
 */
@Deprecated public static boolean isCglibProxyClassName(String className){
  return ClassUtils.isCglibProxyClassName(className);
}
"
"/** 
 * Register the given custom property editor for all properties of the given type, indicating that the given instance is a shared editor that might be used concurrently.
 * @param requiredType the type of the property
 * @param propertyEditor the shared editor to register
 * @deprecated as of Spring 3.0, in favor of PropertyEditorRegistrars or ConversionService usage
 */
@Deprecated public void registerSharedEditor(Class<?> requiredType,PropertyEditor propertyEditor){
  registerCustomEditor(requiredType,null,propertyEditor);
  if (this.sharedEditors == null) {
    this.sharedEditors=new HashSet<PropertyEditor>();
  }
  this.sharedEditors.add(propertyEditor);
}
"
"/** 
 * Override settings in this bean definition (presumably a copied parent from a parent-child inheritance relationship) from the given bean definition (presumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Set the name of the factory bean to use for this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setFactoryBean(String factoryBean,String factoryMethod){
  this.beanDefinition.setFactoryBeanName(factoryBean);
  this.beanDefinition.setFactoryMethodName(factoryMethod);
  return this;
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Set whether or not this definition describes a singleton bean, as alternative to  {@link #setScope}.
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public BeanDefinitionBuilder setSingleton(boolean singleton){
  this.beanDefinition.setSingleton(singleton);
  return this;
}
"
"/** 
 * Set the source of this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setSource(Object source){
  this.beanDefinition.setSource(source);
  return this;
}
"
"/** 
 * Set the description associated with this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setResourceDescription(String resourceDescription){
  this.beanDefinition.setResourceDescription(resourceDescription);
  return this;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Create a new ResourceEditorRegistrar for the given  {@link ResourceLoader}using a  {@link StandardEnvironment}.
 * @param resourceLoader the ResourceLoader (or ResourcePatternResolver)to create editors for (usually an ApplicationContext)
 * @see org.springframework.core.io.support.ResourcePatternResolver
 * @see org.springframework.context.ApplicationContext
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditorRegistrar(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditorRegistrar(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment());
}
"
"/** 
 * Set a List of  {@code TemplateLoader}s that will be used to search for templates. For example, one or more custom loaders such as database loaders could be configured and injected here.
 * @deprecated as of Spring 2.0.1, in favor of the ""preTemplateLoaders""and ""postTemplateLoaders"" properties
 * @see #setPreTemplateLoaders
 * @see #setPostTemplateLoaders
 */
@Deprecated public void setTemplateLoaders(TemplateLoader[] templateLoaders){
  if (templateLoaders != null) {
    this.templateLoaders.addAll(Arrays.asList(templateLoaders));
  }
}
"
"/** 
 * Set the registration behavior by the name of the corresponding constant, e.g. ""REGISTRATION_IGNORE_EXISTING"".
 * @see #setRegistrationBehavior
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehaviorName(String registrationBehavior){
  setRegistrationBehavior(constants.asNumber(registrationBehavior).intValue());
}
"
"/** 
 * Specify what action should be taken when attempting to register an MBean under an  {@link javax.management.ObjectName} that already exists.<p>Default is REGISTRATION_FAIL_ON_EXISTING.
 * @see #setRegistrationBehaviorName(String)
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehavior(int registrationBehavior){
  setRegistrationPolicy(RegistrationPolicy.valueOf(registrationBehavior));
}
"
"/** 
 * Apply the given method invocation to the given RMI stub. <p>Delegates to the corresponding method if the RMI stub does not directly implement the invoked method. This typically happens when a non-RMI service interface is used for an RMI service. The methods of such a service interface have to match the RMI stub methods, but they typically don't declare {@code java.rmi.RemoteException}: A RemoteException thrown by the RMI stub will be automatically converted to Spring's RemoteAccessException.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object invoke(MethodInvocation invocation,Remote stub,String serviceName) throws Throwable {
  try {
    return invokeRemoteMethod(invocation,stub);
  }
 catch (  InvocationTargetException ex) {
    Throwable targetEx=ex.getTargetException();
    if (targetEx instanceof RemoteException) {
      RemoteException rex=(RemoteException)targetEx;
      throw convertRmiAccessException(invocation.getMethod(),rex,serviceName);
    }
 else {
      throw targetEx;
    }
  }
}
"
"/** 
 * Perform a raw method invocation on the given RMI stub, letting reflection exceptions through as-is.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object doInvoke(MethodInvocation invocation,Remote stub) throws InvocationTargetException {
  return invokeRemoteMethod(invocation,stub);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(String,Object)}
 */
@Deprecated public ModelMap addObject(String modelName,Object modelObject){
  return addAttribute(modelName,modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(Object)}
 */
@Deprecated public ModelMap addObject(Object modelObject){
  return addAttribute(modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Collection)}
 */
@Deprecated public ModelMap addAllObjects(Collection objects){
  return addAllAttributes(objects);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Map)}
 */
@Deprecated public ModelMap addAllObjects(Map objects){
  return addAllAttributes(objects);
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.4.
 * @return {@code true} if the current JVM is at least Java 1.4
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_14
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava14(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.5 (Java 5).
 * @return {@code true} if the current JVM is at least Java 1.5
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava15(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.6 (Java 6).
 * @return {@code true} if the current JVM is at least Java 1.6
 * @deprecated as of Spring 3.0, in favor of reflective checks forthe specific Java 1.6 classes of interest
 * @see #getMajorJavaVersion()
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava16(){
  return (majorJavaVersion >= JAVA_16);
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * @deprecated in favor of {@link #returningResultSet(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public SimpleJdbcCall returningResultSet(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,rowMapper);
  return this;
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader} and a {@link StandardEnvironment}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding property could be found
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver,boolean)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader,boolean ignoreUnresolvablePlaceholders){
  this(resourceLoader,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver){
  this(resourcePatternResolver,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding system property could be found
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver,boolean)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver,boolean ignoreUnresolvablePlaceholders){
  this(resourcePatternResolver,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Replacement for  {@code Class.forName()} that also returns Class instancesfor primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return  {@code false} if either the class orone of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Add a  {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.
 * @deprecated in favor of {@link #addDeclaredRowMapper(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public void addDeclaredRowMapper(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,(RowMapper)rowMapper);
}
"
"/** 
 * @deprecated in favor of {@link #returningResultSet(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public SimpleJdbcCall returningResultSet(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,rowMapper);
  return this;
}
"
"/** 
 * Create a new DriverManagerDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @deprecated since Spring 2.5. DriverManagerDataSource is primarilyintended for accessing <i>pre-registered</i> JDBC drivers. If you need to register a new driver, consider using {@link SimpleDriverDataSource} instead.
 */
@Deprecated public DriverManagerDataSource(String driverClassName,String url,String username,String password){
  setDriverClassName(driverClassName);
  setUrl(url);
  setUsername(username);
  setPassword(password);
}
"
"/** 
 * Create a new SingleConnectionDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @param suppressClose if the returned Connection should be aclose-suppressing proxy or the physical Connection
 * @deprecated since Spring 2.5. Driver parameter usage is generally not recommendedfor a SingleConnectionDataSource. If you insist on using driver parameters directly, set up the Driver class manually before invoking this DataSource.
 * @see java.sql.DriverManager#getConnection(String,String,String)
 */
@Deprecated public SingleConnectionDataSource(String driverClassName,String url,String username,String password,boolean suppressClose){
  super(driverClassName,url,username,password);
  this.suppressClose=suppressClose;
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE
 */
public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of HttpStatus.METHOD_FAILURE
 */
public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of HttpStatus.DESTINATION_LOCKED
 */
public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link #registerAutoProxyCreatorIfNecessary(ParserContext,Element)} and{@link AopConfigUtils#registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry,Object)}
 */
@Deprecated public static void registerAutoProxyCreatorIfNecessary(ParserContext parserContext,Object source){
  BeanDefinition beanDefinition=AopConfigUtils.registerAutoProxyCreatorIfNecessary(parserContext.getRegistry(),source);
  registerComponentIfNecessary(beanDefinition,parserContext);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link AopConfigUtils#forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry)}
 */
@Deprecated public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry){
  AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
}
"
"/** 
 * Add all of the given advisors to this proxy configuration.
 * @param advisors the advisors to register
 * @deprecated as of Spring 3.0, in favor of {@link #addAdvisors}
 */
@Deprecated public void addAllAdvisors(Advisor[] advisors){
  addAdvisors(Arrays.asList(advisors));
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(org.hibernate.cache.CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a List result.
 * @param action callback object that specifies the data access action
 * @return the List result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public List executeWithListResult(SqlMapClientCallback<List> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a Map result.
 * @param action callback object that specifies the data access action
 * @return the Map result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public Map executeWithMapResult(SqlMapClientCallback<Map> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Encodes the given source URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromUri(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param uri the URI to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeUri(String uri,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(uri,""'uri' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=URI_PATTERN.matcher(uri);
  if (m.matches()) {
    String scheme=m.group(2);
    String authority=m.group(3);
    String userinfo=m.group(5);
    String host=m.group(6);
    String port=m.group(8);
    String path=m.group(9);
    String query=m.group(11);
    String fragment=m.group(13);
    return encodeUriComponents(scheme,authority,userinfo,host,port,path,query,fragment,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + uri + ""] is not a valid URI"");
  }
}
"
"/** 
 * Encodes the given HTTP URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not support fragments ( {@code #}), as these are not supposed to be sent to the server, but retained by the client. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param httpUrl the HTTP URL to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URL
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeHttpUrl(String httpUrl,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(httpUrl,""'httpUrl' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=HTTP_URL_PATTERN.matcher(httpUrl);
  if (m.matches()) {
    String scheme=m.group(1);
    String authority=m.group(2);
    String userinfo=m.group(4);
    String host=m.group(5);
    String portString=m.group(7);
    String path=m.group(8);
    String query=m.group(10);
    return encodeUriComponents(scheme,authority,userinfo,host,portString,path,query,null,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + httpUrl + ""] is not a valid HTTP URL"");
  }
}
"
"/** 
 * Encodes the given source URI components into an encoded String. All various URI components are optional, but encoded according to their respective valid character sets.
 * @param scheme the scheme
 * @param authority the authority
 * @param userInfo the user info
 * @param host the host
 * @param port the port
 * @param path the path
 * @param query the query
 * @param fragment the fragment
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}
 */
@Deprecated public static String encodeUriComponents(String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,String encoding) throws UnsupportedEncodingException {
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  StringBuilder sb=new StringBuilder();
  if (scheme != null) {
    sb.append(encodeScheme(scheme,encoding));
    sb.append(':');
  }
  if (authority != null) {
    sb.append(""//"");
    if (userInfo != null) {
      sb.append(encodeUserInfo(userInfo,encoding));
      sb.append('@');
    }
    if (host != null) {
      sb.append(encodeHost(host,encoding));
    }
    if (port != null) {
      sb.append(':');
      sb.append(encodePort(port,encoding));
    }
  }
  sb.append(encodePath(path,encoding));
  if (query != null) {
    sb.append('?');
    sb.append(encodeQuery(query,encoding));
  }
  if (fragment != null) {
    sb.append('#');
    sb.append(encodeFragment(fragment,encoding));
  }
  return sb.toString();
}
"
"/** 
 * Register the given custom property editor for all properties of the given type, indicating that the given instance is a shared editor that might be used concurrently.
 * @param requiredType the type of the property
 * @param propertyEditor the shared editor to register
 * @deprecated as of Spring 3.0, in favor of PropertyEditorRegistrars or ConversionService usage
 */
@Deprecated public void registerSharedEditor(Class<?> requiredType,PropertyEditor propertyEditor){
  registerCustomEditor(requiredType,null,propertyEditor);
  if (this.sharedEditors == null) {
    this.sharedEditors=new HashSet<PropertyEditor>();
  }
  this.sharedEditors.add(propertyEditor);
}
"
"/** 
 * Set the name of the factory bean to use for this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setFactoryBean(String factoryBean,String factoryMethod){
  this.beanDefinition.setFactoryBeanName(factoryBean);
  this.beanDefinition.setFactoryMethodName(factoryMethod);
  return this;
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Set whether or not this definition describes a singleton bean, as alternative to  {@link #setScope}.
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public BeanDefinitionBuilder setSingleton(boolean singleton){
  this.beanDefinition.setSingleton(singleton);
  return this;
}
"
"/** 
 * Set the source of this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setSource(Object source){
  this.beanDefinition.setSource(source);
  return this;
}
"
"/** 
 * Set the description associated with this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setResourceDescription(String resourceDescription){
  this.beanDefinition.setResourceDescription(resourceDescription);
  return this;
}
"
"/** 
 * Return the ContextLoader used by this listener.
 * @return the current ContextLoader
 * @deprecated in favor of simply subclassing ContextLoaderListener itself(which extends ContextLoader, as of Spring 3.0)
 */
@Deprecated public ContextLoader getContextLoader(){
  return this.contextLoader;
}
"
"/** 
 * Set a List of  {@code TemplateLoader}s that will be used to search for templates. For example, one or more custom loaders such as database loaders could be configured and injected here.
 * @deprecated as of Spring 2.0.1, in favor of the ""preTemplateLoaders""and ""postTemplateLoaders"" properties
 * @see #setPreTemplateLoaders
 * @see #setPostTemplateLoaders
 */
@Deprecated public void setTemplateLoaders(TemplateLoader[] templateLoaders){
  if (templateLoaders != null) {
    this.templateLoaders.addAll(Arrays.asList(templateLoaders));
  }
}
"
"/** 
 * Encodes the given source URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromUri(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param uri the URI to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeUri(String uri,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(uri,""'uri' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=URI_PATTERN.matcher(uri);
  if (m.matches()) {
    String scheme=m.group(2);
    String authority=m.group(3);
    String userinfo=m.group(5);
    String host=m.group(6);
    String port=m.group(8);
    String path=m.group(9);
    String query=m.group(11);
    String fragment=m.group(13);
    return encodeUriComponents(scheme,authority,userinfo,host,port,path,query,fragment,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + uri + ""] is not a valid URI"");
  }
}
"
"/** 
 * Encodes the given HTTP URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not support fragments ( {@code #}), as these are not supposed to be sent to the server, but retained by the client. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param httpUrl the HTTP URL to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URL
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeHttpUrl(String httpUrl,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(httpUrl,""'httpUrl' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=HTTP_URL_PATTERN.matcher(httpUrl);
  if (m.matches()) {
    String scheme=m.group(1);
    String authority=m.group(2);
    String userinfo=m.group(4);
    String host=m.group(5);
    String portString=m.group(7);
    String path=m.group(8);
    String query=m.group(10);
    return encodeUriComponents(scheme,authority,userinfo,host,portString,path,query,null,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + httpUrl + ""] is not a valid HTTP URL"");
  }
}
"
"/** 
 * Encodes the given source URI components into an encoded String. All various URI components are optional, but encoded according to their respective valid character sets.
 * @param scheme the scheme
 * @param authority the authority
 * @param userInfo the user info
 * @param host the host
 * @param port the port
 * @param path the path
 * @param query the query
 * @param fragment the fragment
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}
 */
@Deprecated public static String encodeUriComponents(String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,String encoding) throws UnsupportedEncodingException {
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  StringBuilder sb=new StringBuilder();
  if (scheme != null) {
    sb.append(encodeScheme(scheme,encoding));
    sb.append(':');
  }
  if (authority != null) {
    sb.append(""//"");
    if (userInfo != null) {
      sb.append(encodeUserInfo(userInfo,encoding));
      sb.append('@');
    }
    if (host != null) {
      sb.append(encodeHost(host,encoding));
    }
    if (port != null) {
      sb.append(':');
      sb.append(encodePort(port,encoding));
    }
  }
  sb.append(encodePath(path,encoding));
  if (query != null) {
    sb.append('?');
    sb.append(encodeQuery(query,encoding));
  }
  if (fragment != null) {
    sb.append('#');
    sb.append(encodeFragment(fragment,encoding));
  }
  return sb.toString();
}
"
"/** 
 * Apply the given method invocation to the given RMI stub. <p>Delegates to the corresponding method if the RMI stub does not directly implement the invoked method. This typically happens when a non-RMI service interface is used for an RMI service. The methods of such a service interface have to match the RMI stub methods, but they typically don't declare {@code java.rmi.RemoteException}: A RemoteException thrown by the RMI stub will be automatically converted to Spring's RemoteAccessException.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object invoke(MethodInvocation invocation,Remote stub,String serviceName) throws Throwable {
  try {
    return invokeRemoteMethod(invocation,stub);
  }
 catch (  InvocationTargetException ex) {
    Throwable targetEx=ex.getTargetException();
    if (targetEx instanceof RemoteException) {
      RemoteException rex=(RemoteException)targetEx;
      throw convertRmiAccessException(invocation.getMethod(),rex,serviceName);
    }
 else {
      throw targetEx;
    }
  }
}
"
"/** 
 * Perform a raw method invocation on the given RMI stub, letting reflection exceptions through as-is.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object doInvoke(MethodInvocation invocation,Remote stub) throws InvocationTargetException {
  return invokeRemoteMethod(invocation,stub);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(String,Object)}
 */
@Deprecated public ModelMap addObject(String modelName,Object modelObject){
  return addAttribute(modelName,modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(Object)}
 */
@Deprecated public ModelMap addObject(Object modelObject){
  return addAttribute(modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Collection)}
 */
@Deprecated public ModelMap addAllObjects(Collection objects){
  return addAllAttributes(objects);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Map)}
 */
@Deprecated public ModelMap addAllObjects(Map objects){
  return addAllAttributes(objects);
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorParameter(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    this.cnManagerFactoryBean.getMediaTypes().putAll(mediaTypes);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.4.
 * @return {@code true} if the current JVM is at least Java 1.4
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_14
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava14(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.5 (Java 5).
 * @return {@code true} if the current JVM is at least Java 1.5
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava15(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.6 (Java 6).
 * @return {@code true} if the current JVM is at least Java 1.6
 * @deprecated as of Spring 3.0, in favor of reflective checks forthe specific Java 1.6 classes of interest
 * @see #getMajorJavaVersion()
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava16(){
  return (majorJavaVersion >= JAVA_16);
}
"
"/** 
 * Create a new default GenericConversionService instance that can be safely modified.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#DefaultConversionService()}
 */
@Deprecated public static GenericConversionService createDefaultConversionService(){
  return new DefaultConversionService();
}
"
"/** 
 * Populate the given GenericConversionService instance with the set of default converters.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#addDefaultConverters(ConverterRegistry)}
 */
@Deprecated public static void addDefaultConverters(GenericConversionService conversionService){
  DefaultConversionService.addDefaultConverters(conversionService);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader} and a {@link StandardEnvironment}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding property could be found
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver,boolean)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader,boolean ignoreUnresolvablePlaceholders){
  this(resourceLoader,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver){
  this(resourcePatternResolver,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding system property could be found
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver,boolean)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver,boolean ignoreUnresolvablePlaceholders){
  this(resourcePatternResolver,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Constructor for CannotGetJdbcConnectionException.
 * @param msg the detail message
 * @param ex ClassNotFoundException root cause
 * @deprecated since Spring 2.5, in favor of throwing anIllegalStateException in case of the driver not being found
 */
@Deprecated public CannotGetJdbcConnectionException(String msg,ClassNotFoundException ex){
  super(msg,ex);
}
"
"/** 
 * Add a  {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.
 * @deprecated in favor of {@link #addDeclaredRowMapper(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public void addDeclaredRowMapper(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,(RowMapper)rowMapper);
}
"
"/** 
 * @deprecated in favor of {@link #returningResultSet(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public SimpleJdbcCall returningResultSet(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,rowMapper);
  return this;
}
"
"/** 
 * Create a new DriverManagerDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @deprecated since Spring 2.5. DriverManagerDataSource is primarilyintended for accessing <i>pre-registered</i> JDBC drivers. If you need to register a new driver, consider using {@link SimpleDriverDataSource} instead.
 */
@Deprecated public DriverManagerDataSource(String driverClassName,String url,String username,String password){
  setDriverClassName(driverClassName);
  setUrl(url);
  setUsername(username);
  setPassword(password);
}
"
"/** 
 * Create a new SingleConnectionDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @param suppressClose if the returned Connection should be aclose-suppressing proxy or the physical Connection
 * @deprecated since Spring 2.5. Driver parameter usage is generally not recommendedfor a SingleConnectionDataSource. If you insist on using driver parameters directly, set up the Driver class manually before invoking this DataSource.
 * @see java.sql.DriverManager#getConnection(String,String,String)
 */
@Deprecated public SingleConnectionDataSource(String driverClassName,String url,String username,String password,boolean suppressClose){
  super(driverClassName,url,username,password);
  this.suppressClose=suppressClose;
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a List result.
 * @param action callback object that specifies the data access action
 * @return the List result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public List executeWithListResult(SqlMapClientCallback<List> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a Map result.
 * @param action callback object that specifies the data access action
 * @return the Map result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public Map executeWithMapResult(SqlMapClientCallback<Map> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Add all of the given advisors to this proxy configuration.
 * @param advisors the advisors to register
 * @deprecated as of Spring 3.0, in favor of {@link #addAdvisors}
 */
@Deprecated public void addAllAdvisors(Advisor[] advisors){
  addAdvisors(Arrays.asList(advisors));
}
"
"/** 
 * Register the given custom property editor for all properties of the given type, indicating that the given instance is a shared editor that might be used concurrently.
 * @param requiredType the type of the property
 * @param propertyEditor the shared editor to register
 * @deprecated as of Spring 3.0, in favor of PropertyEditorRegistrars or ConversionService usage
 */
@Deprecated public void registerSharedEditor(Class<?> requiredType,PropertyEditor propertyEditor){
  registerCustomEditor(requiredType,null,propertyEditor);
  if (this.sharedEditors == null) {
    this.sharedEditors=new HashSet<PropertyEditor>();
  }
  this.sharedEditors.add(propertyEditor);
}
"
"/** 
 * Override settings in this bean definition (presumably a copied parent from a parent-child inheritance relationship) from the given bean definition (presumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new ResourceEditorRegistrar for the given  {@link ResourceLoader}using a  {@link StandardEnvironment}.
 * @param resourceLoader the ResourceLoader (or ResourcePatternResolver)to create editors for (usually an ApplicationContext)
 * @see org.springframework.core.io.support.ResourcePatternResolver
 * @see org.springframework.context.ApplicationContext
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditorRegistrar(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditorRegistrar(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment());
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * @deprecated in favor of {@link #returningResultSet(String,org.springframework.jdbc.core.RowMapper)}
 */
@Override @Deprecated public SimpleJdbcCall returningResultSet(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,rowMapper);
  return this;
}
"
"/** 
 * Create a new SingleConnectionDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @param suppressClose if the returned Connection should be aclose-suppressing proxy or the physical Connection
 * @deprecated since Spring 2.5. Driver parameter usage is generally not recommendedfor a SingleConnectionDataSource. If you insist on using driver parameters directly, set up the Driver class manually before invoking this DataSource.
 * @see java.sql.DriverManager#getConnection(String,String,String)
 */
@Deprecated public SingleConnectionDataSource(String driverClassName,String url,String username,String password,boolean suppressClose){
  super(driverClassName,url,username,password);
  this.suppressClose=suppressClose;
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(org.hibernate.cache.CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a List result.
 * @param action callback object that specifies the data access action
 * @return the List result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public List executeWithListResult(SqlMapClientCallback<List> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a Map result.
 * @param action callback object that specifies the data access action
 * @return the Map result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public Map executeWithMapResult(SqlMapClientCallback<Map> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link #registerAutoProxyCreatorIfNecessary(ParserContext,Element)} and{@link AopConfigUtils#registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry,Object)}
 */
@Deprecated public static void registerAutoProxyCreatorIfNecessary(ParserContext parserContext,Object source){
  BeanDefinition beanDefinition=AopConfigUtils.registerAutoProxyCreatorIfNecessary(parserContext.getRegistry(),source);
  registerComponentIfNecessary(beanDefinition,parserContext);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link AopConfigUtils#forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry)}
 */
@Deprecated public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry){
  AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
}
"
"/** 
 * Add all of the given advisors to this proxy configuration.
 * @param advisors the advisors to register
 * @deprecated as of Spring 3.0, in favor of {@link #addAdvisors}
 */
@Deprecated public void addAllAdvisors(Advisor[] advisors){
  addAdvisors(Arrays.asList(advisors));
}
"
"/** 
 * Check whether the specified class is a CGLIB-generated class.
 * @param clazz the class to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)}
 */
@Deprecated public static boolean isCglibProxyClass(Class<?> clazz){
  return ClassUtils.isCglibProxyClass(clazz);
}
"
"/** 
 * Check whether the specified class name is a CGLIB-generated class.
 * @param className the class name to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)}
 */
@Deprecated public static boolean isCglibProxyClassName(String className){
  return ClassUtils.isCglibProxyClassName(className);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of HttpStatus.METHOD_FAILURE
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of HttpStatus.DESTINATION_LOCKED
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Register the given custom property editor for all properties of the given type, indicating that the given instance is a shared editor that might be used concurrently.
 * @param requiredType the type of the property
 * @param propertyEditor the shared editor to register
 * @deprecated as of Spring 3.0, in favor of PropertyEditorRegistrars or ConversionService usage
 */
@Deprecated public void registerSharedEditor(Class<?> requiredType,PropertyEditor propertyEditor){
  registerCustomEditor(requiredType,null,propertyEditor);
  if (this.sharedEditors == null) {
    this.sharedEditors=new HashSet<PropertyEditor>();
  }
  this.sharedEditors.add(propertyEditor);
}
"
"/** 
 * Return the ContextLoader used by this listener.
 * @return the current ContextLoader
 * @deprecated in favor of simply subclassing ContextLoaderListener itself(which extends ContextLoader, as of Spring 3.0)
 */
@Deprecated public ContextLoader getContextLoader(){
  return this.contextLoader;
}
"
"/** 
 * Override settings in this bean definition (presumably a copied parent from a parent-child inheritance relationship) from the given bean definition (presumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Set the name of the factory bean to use for this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setFactoryBean(String factoryBean,String factoryMethod){
  this.beanDefinition.setFactoryBeanName(factoryBean);
  this.beanDefinition.setFactoryMethodName(factoryMethod);
  return this;
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Set whether or not this definition describes a singleton bean, as alternative to  {@link #setScope}.
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public BeanDefinitionBuilder setSingleton(boolean singleton){
  this.beanDefinition.setSingleton(singleton);
  return this;
}
"
"/** 
 * Set the source of this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setSource(Object source){
  this.beanDefinition.setSource(source);
  return this;
}
"
"/** 
 * Set the description associated with this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setResourceDescription(String resourceDescription){
  this.beanDefinition.setResourceDescription(resourceDescription);
  return this;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
@Deprecated public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Create a new ResourceEditorRegistrar for the given  {@link ResourceLoader}using a  {@link StandardEnvironment}.
 * @param resourceLoader the ResourceLoader (or ResourcePatternResolver)to create editors for (usually an ApplicationContext)
 * @see org.springframework.core.io.support.ResourcePatternResolver
 * @see org.springframework.context.ApplicationContext
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditorRegistrar(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditorRegistrar(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment());
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorParameter(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    this.cnManagerFactoryBean.getMediaTypes().putAll(mediaTypes);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Set a List of  {@code TemplateLoader}s that will be used to search for templates. For example, one or more custom loaders such as database loaders could be configured and injected here.
 * @deprecated as of Spring 2.0.1, in favor of the ""preTemplateLoaders""and ""postTemplateLoaders"" properties
 * @see #setPreTemplateLoaders
 * @see #setPostTemplateLoaders
 */
@Deprecated public void setTemplateLoaders(TemplateLoader[] templateLoaders){
  if (templateLoaders != null) {
    this.templateLoaders.addAll(Arrays.asList(templateLoaders));
  }
}
"
"/** 
 * Set the registration behavior by the name of the corresponding constant, e.g. ""REGISTRATION_IGNORE_EXISTING"".
 * @see #setRegistrationBehavior
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehaviorName(String registrationBehavior){
  setRegistrationBehavior(constants.asNumber(registrationBehavior).intValue());
}
"
"/** 
 * Specify what action should be taken when attempting to register an MBean under an  {@link javax.management.ObjectName} that already exists.<p>Default is REGISTRATION_FAIL_ON_EXISTING.
 * @see #setRegistrationBehaviorName(String)
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehavior(int registrationBehavior){
  setRegistrationPolicy(RegistrationPolicy.valueOf(registrationBehavior));
}
"
"/** 
 * Apply the given method invocation to the given RMI stub. <p>Delegates to the corresponding method if the RMI stub does not directly implement the invoked method. This typically happens when a non-RMI service interface is used for an RMI service. The methods of such a service interface have to match the RMI stub methods, but they typically don't declare {@code java.rmi.RemoteException}: A RemoteException thrown by the RMI stub will be automatically converted to Spring's RemoteAccessException.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object invoke(MethodInvocation invocation,Remote stub,String serviceName) throws Throwable {
  try {
    return invokeRemoteMethod(invocation,stub);
  }
 catch (  InvocationTargetException ex) {
    Throwable targetEx=ex.getTargetException();
    if (targetEx instanceof RemoteException) {
      RemoteException rex=(RemoteException)targetEx;
      throw convertRmiAccessException(invocation.getMethod(),rex,serviceName);
    }
 else {
      throw targetEx;
    }
  }
}
"
"/** 
 * Perform a raw method invocation on the given RMI stub, letting reflection exceptions through as-is.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object doInvoke(MethodInvocation invocation,Remote stub) throws InvocationTargetException {
  return invokeRemoteMethod(invocation,stub);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(String,Object)}
 */
@Deprecated public ModelMap addObject(String modelName,Object modelObject){
  return addAttribute(modelName,modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(Object)}
 */
@Deprecated public ModelMap addObject(Object modelObject){
  return addAttribute(modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Collection)}
 */
@Deprecated public ModelMap addAllObjects(Collection objects){
  return addAllAttributes(objects);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Map)}
 */
@Deprecated public ModelMap addAllObjects(Map objects){
  return addAllAttributes(objects);
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link #registerAutoProxyCreatorIfNecessary(ParserContext,Element)} and{@link AopConfigUtils#registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry,Object)}
 */
@Deprecated public static void registerAutoProxyCreatorIfNecessary(ParserContext parserContext,Object source){
  BeanDefinition beanDefinition=AopConfigUtils.registerAutoProxyCreatorIfNecessary(parserContext.getRegistry(),source);
  registerComponentIfNecessary(beanDefinition,parserContext);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link AopConfigUtils#forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry)}
 */
@Deprecated public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry){
  AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
}
"
"/** 
 * Add all of the given advisors to this proxy configuration.
 * @param advisors the advisors to register
 * @deprecated as of Spring 3.0, in favor of {@link #addAdvisors}
 */
@Deprecated public void addAllAdvisors(Advisor[] advisors){
  addAdvisors(Arrays.asList(advisors));
}
"
"/** 
 * Check whether the specified class is a CGLIB-generated class.
 * @param clazz the class to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)}
 */
@Deprecated public static boolean isCglibProxyClass(Class<?> clazz){
  return ClassUtils.isCglibProxyClass(clazz);
}
"
"/** 
 * Check whether the specified class name is a CGLIB-generated class.
 * @param className the class name to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)}
 */
@Deprecated public static boolean isCglibProxyClassName(String className){
  return ClassUtils.isCglibProxyClassName(className);
}
"
"/** 
 * Add all of the given advisors to this proxy configuration.
 * @param advisors the advisors to register
 * @deprecated as of Spring 3.0, in favor of {@link #addAdvisors}
 */
@Deprecated public void addAllAdvisors(Advisor[] advisors){
  addAdvisors(Arrays.asList(advisors));
}
"
"/** 
 * Register the given custom property editor for all properties of the given type, indicating that the given instance is a shared editor that might be used concurrently.
 * @param requiredType the type of the property
 * @param propertyEditor the shared editor to register
 * @deprecated as of Spring 3.0, in favor of PropertyEditorRegistrars or ConversionService usage
 */
@Deprecated public void registerSharedEditor(Class<?> requiredType,PropertyEditor propertyEditor){
  registerCustomEditor(requiredType,null,propertyEditor);
  if (this.sharedEditors == null) {
    this.sharedEditors=new HashSet<PropertyEditor>();
  }
  this.sharedEditors.add(propertyEditor);
}
"
"/** 
 * Register the given custom property editor for all properties of the given type, indicating that the given instance is a shared editor that might be used concurrently.
 * @param requiredType the type of the property
 * @param propertyEditor the shared editor to register
 * @deprecated as of Spring 3.0, in favor of PropertyEditorRegistrars or ConversionService usage
 */
@Deprecated public void registerSharedEditor(Class<?> requiredType,PropertyEditor propertyEditor){
  registerCustomEditor(requiredType,null,propertyEditor);
  if (this.sharedEditors == null) {
    this.sharedEditors=new HashSet<PropertyEditor>();
  }
  this.sharedEditors.add(propertyEditor);
}
"
"/** 
 * Override settings in this bean definition (presumably a copied parent from a parent-child inheritance relationship) from the given bean definition (presumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Set the name of the factory bean to use for this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setFactoryBean(String factoryBean,String factoryMethod){
  this.beanDefinition.setFactoryBeanName(factoryBean);
  this.beanDefinition.setFactoryMethodName(factoryMethod);
  return this;
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Set whether or not this definition describes a singleton bean, as alternative to  {@link #setScope}.
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public BeanDefinitionBuilder setSingleton(boolean singleton){
  this.beanDefinition.setSingleton(singleton);
  return this;
}
"
"/** 
 * Set the source of this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setSource(Object source){
  this.beanDefinition.setSource(source);
  return this;
}
"
"/** 
 * Set the description associated with this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setResourceDescription(String resourceDescription){
  this.beanDefinition.setResourceDescription(resourceDescription);
  return this;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.4.
 * @return {@code true} if the current JVM is at least Java 1.4
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_14
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava14(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.5 (Java 5).
 * @return {@code true} if the current JVM is at least Java 1.5
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava15(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.6 (Java 6).
 * @return {@code true} if the current JVM is at least Java 1.6
 * @deprecated as of Spring 3.0, in favor of reflective checks forthe specific Java 1.6 classes of interest
 * @see #getMajorJavaVersion()
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava16(){
  return (majorJavaVersion >= JAVA_16);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Override settings in this bean definition (presumably a copied parent from a parent-child inheritance relationship) from the given bean definition (presumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
@Deprecated public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Create a new default GenericConversionService instance that can be safely modified.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#DefaultConversionService()}
 */
@Deprecated public static GenericConversionService createDefaultConversionService(){
  return new DefaultConversionService();
}
"
"/** 
 * Populate the given GenericConversionService instance with the set of default converters.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#addDefaultConverters(ConverterRegistry)}
 */
@Deprecated public static void addDefaultConverters(GenericConversionService conversionService){
  DefaultConversionService.addDefaultConverters(conversionService);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader} and a {@link StandardEnvironment}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding property could be found
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver,boolean)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader,boolean ignoreUnresolvablePlaceholders){
  this(resourceLoader,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Create a new ResourceEditorRegistrar for the given  {@link ResourceLoader}using a  {@link StandardEnvironment}.
 * @param resourceLoader the ResourceLoader (or ResourcePatternResolver)to create editors for (usually an ApplicationContext)
 * @see org.springframework.core.io.support.ResourcePatternResolver
 * @see org.springframework.context.ApplicationContext
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditorRegistrar(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditorRegistrar(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment());
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver){
  this(resourcePatternResolver,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding system property could be found
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver,boolean)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver,boolean ignoreUnresolvablePlaceholders){
  this(resourcePatternResolver,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Create a new ResourceEditorRegistrar for the given  {@link ResourceLoader}using a  {@link StandardEnvironment}.
 * @param resourceLoader the ResourceLoader (or ResourcePatternResolver)to create editors for (usually an ApplicationContext)
 * @see org.springframework.core.io.support.ResourcePatternResolver
 * @see org.springframework.context.ApplicationContext
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditorRegistrar(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditorRegistrar(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment());
}
"
"/** 
 * Replacement for  {@code Class.forName()} that also returns Class instancesfor primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return  {@code false} if either the class orone of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Set a List of  {@code TemplateLoader}s that will be used to search for templates. For example, one or more custom loaders such as database loaders could be configured and injected here.
 * @deprecated as of Spring 2.0.1, in favor of the ""preTemplateLoaders""and ""postTemplateLoaders"" properties
 * @see #setPreTemplateLoaders
 * @see #setPostTemplateLoaders
 */
@Deprecated public void setTemplateLoaders(TemplateLoader[] templateLoaders){
  if (templateLoaders != null) {
    this.templateLoaders.addAll(Arrays.asList(templateLoaders));
  }
}
"
"/** 
 * Set the registration behavior by the name of the corresponding constant, e.g. ""REGISTRATION_IGNORE_EXISTING"".
 * @see #setRegistrationBehavior
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehaviorName(String registrationBehavior){
  setRegistrationBehavior(constants.asNumber(registrationBehavior).intValue());
}
"
"/** 
 * Specify what action should be taken when attempting to register an MBean under an  {@link javax.management.ObjectName} that already exists.<p>Default is REGISTRATION_FAIL_ON_EXISTING.
 * @see #setRegistrationBehaviorName(String)
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehavior(int registrationBehavior){
  setRegistrationPolicy(RegistrationPolicy.valueOf(registrationBehavior));
}
"
"/** 
 * Apply the given method invocation to the given RMI stub. <p>Delegates to the corresponding method if the RMI stub does not directly implement the invoked method. This typically happens when a non-RMI service interface is used for an RMI service. The methods of such a service interface have to match the RMI stub methods, but they typically don't declare {@code java.rmi.RemoteException}: A RemoteException thrown by the RMI stub will be automatically converted to Spring's RemoteAccessException.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object invoke(MethodInvocation invocation,Remote stub,String serviceName) throws Throwable {
  try {
    return invokeRemoteMethod(invocation,stub);
  }
 catch (  InvocationTargetException ex) {
    Throwable targetEx=ex.getTargetException();
    if (targetEx instanceof RemoteException) {
      RemoteException rex=(RemoteException)targetEx;
      throw convertRmiAccessException(invocation.getMethod(),rex,serviceName);
    }
 else {
      throw targetEx;
    }
  }
}
"
"/** 
 * Perform a raw method invocation on the given RMI stub, letting reflection exceptions through as-is.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object doInvoke(MethodInvocation invocation,Remote stub) throws InvocationTargetException {
  return invokeRemoteMethod(invocation,stub);
}
"
"/** 
 * Constructor for CannotGetJdbcConnectionException.
 * @param msg the detail message
 * @param ex ClassNotFoundException root cause
 * @deprecated since Spring 2.5, in favor of throwing anIllegalStateException in case of the driver not being found
 */
@Deprecated public CannotGetJdbcConnectionException(String msg,ClassNotFoundException ex){
  super(msg,ex);
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
@Deprecated public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Add a  {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.
 * @deprecated in favor of {@link #addDeclaredRowMapper(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public void addDeclaredRowMapper(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,(RowMapper)rowMapper);
}
"
"/** 
 * @deprecated in favor of {@link #returningResultSet(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public SimpleJdbcCall returningResultSet(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,rowMapper);
  return this;
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(String,Object)}
 */
@Deprecated public ModelMap addObject(String modelName,Object modelObject){
  return addAttribute(modelName,modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(Object)}
 */
@Deprecated public ModelMap addObject(Object modelObject){
  return addAttribute(modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Collection)}
 */
@Deprecated public ModelMap addAllObjects(Collection objects){
  return addAllAttributes(objects);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Map)}
 */
@Deprecated public ModelMap addAllObjects(Map objects){
  return addAllAttributes(objects);
}
"
"/** 
 * Create a new DriverManagerDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @deprecated since Spring 2.5. DriverManagerDataSource is primarilyintended for accessing <i>pre-registered</i> JDBC drivers. If you need to register a new driver, consider using {@link SimpleDriverDataSource} instead.
 */
@Deprecated public DriverManagerDataSource(String driverClassName,String url,String username,String password){
  setDriverClassName(driverClassName);
  setUrl(url);
  setUsername(username);
  setPassword(password);
}
"
"/** 
 * Create a new SingleConnectionDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @param suppressClose if the returned Connection should be aclose-suppressing proxy or the physical Connection
 * @deprecated since Spring 2.5. Driver parameter usage is generally not recommendedfor a SingleConnectionDataSource. If you insist on using driver parameters directly, set up the Driver class manually before invoking this DataSource.
 * @see java.sql.DriverManager#getConnection(String,String,String)
 */
@Deprecated public SingleConnectionDataSource(String driverClassName,String url,String username,String password,boolean suppressClose){
  super(driverClassName,url,username,password);
  this.suppressClose=suppressClose;
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * @deprecated in favor of {@link #returningResultSet(String,org.springframework.jdbc.core.RowMapper)}
 */
@Override @Deprecated public SimpleJdbcCall returningResultSet(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,rowMapper);
  return this;
}
"
"/** 
 * Create a new SingleConnectionDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @param suppressClose if the returned Connection should be aclose-suppressing proxy or the physical Connection
 * @deprecated since Spring 2.5. Driver parameter usage is generally not recommendedfor a SingleConnectionDataSource. If you insist on using driver parameters directly, set up the Driver class manually before invoking this DataSource.
 * @see java.sql.DriverManager#getConnection(String,String,String)
 */
@Deprecated public SingleConnectionDataSource(String driverClassName,String url,String username,String password,boolean suppressClose){
  super(driverClassName,url,username,password);
  this.suppressClose=suppressClose;
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.4.
 * @return {@code true} if the current JVM is at least Java 1.4
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_14
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava14(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.5 (Java 5).
 * @return {@code true} if the current JVM is at least Java 1.5
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava15(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.6 (Java 6).
 * @return {@code true} if the current JVM is at least Java 1.6
 * @deprecated as of Spring 3.0, in favor of reflective checks forthe specific Java 1.6 classes of interest
 * @see #getMajorJavaVersion()
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava16(){
  return (majorJavaVersion >= JAVA_16);
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Create a new default GenericConversionService instance that can be safely modified.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#DefaultConversionService()}
 */
@Deprecated public static GenericConversionService createDefaultConversionService(){
  return new DefaultConversionService();
}
"
"/** 
 * Populate the given GenericConversionService instance with the set of default converters.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#addDefaultConverters(ConverterRegistry)}
 */
@Deprecated public static void addDefaultConverters(GenericConversionService conversionService){
  DefaultConversionService.addDefaultConverters(conversionService);
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(org.hibernate.cache.CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(org.hibernate.cache.CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a List result.
 * @param action callback object that specifies the data access action
 * @return the List result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public List executeWithListResult(SqlMapClientCallback<List> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a Map result.
 * @param action callback object that specifies the data access action
 * @return the Map result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public Map executeWithMapResult(SqlMapClientCallback<Map> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader} and a {@link StandardEnvironment}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding property could be found
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver,boolean)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader,boolean ignoreUnresolvablePlaceholders){
  this(resourceLoader,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver){
  this(resourcePatternResolver,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding system property could be found
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver,boolean)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver,boolean ignoreUnresolvablePlaceholders){
  this(resourcePatternResolver,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a List result.
 * @param action callback object that specifies the data access action
 * @return the List result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public List executeWithListResult(SqlMapClientCallback<List> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a Map result.
 * @param action callback object that specifies the data access action
 * @return the Map result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public Map executeWithMapResult(SqlMapClientCallback<Map> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Replacement for  {@code Class.forName()} that also returns Class instancesfor primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return  {@code false} if either the class orone of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of HttpStatus.METHOD_FAILURE
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of HttpStatus.DESTINATION_LOCKED
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Constructor for CannotGetJdbcConnectionException.
 * @param msg the detail message
 * @param ex ClassNotFoundException root cause
 * @deprecated since Spring 2.5, in favor of throwing anIllegalStateException in case of the driver not being found
 */
@Deprecated public CannotGetJdbcConnectionException(String msg,ClassNotFoundException ex){
  super(msg,ex);
}
"
"/** 
 * Add a  {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.
 * @deprecated in favor of {@link #addDeclaredRowMapper(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public void addDeclaredRowMapper(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,(RowMapper)rowMapper);
}
"
"/** 
 * @deprecated in favor of {@link #returningResultSet(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public SimpleJdbcCall returningResultSet(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,rowMapper);
  return this;
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of HttpStatus.METHOD_FAILURE
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of HttpStatus.DESTINATION_LOCKED
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Create a new DriverManagerDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @deprecated since Spring 2.5. DriverManagerDataSource is primarilyintended for accessing <i>pre-registered</i> JDBC drivers. If you need to register a new driver, consider using {@link SimpleDriverDataSource} instead.
 */
@Deprecated public DriverManagerDataSource(String driverClassName,String url,String username,String password){
  setDriverClassName(driverClassName);
  setUrl(url);
  setUsername(username);
  setPassword(password);
}
"
"/** 
 * Create a new SingleConnectionDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @param suppressClose if the returned Connection should be aclose-suppressing proxy or the physical Connection
 * @deprecated since Spring 2.5. Driver parameter usage is generally not recommendedfor a SingleConnectionDataSource. If you insist on using driver parameters directly, set up the Driver class manually before invoking this DataSource.
 * @see java.sql.DriverManager#getConnection(String,String,String)
 */
@Deprecated public SingleConnectionDataSource(String driverClassName,String url,String username,String password,boolean suppressClose){
  super(driverClassName,url,username,password);
  this.suppressClose=suppressClose;
}
"
"/** 
 * Return the ContextLoader used by this listener.
 * @return the current ContextLoader
 * @deprecated in favor of simply subclassing ContextLoaderListener itself(which extends ContextLoader, as of Spring 3.0)
 */
@Deprecated public ContextLoader getContextLoader(){
  return this.contextLoader;
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param beanFactory the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.1.2 in favor of{@link BeanFactoryAnnotationUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
@Deprecated public static PlatformTransactionManager getTransactionManager(BeanFactory beanFactory,String qualifier){
  return BeanFactoryAnnotationUtils.qualifiedBeanOfType(beanFactory,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param bf the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.1.2 in favor of{@link BeanFactoryAnnotationUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
@Deprecated public static PlatformTransactionManager getTransactionManager(ConfigurableListableBeanFactory bf,String qualifier){
  return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(org.hibernate.cache.CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a List result.
 * @param action callback object that specifies the data access action
 * @return the List result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public List executeWithListResult(SqlMapClientCallback<List> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a Map result.
 * @param action callback object that specifies the data access action
 * @return the Map result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public Map executeWithMapResult(SqlMapClientCallback<Map> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorParameter(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    this.cnManagerFactoryBean.getMediaTypes().putAll(mediaTypes);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Return the ContextLoader used by this listener.
 * @return the current ContextLoader
 * @deprecated in favor of simply subclassing ContextLoaderListener itself(which extends ContextLoader, as of Spring 3.0)
 */
@Deprecated public ContextLoader getContextLoader(){
  return this.contextLoader;
}
"
"/** 
 * Encodes the given source URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromUri(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param uri the URI to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeUri(String uri,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(uri,""'uri' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=URI_PATTERN.matcher(uri);
  if (m.matches()) {
    String scheme=m.group(2);
    String authority=m.group(3);
    String userinfo=m.group(5);
    String host=m.group(6);
    String port=m.group(8);
    String path=m.group(9);
    String query=m.group(11);
    String fragment=m.group(13);
    return encodeUriComponents(scheme,authority,userinfo,host,port,path,query,fragment,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + uri + ""] is not a valid URI"");
  }
}
"
"/** 
 * Encodes the given HTTP URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not support fragments ( {@code #}), as these are not supposed to be sent to the server, but retained by the client. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param httpUrl the HTTP URL to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URL
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeHttpUrl(String httpUrl,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(httpUrl,""'httpUrl' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=HTTP_URL_PATTERN.matcher(httpUrl);
  if (m.matches()) {
    String scheme=m.group(1);
    String authority=m.group(2);
    String userinfo=m.group(4);
    String host=m.group(5);
    String portString=m.group(7);
    String path=m.group(8);
    String query=m.group(10);
    return encodeUriComponents(scheme,authority,userinfo,host,portString,path,query,null,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + httpUrl + ""] is not a valid HTTP URL"");
  }
}
"
"/** 
 * Encodes the given source URI components into an encoded String. All various URI components are optional, but encoded according to their respective valid character sets.
 * @param scheme the scheme
 * @param authority the authority
 * @param userInfo the user info
 * @param host the host
 * @param port the port
 * @param path the path
 * @param query the query
 * @param fragment the fragment
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}
 */
@Deprecated public static String encodeUriComponents(String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,String encoding) throws UnsupportedEncodingException {
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  StringBuilder sb=new StringBuilder();
  if (scheme != null) {
    sb.append(encodeScheme(scheme,encoding));
    sb.append(':');
  }
  if (authority != null) {
    sb.append(""//"");
    if (userInfo != null) {
      sb.append(encodeUserInfo(userInfo,encoding));
      sb.append('@');
    }
    if (host != null) {
      sb.append(encodeHost(host,encoding));
    }
    if (port != null) {
      sb.append(':');
      sb.append(encodePort(port,encoding));
    }
  }
  sb.append(encodePath(path,encoding));
  if (query != null) {
    sb.append('?');
    sb.append(encodeQuery(query,encoding));
  }
  if (fragment != null) {
    sb.append('#');
    sb.append(encodeFragment(fragment,encoding));
  }
  return sb.toString();
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of HttpStatus.METHOD_FAILURE
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of HttpStatus.DESTINATION_LOCKED
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param beanFactory the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.1.2 in favor of{@link BeanFactoryAnnotationUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
@Deprecated public static PlatformTransactionManager getTransactionManager(BeanFactory beanFactory,String qualifier){
  return BeanFactoryAnnotationUtils.qualifiedBeanOfType(beanFactory,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param bf the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.1.2 in favor of{@link BeanFactoryAnnotationUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
@Deprecated public static PlatformTransactionManager getTransactionManager(ConfigurableListableBeanFactory bf,String qualifier){
  return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorParameter(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    this.cnManagerFactoryBean.getMediaTypes().putAll(mediaTypes);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Return the ContextLoader used by this listener.
 * @return the current ContextLoader
 * @deprecated in favor of simply subclassing ContextLoaderListener itself(which extends ContextLoader, as of Spring 3.0)
 */
@Deprecated public ContextLoader getContextLoader(){
  return this.contextLoader;
}
"
"/** 
 * Encodes the given source URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromUri(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param uri the URI to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeUri(String uri,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(uri,""'uri' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=URI_PATTERN.matcher(uri);
  if (m.matches()) {
    String scheme=m.group(2);
    String authority=m.group(3);
    String userinfo=m.group(5);
    String host=m.group(6);
    String port=m.group(8);
    String path=m.group(9);
    String query=m.group(11);
    String fragment=m.group(13);
    return encodeUriComponents(scheme,authority,userinfo,host,port,path,query,fragment,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + uri + ""] is not a valid URI"");
  }
}
"
"/** 
 * Encodes the given HTTP URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not support fragments ( {@code #}), as these are not supposed to be sent to the server, but retained by the client. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param httpUrl the HTTP URL to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URL
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeHttpUrl(String httpUrl,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(httpUrl,""'httpUrl' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=HTTP_URL_PATTERN.matcher(httpUrl);
  if (m.matches()) {
    String scheme=m.group(1);
    String authority=m.group(2);
    String userinfo=m.group(4);
    String host=m.group(5);
    String portString=m.group(7);
    String path=m.group(8);
    String query=m.group(10);
    return encodeUriComponents(scheme,authority,userinfo,host,portString,path,query,null,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + httpUrl + ""] is not a valid HTTP URL"");
  }
}
"
"/** 
 * Encodes the given source URI components into an encoded String. All various URI components are optional, but encoded according to their respective valid character sets.
 * @param scheme the scheme
 * @param authority the authority
 * @param userInfo the user info
 * @param host the host
 * @param port the port
 * @param path the path
 * @param query the query
 * @param fragment the fragment
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}
 */
@Deprecated public static String encodeUriComponents(String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,String encoding) throws UnsupportedEncodingException {
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  StringBuilder sb=new StringBuilder();
  if (scheme != null) {
    sb.append(encodeScheme(scheme,encoding));
    sb.append(':');
  }
  if (authority != null) {
    sb.append(""//"");
    if (userInfo != null) {
      sb.append(encodeUserInfo(userInfo,encoding));
      sb.append('@');
    }
    if (host != null) {
      sb.append(encodeHost(host,encoding));
    }
    if (port != null) {
      sb.append(':');
      sb.append(encodePort(port,encoding));
    }
  }
  sb.append(encodePath(path,encoding));
  if (query != null) {
    sb.append('?');
    sb.append(encodeQuery(query,encoding));
  }
  if (fragment != null) {
    sb.append('#');
    sb.append(encodeFragment(fragment,encoding));
  }
  return sb.toString();
}
"
"/** 
 * Add all of the given advisors to this proxy configuration.
 * @param advisors the advisors to register
 * @deprecated as of Spring 3.0, in favor of {@link #addAdvisors}
 */
@Deprecated public void addAllAdvisors(Advisor[] advisors){
  addAdvisors(Arrays.asList(advisors));
}
"
"/** 
 * Register the given custom property editor for all properties of the given type, indicating that the given instance is a shared editor that might be used concurrently.
 * @param requiredType the type of the property
 * @param propertyEditor the shared editor to register
 * @deprecated as of Spring 3.0, in favor of PropertyEditorRegistrars or ConversionService usage
 */
@Deprecated public void registerSharedEditor(Class<?> requiredType,PropertyEditor propertyEditor){
  registerCustomEditor(requiredType,null,propertyEditor);
  if (this.sharedEditors == null) {
    this.sharedEditors=new HashSet<PropertyEditor>();
  }
  this.sharedEditors.add(propertyEditor);
}
"
"/** 
 * Override settings in this bean definition (presumably a copied parent from a parent-child inheritance relationship) from the given bean definition (presumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new ResourceEditorRegistrar for the given  {@link ResourceLoader}using a  {@link StandardEnvironment}.
 * @param resourceLoader the ResourceLoader (or ResourcePatternResolver)to create editors for (usually an ApplicationContext)
 * @see org.springframework.core.io.support.ResourcePatternResolver
 * @see org.springframework.context.ApplicationContext
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditorRegistrar(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditorRegistrar(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment());
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
@Deprecated public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorParameter(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    this.cnManagerFactoryBean.getMediaTypes().putAll(mediaTypes);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * @deprecated in favor of {@link #returningResultSet(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public SimpleJdbcCall returningResultSet(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,rowMapper);
  return this;
}
"
"/** 
 * Create a new SingleConnectionDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @param suppressClose if the returned Connection should be aclose-suppressing proxy or the physical Connection
 * @deprecated since Spring 2.5. Driver parameter usage is generally not recommendedfor a SingleConnectionDataSource. If you insist on using driver parameters directly, set up the Driver class manually before invoking this DataSource.
 * @see java.sql.DriverManager#getConnection(String,String,String)
 */
@Deprecated public SingleConnectionDataSource(String driverClassName,String url,String username,String password,boolean suppressClose){
  super(driverClassName,url,username,password);
  this.suppressClose=suppressClose;
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(org.hibernate.cache.CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a List result.
 * @param action callback object that specifies the data access action
 * @return the List result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public List executeWithListResult(SqlMapClientCallback<List> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a Map result.
 * @param action callback object that specifies the data access action
 * @return the Map result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public Map executeWithMapResult(SqlMapClientCallback<Map> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of HttpStatus.METHOD_FAILURE
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of HttpStatus.DESTINATION_LOCKED
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Return the ContextLoader used by this listener.
 * @return the current ContextLoader
 * @deprecated in favor of simply subclassing ContextLoaderListener itself(which extends ContextLoader, as of Spring 3.0)
 */
@Deprecated public ContextLoader getContextLoader(){
  return this.contextLoader;
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link #registerAutoProxyCreatorIfNecessary(ParserContext,Element)} and{@link AopConfigUtils#registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry,Object)}
 */
@Deprecated public static void registerAutoProxyCreatorIfNecessary(ParserContext parserContext,Object source){
  BeanDefinition beanDefinition=AopConfigUtils.registerAutoProxyCreatorIfNecessary(parserContext.getRegistry(),source);
  registerComponentIfNecessary(beanDefinition,parserContext);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link AopConfigUtils#forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry)}
 */
@Deprecated public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry){
  AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
}
"
"/** 
 * Add all of the given advisors to this proxy configuration.
 * @param advisors the advisors to register
 * @deprecated as of Spring 3.0, in favor of {@link #addAdvisors}
 */
@Deprecated public void addAllAdvisors(Advisor[] advisors){
  addAdvisors(Arrays.asList(advisors));
}
"
"/** 
 * Check whether the specified class is a CGLIB-generated class.
 * @param clazz the class to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)}
 */
@Deprecated public static boolean isCglibProxyClass(Class<?> clazz){
  return ClassUtils.isCglibProxyClass(clazz);
}
"
"/** 
 * Check whether the specified class name is a CGLIB-generated class.
 * @param className the class name to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)}
 */
@Deprecated public static boolean isCglibProxyClassName(String className){
  return ClassUtils.isCglibProxyClassName(className);
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorParameter(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    this.cnManagerFactoryBean.getMediaTypes().putAll(mediaTypes);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorParameter(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    Properties props=new Properties();
    props.putAll(mediaTypes);
    this.cnManagerFactoryBean.setMediaTypes(props);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Register the given custom property editor for all properties of the given type, indicating that the given instance is a shared editor that might be used concurrently.
 * @param requiredType the type of the property
 * @param propertyEditor the shared editor to register
 * @deprecated as of Spring 3.0, in favor of PropertyEditorRegistrars or ConversionService usage
 */
@Deprecated public void registerSharedEditor(Class<?> requiredType,PropertyEditor propertyEditor){
  registerCustomEditor(requiredType,null,propertyEditor);
  if (this.sharedEditors == null) {
    this.sharedEditors=new HashSet<PropertyEditor>();
  }
  this.sharedEditors.add(propertyEditor);
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
@Deprecated public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Override settings in this bean definition (presumably a copied parent from a parent-child inheritance relationship) from the given bean definition (presumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Set the name of the factory bean to use for this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setFactoryBean(String factoryBean,String factoryMethod){
  this.beanDefinition.setFactoryBeanName(factoryBean);
  this.beanDefinition.setFactoryMethodName(factoryMethod);
  return this;
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Set whether or not this definition describes a singleton bean, as alternative to  {@link #setScope}.
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public BeanDefinitionBuilder setSingleton(boolean singleton){
  this.beanDefinition.setSingleton(singleton);
  return this;
}
"
"/** 
 * Set the source of this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setSource(Object source){
  this.beanDefinition.setSource(source);
  return this;
}
"
"/** 
 * Set the description associated with this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setResourceDescription(String resourceDescription){
  this.beanDefinition.setResourceDescription(resourceDescription);
  return this;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
@Deprecated public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Create a new ResourceEditorRegistrar for the given  {@link ResourceLoader}using a  {@link StandardEnvironment}.
 * @param resourceLoader the ResourceLoader (or ResourcePatternResolver)to create editors for (usually an ApplicationContext)
 * @see org.springframework.core.io.support.ResourcePatternResolver
 * @see org.springframework.context.ApplicationContext
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditorRegistrar(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditorRegistrar(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment());
}
"
"/** 
 * Set a List of  {@code TemplateLoader}s that will be used to search for templates. For example, one or more custom loaders such as database loaders could be configured and injected here.
 * @deprecated as of Spring 2.0.1, in favor of the ""preTemplateLoaders""and ""postTemplateLoaders"" properties
 * @see #setPreTemplateLoaders
 * @see #setPostTemplateLoaders
 */
@Deprecated public void setTemplateLoaders(TemplateLoader[] templateLoaders){
  if (templateLoaders != null) {
    this.templateLoaders.addAll(Arrays.asList(templateLoaders));
  }
}
"
"/** 
 * Set the registration behavior by the name of the corresponding constant, e.g. ""REGISTRATION_IGNORE_EXISTING"".
 * @see #setRegistrationBehavior
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehaviorName(String registrationBehavior){
  setRegistrationBehavior(constants.asNumber(registrationBehavior).intValue());
}
"
"/** 
 * Specify what action should be taken when attempting to register an MBean under an  {@link javax.management.ObjectName} that already exists.<p>Default is REGISTRATION_FAIL_ON_EXISTING.
 * @see #setRegistrationBehaviorName(String)
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehavior(int registrationBehavior){
  setRegistrationPolicy(RegistrationPolicy.valueOf(registrationBehavior));
}
"
"/** 
 * Apply the given method invocation to the given RMI stub. <p>Delegates to the corresponding method if the RMI stub does not directly implement the invoked method. This typically happens when a non-RMI service interface is used for an RMI service. The methods of such a service interface have to match the RMI stub methods, but they typically don't declare {@code java.rmi.RemoteException}: A RemoteException thrown by the RMI stub will be automatically converted to Spring's RemoteAccessException.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object invoke(MethodInvocation invocation,Remote stub,String serviceName) throws Throwable {
  try {
    return invokeRemoteMethod(invocation,stub);
  }
 catch (  InvocationTargetException ex) {
    Throwable targetEx=ex.getTargetException();
    if (targetEx instanceof RemoteException) {
      RemoteException rex=(RemoteException)targetEx;
      throw convertRmiAccessException(invocation.getMethod(),rex,serviceName);
    }
 else {
      throw targetEx;
    }
  }
}
"
"/** 
 * Perform a raw method invocation on the given RMI stub, letting reflection exceptions through as-is.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object doInvoke(MethodInvocation invocation,Remote stub) throws InvocationTargetException {
  return invokeRemoteMethod(invocation,stub);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link #registerAutoProxyCreatorIfNecessary(ParserContext,Element)} and{@link AopConfigUtils#registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry,Object)}
 */
@Deprecated public static void registerAutoProxyCreatorIfNecessary(ParserContext parserContext,Object source){
  BeanDefinition beanDefinition=AopConfigUtils.registerAutoProxyCreatorIfNecessary(parserContext.getRegistry(),source);
  registerComponentIfNecessary(beanDefinition,parserContext);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link AopConfigUtils#forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry)}
 */
@Deprecated public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry){
  AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
}
"
"/** 
 * Add all of the given advisors to this proxy configuration.
 * @param advisors the advisors to register
 * @deprecated as of Spring 3.0, in favor of {@link #addAdvisors}
 */
@Deprecated public void addAllAdvisors(Advisor[] advisors){
  addAdvisors(Arrays.asList(advisors));
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(String,Object)}
 */
@Deprecated public ModelMap addObject(String modelName,Object modelObject){
  return addAttribute(modelName,modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(Object)}
 */
@Deprecated public ModelMap addObject(Object modelObject){
  return addAttribute(modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Collection)}
 */
@Deprecated public ModelMap addAllObjects(Collection objects){
  return addAllAttributes(objects);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Map)}
 */
@Deprecated public ModelMap addAllObjects(Map objects){
  return addAllAttributes(objects);
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorParameter(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    Properties props=new Properties();
    props.putAll(mediaTypes);
    this.cnManagerFactoryBean.setMediaTypes(props);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Register the given custom property editor for all properties of the given type, indicating that the given instance is a shared editor that might be used concurrently.
 * @param requiredType the type of the property
 * @param propertyEditor the shared editor to register
 * @deprecated as of Spring 3.0, in favor of PropertyEditorRegistrars or ConversionService usage
 */
@Deprecated public void registerSharedEditor(Class<?> requiredType,PropertyEditor propertyEditor){
  registerCustomEditor(requiredType,null,propertyEditor);
  if (this.sharedEditors == null) {
    this.sharedEditors=new HashSet<PropertyEditor>();
  }
  this.sharedEditors.add(propertyEditor);
}
"
"/** 
 * Set the name of the factory bean to use for this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setFactoryBean(String factoryBean,String factoryMethod){
  this.beanDefinition.setFactoryBeanName(factoryBean);
  this.beanDefinition.setFactoryMethodName(factoryMethod);
  return this;
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Set whether or not this definition describes a singleton bean, as alternative to  {@link #setScope}.
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public BeanDefinitionBuilder setSingleton(boolean singleton){
  this.beanDefinition.setSingleton(singleton);
  return this;
}
"
"/** 
 * Set the source of this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setSource(Object source){
  this.beanDefinition.setSource(source);
  return this;
}
"
"/** 
 * Set the description associated with this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setResourceDescription(String resourceDescription){
  this.beanDefinition.setResourceDescription(resourceDescription);
  return this;
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
@Deprecated public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.4.
 * @return {@code true} if the current JVM is at least Java 1.4
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_14
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava14(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.5 (Java 5).
 * @return {@code true} if the current JVM is at least Java 1.5
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava15(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.6 (Java 6).
 * @return {@code true} if the current JVM is at least Java 1.6
 * @deprecated as of Spring 3.0, in favor of reflective checks forthe specific Java 1.6 classes of interest
 * @see #getMajorJavaVersion()
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava16(){
  return (majorJavaVersion >= JAVA_16);
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Create a new default GenericConversionService instance that can be safely modified.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#DefaultConversionService()}
 */
@Deprecated public static GenericConversionService createDefaultConversionService(){
  return new DefaultConversionService();
}
"
"/** 
 * Populate the given GenericConversionService instance with the set of default converters.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#addDefaultConverters(ConverterRegistry)}
 */
@Deprecated public static void addDefaultConverters(GenericConversionService conversionService){
  DefaultConversionService.addDefaultConverters(conversionService);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader} and a {@link StandardEnvironment}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding property could be found
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver,boolean)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader,boolean ignoreUnresolvablePlaceholders){
  this(resourceLoader,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver){
  this(resourcePatternResolver,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding system property could be found
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver,boolean)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver,boolean ignoreUnresolvablePlaceholders){
  this(resourcePatternResolver,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Replacement for  {@code Class.forName()} that also returns Class instancesfor primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return  {@code false} if either the class orone of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Set a List of  {@code TemplateLoader}s that will be used to search for templates. For example, one or more custom loaders such as database loaders could be configured and injected here.
 * @deprecated as of Spring 2.0.1, in favor of the ""preTemplateLoaders""and ""postTemplateLoaders"" properties
 * @see #setPreTemplateLoaders
 * @see #setPostTemplateLoaders
 */
@Deprecated public void setTemplateLoaders(TemplateLoader[] templateLoaders){
  if (templateLoaders != null) {
    this.templateLoaders.addAll(Arrays.asList(templateLoaders));
  }
}
"
"/** 
 * Apply the given method invocation to the given RMI stub. <p>Delegates to the corresponding method if the RMI stub does not directly implement the invoked method. This typically happens when a non-RMI service interface is used for an RMI service. The methods of such a service interface have to match the RMI stub methods, but they typically don't declare {@code java.rmi.RemoteException}: A RemoteException thrown by the RMI stub will be automatically converted to Spring's RemoteAccessException.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object invoke(MethodInvocation invocation,Remote stub,String serviceName) throws Throwable {
  try {
    return invokeRemoteMethod(invocation,stub);
  }
 catch (  InvocationTargetException ex) {
    Throwable targetEx=ex.getTargetException();
    if (targetEx instanceof RemoteException) {
      RemoteException rex=(RemoteException)targetEx;
      throw convertRmiAccessException(invocation.getMethod(),rex,serviceName);
    }
 else {
      throw targetEx;
    }
  }
}
"
"/** 
 * Perform a raw method invocation on the given RMI stub, letting reflection exceptions through as-is.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object doInvoke(MethodInvocation invocation,Remote stub) throws InvocationTargetException {
  return invokeRemoteMethod(invocation,stub);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(String,Object)}
 */
@Deprecated public ModelMap addObject(String modelName,Object modelObject){
  return addAttribute(modelName,modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(Object)}
 */
@Deprecated public ModelMap addObject(Object modelObject){
  return addAttribute(modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Collection)}
 */
@Deprecated public ModelMap addAllObjects(Collection objects){
  return addAllAttributes(objects);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Map)}
 */
@Deprecated public ModelMap addAllObjects(Map objects){
  return addAllAttributes(objects);
}
"
"/** 
 * Constructor for CannotGetJdbcConnectionException.
 * @param msg the detail message
 * @param ex ClassNotFoundException root cause
 * @deprecated since Spring 2.5, in favor of throwing anIllegalStateException in case of the driver not being found
 */
@Deprecated public CannotGetJdbcConnectionException(String msg,ClassNotFoundException ex){
  super(msg,ex);
}
"
"/** 
 * Add a  {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.
 * @deprecated in favor of {@link #addDeclaredRowMapper(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public void addDeclaredRowMapper(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,(RowMapper)rowMapper);
}
"
"/** 
 * @deprecated in favor of {@link #returningResultSet(String,org.springframework.jdbc.core.RowMapper)}
 */
@Override @Deprecated public SimpleJdbcCall returningResultSet(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,rowMapper);
  return this;
}
"
"/** 
 * Create a new DriverManagerDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @deprecated since Spring 2.5. DriverManagerDataSource is primarilyintended for accessing <i>pre-registered</i> JDBC drivers. If you need to register a new driver, consider using {@link SimpleDriverDataSource} instead.
 */
@Deprecated public DriverManagerDataSource(String driverClassName,String url,String username,String password){
  setDriverClassName(driverClassName);
  setUrl(url);
  setUsername(username);
  setPassword(password);
}
"
"/** 
 * Create a new SingleConnectionDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @param suppressClose if the returned Connection should be aclose-suppressing proxy or the physical Connection
 * @deprecated since Spring 2.5. Driver parameter usage is generally not recommendedfor a SingleConnectionDataSource. If you insist on using driver parameters directly, set up the Driver class manually before invoking this DataSource.
 * @see java.sql.DriverManager#getConnection(String,String,String)
 */
@Deprecated public SingleConnectionDataSource(String driverClassName,String url,String username,String password,boolean suppressClose){
  super(driverClassName,url,username,password);
  this.suppressClose=suppressClose;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.4.
 * @return {@code true} if the current JVM is at least Java 1.4
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_14
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava14(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.5 (Java 5).
 * @return {@code true} if the current JVM is at least Java 1.5
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava15(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.6 (Java 6).
 * @return {@code true} if the current JVM is at least Java 1.6
 * @deprecated as of Spring 3.0, in favor of reflective checks forthe specific Java 1.6 classes of interest
 * @see #getMajorJavaVersion()
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava16(){
  return (majorJavaVersion >= JAVA_16);
}
"
"/** 
 * Create a new default GenericConversionService instance that can be safely modified.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#DefaultConversionService()}
 */
@Deprecated public static GenericConversionService createDefaultConversionService(){
  return new DefaultConversionService();
}
"
"/** 
 * Populate the given GenericConversionService instance with the set of default converters.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#addDefaultConverters(ConverterRegistry)}
 */
@Deprecated public static void addDefaultConverters(GenericConversionService conversionService){
  DefaultConversionService.addDefaultConverters(conversionService);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader} and a {@link StandardEnvironment}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding property could be found
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver,boolean)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader,boolean ignoreUnresolvablePlaceholders){
  this(resourceLoader,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver){
  this(resourcePatternResolver,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding system property could be found
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver,boolean)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver,boolean ignoreUnresolvablePlaceholders){
  this(resourcePatternResolver,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Constructor for CannotGetJdbcConnectionException.
 * @param msg the detail message
 * @param ex ClassNotFoundException root cause
 * @deprecated since Spring 2.5, in favor of throwing anIllegalStateException in case of the driver not being found
 */
@Deprecated public CannotGetJdbcConnectionException(String msg,ClassNotFoundException ex){
  super(msg,ex);
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(org.hibernate.cache.CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Add a  {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.
 * @deprecated in favor of {@link #addDeclaredRowMapper(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public void addDeclaredRowMapper(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,(RowMapper)rowMapper);
}
"
"/** 
 * @deprecated in favor of {@link #returningResultSet(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public SimpleJdbcCall returningResultSet(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,rowMapper);
  return this;
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a List result.
 * @param action callback object that specifies the data access action
 * @return the List result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public List executeWithListResult(SqlMapClientCallback<List> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a Map result.
 * @param action callback object that specifies the data access action
 * @return the Map result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public Map executeWithMapResult(SqlMapClientCallback<Map> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Create a new DriverManagerDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @deprecated since Spring 2.5. DriverManagerDataSource is primarilyintended for accessing <i>pre-registered</i> JDBC drivers. If you need to register a new driver, consider using {@link SimpleDriverDataSource} instead.
 */
@Deprecated public DriverManagerDataSource(String driverClassName,String url,String username,String password){
  setDriverClassName(driverClassName);
  setUrl(url);
  setUsername(username);
  setPassword(password);
}
"
"/** 
 * Create a new SingleConnectionDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @param suppressClose if the returned Connection should be aclose-suppressing proxy or the physical Connection
 * @deprecated since Spring 2.5. Driver parameter usage is generally not recommendedfor a SingleConnectionDataSource. If you insist on using driver parameters directly, set up the Driver class manually before invoking this DataSource.
 * @see java.sql.DriverManager#getConnection(String,String,String)
 */
@Deprecated public SingleConnectionDataSource(String driverClassName,String url,String username,String password,boolean suppressClose){
  super(driverClassName,url,username,password);
  this.suppressClose=suppressClose;
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a List result.
 * @param action callback object that specifies the data access action
 * @return the List result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public List executeWithListResult(SqlMapClientCallback<List> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a Map result.
 * @param action callback object that specifies the data access action
 * @return the Map result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public Map executeWithMapResult(SqlMapClientCallback<Map> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of HttpStatus.METHOD_FAILURE
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of HttpStatus.DESTINATION_LOCKED
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param beanFactory the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.1.2 in favor of{@link BeanFactoryAnnotationUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
@Deprecated public static PlatformTransactionManager getTransactionManager(BeanFactory beanFactory,String qualifier){
  return BeanFactoryAnnotationUtils.qualifiedBeanOfType(beanFactory,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Obtain a PlatformTransactionManager from the given BeanFactory, matching the given qualifier.
 * @param bf the BeanFactory to get the {@code PlatformTransactionManager} bean from
 * @param qualifier the qualifier for selecting between multiple {@code PlatformTransactionManager} matches
 * @return the chosen {@code PlatformTransactionManager} (never {@code null})
 * @throws IllegalStateException if no matching {@code PlatformTransactionManager} bean found
 * @deprecated as of Spring 3.1.2 in favor of{@link BeanFactoryAnnotationUtils#qualifiedBeanOfType(BeanFactory,Class,String)}
 */
@Deprecated public static PlatformTransactionManager getTransactionManager(ConfigurableListableBeanFactory bf,String qualifier){
  return BeanFactoryAnnotationUtils.qualifiedBeanOfType(bf,PlatformTransactionManager.class,qualifier);
}
"
"/** 
 * Return the ContextLoader used by this listener.
 * @return the current ContextLoader
 * @deprecated in favor of simply subclassing ContextLoaderListener itself(which extends ContextLoader, as of Spring 3.0)
 */
@Deprecated public ContextLoader getContextLoader(){
  return this.contextLoader;
}
"
"/** 
 * Encodes the given source URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromUri(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param uri the URI to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeUri(String uri,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(uri,""'uri' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=URI_PATTERN.matcher(uri);
  if (m.matches()) {
    String scheme=m.group(2);
    String authority=m.group(3);
    String userinfo=m.group(5);
    String host=m.group(6);
    String port=m.group(8);
    String path=m.group(9);
    String query=m.group(11);
    String fragment=m.group(13);
    return encodeUriComponents(scheme,authority,userinfo,host,port,path,query,fragment,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + uri + ""] is not a valid URI"");
  }
}
"
"/** 
 * Encodes the given HTTP URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not support fragments ( {@code #}), as these are not supposed to be sent to the server, but retained by the client. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre> UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param httpUrl the HTTP URL to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URL
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeHttpUrl(String httpUrl,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(httpUrl,""'httpUrl' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=HTTP_URL_PATTERN.matcher(httpUrl);
  if (m.matches()) {
    String scheme=m.group(1);
    String authority=m.group(2);
    String userinfo=m.group(4);
    String host=m.group(5);
    String portString=m.group(7);
    String path=m.group(8);
    String query=m.group(10);
    return encodeUriComponents(scheme,authority,userinfo,host,portString,path,query,null,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + httpUrl + ""] is not a valid HTTP URL"");
  }
}
"
"/** 
 * Encodes the given source URI components into an encoded String. All various URI components are optional, but encoded according to their respective valid character sets.
 * @param scheme the scheme
 * @param authority the authority
 * @param userInfo the user info
 * @param host the host
 * @param port the port
 * @param path the path
 * @param query the query
 * @param fragment the fragment
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}
 */
@Deprecated public static String encodeUriComponents(String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,String encoding) throws UnsupportedEncodingException {
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  StringBuilder sb=new StringBuilder();
  if (scheme != null) {
    sb.append(encodeScheme(scheme,encoding));
    sb.append(':');
  }
  if (authority != null) {
    sb.append(""//"");
    if (userInfo != null) {
      sb.append(encodeUserInfo(userInfo,encoding));
      sb.append('@');
    }
    if (host != null) {
      sb.append(encodeHost(host,encoding));
    }
    if (port != null) {
      sb.append(':');
      sb.append(encodePort(port,encoding));
    }
  }
  sb.append(encodePath(path,encoding));
  if (query != null) {
    sb.append('?');
    sb.append(encodeQuery(query,encoding));
  }
  if (fragment != null) {
    sb.append('#');
    sb.append(encodeFragment(fragment,encoding));
  }
  return sb.toString();
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorParameter(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    this.cnManagerFactoryBean.getMediaTypes().putAll(mediaTypes);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Set a List of  {@code TemplateLoader}s that will be used to search for templates. For example, one or more custom loaders such as database loaders could be configured and injected here.
 * @deprecated as of Spring 2.0.1, in favor of the ""preTemplateLoaders""and ""postTemplateLoaders"" properties
 * @see #setPreTemplateLoaders
 * @see #setPostTemplateLoaders
 */
@Deprecated public void setTemplateLoaders(TemplateLoader... templateLoaders){
  if (templateLoaders != null) {
    this.templateLoaders.addAll(Arrays.asList(templateLoaders));
  }
}
"
"/** 
 * Set a List of  {@code TemplateLoader}s that will be used to search for templates. For example, one or more custom loaders such as database loaders could be configured and injected here.
 * @deprecated as of Spring 2.0.1, in favor of the ""preTemplateLoaders""and ""postTemplateLoaders"" properties
 * @see #setPreTemplateLoaders
 * @see #setPostTemplateLoaders
 */
@Deprecated public void setTemplateLoaders(TemplateLoader... templateLoaders){
  if (templateLoaders != null) {
    this.templateLoaders.addAll(Arrays.asList(templateLoaders));
  }
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link #registerAutoProxyCreatorIfNecessary(ParserContext,Element)} and{@link AopConfigUtils#registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry,Object)}
 */
@Deprecated public static void registerAutoProxyCreatorIfNecessary(ParserContext parserContext,Object source){
  BeanDefinition beanDefinition=AopConfigUtils.registerAutoProxyCreatorIfNecessary(parserContext.getRegistry(),source);
  registerComponentIfNecessary(beanDefinition,parserContext);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link AopConfigUtils#forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry)}
 */
@Deprecated public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry){
  AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
}
"
"/** 
 * Add all of the given advisors to this proxy configuration.
 * @param advisors the advisors to register
 * @deprecated as of Spring 3.0, in favor of {@link #addAdvisors}
 */
@Deprecated public void addAllAdvisors(Advisor[] advisors){
  addAdvisors(Arrays.asList(advisors));
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Register the given custom property editor for all properties of the given type, indicating that the given instance is a shared editor that might be used concurrently.
 * @param requiredType the type of the property
 * @param propertyEditor the shared editor to register
 * @deprecated as of Spring 3.0, in favor of PropertyEditorRegistrars or ConversionService usage
 */
@Deprecated public void registerSharedEditor(Class<?> requiredType,PropertyEditor propertyEditor){
  registerCustomEditor(requiredType,null,propertyEditor);
  if (this.sharedEditors == null) {
    this.sharedEditors=new HashSet<PropertyEditor>();
  }
  this.sharedEditors.add(propertyEditor);
}
"
"/** 
 * Set the name of the factory bean to use for this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setFactoryBean(String factoryBean,String factoryMethod){
  this.beanDefinition.setFactoryBeanName(factoryBean);
  this.beanDefinition.setFactoryMethodName(factoryMethod);
  return this;
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Set whether or not this definition describes a singleton bean, as alternative to  {@link #setScope}.
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public BeanDefinitionBuilder setSingleton(boolean singleton){
  this.beanDefinition.setSingleton(singleton);
  return this;
}
"
"/** 
 * Set the source of this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setSource(Object source){
  this.beanDefinition.setSource(source);
  return this;
}
"
"/** 
 * Set the description associated with this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setResourceDescription(String resourceDescription){
  this.beanDefinition.setResourceDescription(resourceDescription);
  return this;
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
@Deprecated public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link #registerAutoProxyCreatorIfNecessary(ParserContext,Element)} and{@link AopConfigUtils#registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry,Object)}
 */
@Deprecated public static void registerAutoProxyCreatorIfNecessary(ParserContext parserContext,Object source){
  BeanDefinition beanDefinition=AopConfigUtils.registerAutoProxyCreatorIfNecessary(parserContext.getRegistry(),source);
  registerComponentIfNecessary(beanDefinition,parserContext);
}
"
"/** 
 * @deprecated since Spring 2.5, in favor of{@link AopConfigUtils#forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry)}
 */
@Deprecated public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry){
  AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
}
"
"/** 
 * Add all of the given advisors to this proxy configuration.
 * @param advisors the advisors to register
 * @deprecated as of Spring 3.0, in favor of {@link #addAdvisors}
 */
@Deprecated public void addAllAdvisors(Advisor[] advisors){
  addAdvisors(Arrays.asList(advisors));
}
"
"/** 
 * Set a List of  {@code TemplateLoader}s that will be used to search for templates. For example, one or more custom loaders such as database loaders could be configured and injected here.
 * @deprecated as of Spring 2.0.1, in favor of the ""preTemplateLoaders""and ""postTemplateLoaders"" properties
 * @see #setPreTemplateLoaders
 * @see #setPostTemplateLoaders
 */
@Deprecated public void setTemplateLoaders(TemplateLoader[] templateLoaders){
  if (templateLoaders != null) {
    this.templateLoaders.addAll(Arrays.asList(templateLoaders));
  }
}
"
"/** 
 * Apply the given method invocation to the given RMI stub. <p>Delegates to the corresponding method if the RMI stub does not directly implement the invoked method. This typically happens when a non-RMI service interface is used for an RMI service. The methods of such a service interface have to match the RMI stub methods, but they typically don't declare {@code java.rmi.RemoteException}: A RemoteException thrown by the RMI stub will be automatically converted to Spring's RemoteAccessException.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object invoke(MethodInvocation invocation,Remote stub,String serviceName) throws Throwable {
  try {
    return invokeRemoteMethod(invocation,stub);
  }
 catch (  InvocationTargetException ex) {
    Throwable targetEx=ex.getTargetException();
    if (targetEx instanceof RemoteException) {
      RemoteException rex=(RemoteException)targetEx;
      throw convertRmiAccessException(invocation.getMethod(),rex,serviceName);
    }
 else {
      throw targetEx;
    }
  }
}
"
"/** 
 * Perform a raw method invocation on the given RMI stub, letting reflection exceptions through as-is.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object doInvoke(MethodInvocation invocation,Remote stub) throws InvocationTargetException {
  return invokeRemoteMethod(invocation,stub);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(String,Object)}
 */
@Deprecated public ModelMap addObject(String modelName,Object modelObject){
  return addAttribute(modelName,modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(Object)}
 */
@Deprecated public ModelMap addObject(Object modelObject){
  return addAttribute(modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Collection)}
 */
@Deprecated public ModelMap addAllObjects(Collection objects){
  return addAllAttributes(objects);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Map)}
 */
@Deprecated public ModelMap addAllObjects(Map objects){
  return addAllAttributes(objects);
}
"
"/** 
 * Register the given custom property editor for all properties of the given type, indicating that the given instance is a shared editor that might be used concurrently.
 * @param requiredType the type of the property
 * @param propertyEditor the shared editor to register
 * @deprecated as of Spring 3.0, in favor of PropertyEditorRegistrars or ConversionService usage
 */
@Deprecated public void registerSharedEditor(Class<?> requiredType,PropertyEditor propertyEditor){
  registerCustomEditor(requiredType,null,propertyEditor);
  if (this.sharedEditors == null) {
    this.sharedEditors=new HashSet<PropertyEditor>();
  }
  this.sharedEditors.add(propertyEditor);
}
"
"/** 
 * Set the name of the factory bean to use for this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setFactoryBean(String factoryBean,String factoryMethod){
  this.beanDefinition.setFactoryBeanName(factoryBean);
  this.beanDefinition.setFactoryMethodName(factoryMethod);
  return this;
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Set whether or not this definition describes a singleton bean, as alternative to  {@link #setScope}.
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public BeanDefinitionBuilder setSingleton(boolean singleton){
  this.beanDefinition.setSingleton(singleton);
  return this;
}
"
"/** 
 * Set the source of this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setSource(Object source){
  this.beanDefinition.setSource(source);
  return this;
}
"
"/** 
 * Set the description associated with this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setResourceDescription(String resourceDescription){
  this.beanDefinition.setResourceDescription(resourceDescription);
  return this;
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
@Deprecated public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Set the registration behavior by the name of the corresponding constant, e.g. ""REGISTRATION_IGNORE_EXISTING"".
 * @see #setRegistrationBehavior
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehaviorName(String registrationBehavior){
  setRegistrationBehavior(constants.asNumber(registrationBehavior).intValue());
}
"
"/** 
 * Specify what action should be taken when attempting to register an MBean under an  {@link javax.management.ObjectName} that already exists.<p>Default is REGISTRATION_FAIL_ON_EXISTING.
 * @see #setRegistrationBehaviorName(String)
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehavior(int registrationBehavior){
  setRegistrationPolicy(RegistrationPolicy.valueOf(registrationBehavior));
}
"
"/** 
 * Set a List of  {@code TemplateLoader}s that will be used to search for templates. For example, one or more custom loaders such as database loaders could be configured and injected here.
 * @deprecated as of Spring 2.0.1, in favor of the ""preTemplateLoaders""and ""postTemplateLoaders"" properties
 * @see #setPreTemplateLoaders
 * @see #setPostTemplateLoaders
 */
@Deprecated public void setTemplateLoaders(TemplateLoader[] templateLoaders){
  if (templateLoaders != null) {
    this.templateLoaders.addAll(Arrays.asList(templateLoaders));
  }
}
"
"/** 
 * Apply the given method invocation to the given RMI stub. <p>Delegates to the corresponding method if the RMI stub does not directly implement the invoked method. This typically happens when a non-RMI service interface is used for an RMI service. The methods of such a service interface have to match the RMI stub methods, but they typically don't declare {@code java.rmi.RemoteException}: A RemoteException thrown by the RMI stub will be automatically converted to Spring's RemoteAccessException.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object invoke(MethodInvocation invocation,Remote stub,String serviceName) throws Throwable {
  try {
    return invokeRemoteMethod(invocation,stub);
  }
 catch (  InvocationTargetException ex) {
    Throwable targetEx=ex.getTargetException();
    if (targetEx instanceof RemoteException) {
      RemoteException rex=(RemoteException)targetEx;
      throw convertRmiAccessException(invocation.getMethod(),rex,serviceName);
    }
 else {
      throw targetEx;
    }
  }
}
"
"/** 
 * Perform a raw method invocation on the given RMI stub, letting reflection exceptions through as-is.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object doInvoke(MethodInvocation invocation,Remote stub) throws InvocationTargetException {
  return invokeRemoteMethod(invocation,stub);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(String,Object)}
 */
@Deprecated public ModelMap addObject(String modelName,Object modelObject){
  return addAttribute(modelName,modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAttribute(Object)}
 */
@Deprecated public ModelMap addObject(Object modelObject){
  return addAttribute(modelObject);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Collection)}
 */
@Deprecated public ModelMap addAllObjects(Collection objects){
  return addAllAttributes(objects);
}
"
"/** 
 * @deprecated as of Spring 2.5, in favor of {@link #addAllAttributes(Map)}
 */
@Deprecated public ModelMap addAllObjects(Map objects){
  return addAllAttributes(objects);
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.4.
 * @return {@code true} if the current JVM is at least Java 1.4
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_14
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava14(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.5 (Java 5).
 * @return {@code true} if the current JVM is at least Java 1.5
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava15(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.6 (Java 6).
 * @return {@code true} if the current JVM is at least Java 1.6
 * @deprecated as of Spring 3.0, in favor of reflective checks forthe specific Java 1.6 classes of interest
 * @see #getMajorJavaVersion()
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava16(){
  return (majorJavaVersion >= JAVA_16);
}
"
"/** 
 * Create a new default GenericConversionService instance that can be safely modified.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#DefaultConversionService()}
 */
@Deprecated public static GenericConversionService createDefaultConversionService(){
  return new DefaultConversionService();
}
"
"/** 
 * Populate the given GenericConversionService instance with the set of default converters.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#addDefaultConverters(ConverterRegistry)}
 */
@Deprecated public static void addDefaultConverters(GenericConversionService conversionService){
  DefaultConversionService.addDefaultConverters(conversionService);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader} and a {@link StandardEnvironment}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding property could be found
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver,boolean)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader,boolean ignoreUnresolvablePlaceholders){
  this(resourceLoader,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver){
  this(resourcePatternResolver,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding system property could be found
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver,boolean)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver,boolean ignoreUnresolvablePlaceholders){
  this(resourcePatternResolver,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Constructor for CannotGetJdbcConnectionException.
 * @param msg the detail message
 * @param ex ClassNotFoundException root cause
 * @deprecated since Spring 2.5, in favor of throwing anIllegalStateException in case of the driver not being found
 */
@Deprecated public CannotGetJdbcConnectionException(String msg,ClassNotFoundException ex){
  super(msg,ex);
}
"
"/** 
 * Add a  {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.
 * @deprecated in favor of {@link #addDeclaredRowMapper(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public void addDeclaredRowMapper(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,(RowMapper)rowMapper);
}
"
"/** 
 * @deprecated in favor of {@link #returningResultSet(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public SimpleJdbcCall returningResultSet(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,rowMapper);
  return this;
}
"
"/** 
 * Create a new DriverManagerDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @deprecated since Spring 2.5. DriverManagerDataSource is primarilyintended for accessing <i>pre-registered</i> JDBC drivers. If you need to register a new driver, consider using {@link SimpleDriverDataSource} instead.
 */
@Deprecated public DriverManagerDataSource(String driverClassName,String url,String username,String password){
  setDriverClassName(driverClassName);
  setUrl(url);
  setUsername(username);
  setPassword(password);
}
"
"/** 
 * Create a new SingleConnectionDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @param suppressClose if the returned Connection should be aclose-suppressing proxy or the physical Connection
 * @deprecated since Spring 2.5. Driver parameter usage is generally not recommendedfor a SingleConnectionDataSource. If you insist on using driver parameters directly, set up the Driver class manually before invoking this DataSource.
 * @see java.sql.DriverManager#getConnection(String,String,String)
 */
@Deprecated public SingleConnectionDataSource(String driverClassName,String url,String username,String password,boolean suppressClose){
  super(driverClassName,url,username,password);
  this.suppressClose=suppressClose;
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a List result.
 * @param action callback object that specifies the data access action
 * @return the List result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public List executeWithListResult(SqlMapClientCallback<List> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a Map result.
 * @param action callback object that specifies the data access action
 * @return the Map result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public Map executeWithMapResult(SqlMapClientCallback<Map> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.4.
 * @return {@code true} if the current JVM is at least Java 1.4
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_14
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava14(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.5 (Java 5).
 * @return {@code true} if the current JVM is at least Java 1.5
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava15(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.6 (Java 6).
 * @return {@code true} if the current JVM is at least Java 1.6
 * @deprecated as of Spring 3.0, in favor of reflective checks forthe specific Java 1.6 classes of interest
 * @see #getMajorJavaVersion()
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava16(){
  return (majorJavaVersion >= JAVA_16);
}
"
"/** 
 * Create a new default GenericConversionService instance that can be safely modified.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#DefaultConversionService()}
 */
@Deprecated public static GenericConversionService createDefaultConversionService(){
  return new DefaultConversionService();
}
"
"/** 
 * Populate the given GenericConversionService instance with the set of default converters.
 * @deprecated in Spring 3.1 in favor of {@link DefaultConversionService#addDefaultConverters(ConverterRegistry)}
 */
@Deprecated public static void addDefaultConverters(GenericConversionService conversionService){
  DefaultConversionService.addDefaultConverters(conversionService);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader} and a {@link StandardEnvironment}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding property could be found
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver,boolean)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader,boolean ignoreUnresolvablePlaceholders){
  this(resourceLoader,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver){
  this(resourcePatternResolver,new StandardEnvironment(),true);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding system property could be found
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver,boolean)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver,boolean ignoreUnresolvablePlaceholders){
  this(resourcePatternResolver,new StandardEnvironment(),ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Constructor for CannotGetJdbcConnectionException.
 * @param msg the detail message
 * @param ex ClassNotFoundException root cause
 * @deprecated since Spring 2.5, in favor of throwing anIllegalStateException in case of the driver not being found
 */
@Deprecated public CannotGetJdbcConnectionException(String msg,ClassNotFoundException ex){
  super(msg,ex);
}
"
"/** 
 * Add a  {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.
 * @deprecated in favor of {@link #addDeclaredRowMapper(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public void addDeclaredRowMapper(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,(RowMapper)rowMapper);
}
"
"/** 
 * @deprecated in favor of {@link #returningResultSet(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public SimpleJdbcCall returningResultSet(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,rowMapper);
  return this;
}
"
"/** 
 * Create a new DriverManagerDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @deprecated since Spring 2.5. DriverManagerDataSource is primarilyintended for accessing <i>pre-registered</i> JDBC drivers. If you need to register a new driver, consider using {@link SimpleDriverDataSource} instead.
 */
@Deprecated public DriverManagerDataSource(String driverClassName,String url,String username,String password){
  setDriverClassName(driverClassName);
  setUrl(url);
  setUsername(username);
  setPassword(password);
}
"
"/** 
 * Create a new SingleConnectionDataSource with the given standard DriverManager parameters.
 * @param driverClassName the JDBC driver class name
 * @param url the JDBC URL to use for accessing the DriverManager
 * @param username the JDBC username to use for accessing the DriverManager
 * @param password the JDBC password to use for accessing the DriverManager
 * @param suppressClose if the returned Connection should be aclose-suppressing proxy or the physical Connection
 * @deprecated since Spring 2.5. Driver parameter usage is generally not recommendedfor a SingleConnectionDataSource. If you insist on using driver parameters directly, set up the Driver class manually before invoking this DataSource.
 * @see java.sql.DriverManager#getConnection(String,String,String)
 */
@Deprecated public SingleConnectionDataSource(String driverClassName,String url,String username,String password,boolean suppressClose){
  super(driverClassName,url,username,password);
  this.suppressClose=suppressClose;
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a List result.
 * @param action callback object that specifies the data access action
 * @return the List result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public List executeWithListResult(SqlMapClientCallback<List> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Execute the given data access action on a SqlMapExecutor, expecting a Map result.
 * @param action callback object that specifies the data access action
 * @return the Map result
 * @throws DataAccessException in case of SQL Maps errors
 * @deprecated as of Spring 3.0 - not really needed anymore with generic{@link #execute} method
 */
@Deprecated public Map executeWithMapResult(SqlMapClientCallback<Map> action) throws DataAccessException {
  return execute(action);
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Set a List of  {@code TemplateLoader}s that will be used to search for templates. For example, one or more custom loaders such as database loaders could be configured and injected here.
 * @deprecated as of Spring 2.0.1, in favor of the ""preTemplateLoaders""and ""postTemplateLoaders"" properties
 * @see #setPreTemplateLoaders
 * @see #setPostTemplateLoaders
 */
@Deprecated public void setTemplateLoaders(TemplateLoader... templateLoaders){
  if (templateLoaders != null) {
    this.templateLoaders.addAll(Arrays.asList(templateLoaders));
  }
}
"
"/** 
 * Set the registration behavior by the name of the corresponding constant, e.g. ""REGISTRATION_IGNORE_EXISTING"".
 * @see #setRegistrationBehavior
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehaviorName(String registrationBehavior){
  setRegistrationBehavior(constants.asNumber(registrationBehavior).intValue());
}
"
"/** 
 * Specify what action should be taken when attempting to register an MBean under an  {@link javax.management.ObjectName} that already exists.<p>Default is REGISTRATION_FAIL_ON_EXISTING.
 * @see #setRegistrationBehaviorName(String)
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehavior(int registrationBehavior){
  setRegistrationPolicy(RegistrationPolicy.valueOf(registrationBehavior));
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorParameter(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    Properties props=new Properties();
    props.putAll(mediaTypes);
    this.cnManagerFactoryBean.setMediaTypes(props);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Set the name of the factory bean to use for this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setFactoryBean(String factoryBean,String factoryMethod){
  this.beanDefinition.setFactoryBeanName(factoryBean);
  this.beanDefinition.setFactoryMethodName(factoryMethod);
  return this;
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Set whether or not this definition describes a singleton bean, as alternative to  {@link #setScope}.
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public BeanDefinitionBuilder setSingleton(boolean singleton){
  this.beanDefinition.setSingleton(singleton);
  return this;
}
"
"/** 
 * Set the source of this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setSource(Object source){
  this.beanDefinition.setSource(source);
  return this;
}
"
"/** 
 * Set the description associated with this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setResourceDescription(String resourceDescription){
  this.beanDefinition.setResourceDescription(resourceDescription);
  return this;
}
"
"/** 
 * Set the name of the factory bean to use for this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setFactoryBean(String factoryBean,String factoryMethod){
  this.beanDefinition.setFactoryBeanName(factoryBean);
  this.beanDefinition.setFactoryMethodName(factoryMethod);
  return this;
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Set whether or not this definition describes a singleton bean, as alternative to  {@link #setScope}.
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public BeanDefinitionBuilder setSingleton(boolean singleton){
  this.beanDefinition.setSingleton(singleton);
  return this;
}
"
"/** 
 * Set the source of this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setSource(Object source){
  this.beanDefinition.setSource(source);
  return this;
}
"
"/** 
 * Set the description associated with this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setResourceDescription(String resourceDescription){
  this.beanDefinition.setResourceDescription(resourceDescription);
  return this;
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorPathExtension(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    Properties props=new Properties();
    props.putAll(mediaTypes);
    this.cnManagerFactoryBean.setMediaTypes(props);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorPathExtension(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    Properties props=new Properties();
    props.putAll(mediaTypes);
    this.cnManagerFactoryBean.setMediaTypes(props);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the expected root object for the unmarshaller, into which the source will be unmarshalled.
 * @see org.exolab.castor.xml.Unmarshaller#setObject(Object)
 * @deprecated in favor of {@link #setRootObject}
 */
@Deprecated public void setObject(Object root){
  this.rootObject=root;
}
"
"/** 
 * Add a  {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.
 * @deprecated in favor of {@link #addDeclaredRowMapper(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public void addDeclaredRowMapper(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,(RowMapper)rowMapper);
}
"
"/** 
 * @deprecated in favor of {@link #returningResultSet(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public SimpleJdbcCall returningResultSet(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,rowMapper);
  return this;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Construct a new  {@link ContextConfigurationAttributes} instance for the{@linkplain Class test class} that declared the{@link ContextConfiguration @ContextConfiguration} annotation and itscorresponding attributes.
 * @param declaringClass the test class that declared {@code @ContextConfiguration}
 * @param locations the resource locations declared via {@code @ContextConfiguration}
 * @param classes the annotated classes declared via {@code @ContextConfiguration}
 * @param inheritLocations the {@code inheritLocations} flag declared via {@code @ContextConfiguration}
 * @param contextLoaderClass the {@code ContextLoader} class declared via {@code @ContextConfiguration}
 * @throws IllegalArgumentException if the {@code declaringClass} or {@code contextLoaderClass} is{@code null}, or if the  {@code locations} and {@code classes} are both non-empty
 * @deprecated as of Spring 3.2, use{@link #ContextConfigurationAttributes(Class,String[],Class[],boolean,Class[],boolean,String,Class)}instead
 */
@Deprecated public ContextConfigurationAttributes(Class<?> declaringClass,String[] locations,Class<?>[] classes,boolean inheritLocations,Class<? extends ContextLoader> contextLoaderClass){
  this(declaringClass,locations,classes,inheritLocations,null,true,null,contextLoaderClass);
}
"
"/** 
 * Call this method to signal that the  {@linkplain ApplicationContext applicationcontext} associated with this test context is <em>dirty</em> and should bediscarded. Do this if a test has modified the context &mdash; for example, by replacing a bean definition or modifying the state of a singleton bean.
 * @deprecated As of Spring 3.2.2, use {@link #markApplicationContextDirty(HierarchyMode)} instead.
 */
@Deprecated public void markApplicationContextDirty(){
  markApplicationContextDirty((HierarchyMode)null);
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied test class, resource locations, annotated classes, context initializers, active profiles, resource base path, and  {@code ContextLoader}. <p>If a  {@code null} value is supplied for {@code locations}, {@code classes}, or  {@code activeProfiles} an empty array willbe stored instead. If a  {@code null} value is supplied for the{@code contextInitializerClasses} an empty set will be stored instead.If an <em>empty</em> value is supplied for the  {@code resourceBasePath}an empty string will be used. Furthermore, active profiles will be sorted, and duplicate profiles will be removed.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @see #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)
 * @deprecated as of Spring 3.2.2, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)} instead.
 */
@Deprecated public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,resourceBasePath,contextLoader,null,null);
}
"
"/** 
 * Construct a new  {@link ContextConfigurationAttributes} instance for the{@linkplain Class test class} that declared the{@link ContextConfiguration @ContextConfiguration} annotation and itscorresponding attributes.
 * @param declaringClass the test class that declared {@code @ContextConfiguration}
 * @param locations the resource locations declared via {@code @ContextConfiguration}
 * @param classes the annotated classes declared via {@code @ContextConfiguration}
 * @param inheritLocations the {@code inheritLocations} flag declared via {@code @ContextConfiguration}
 * @param contextLoaderClass the {@code ContextLoader} class declared via {@code @ContextConfiguration}
 * @throws IllegalArgumentException if the {@code declaringClass} or {@code contextLoaderClass} is{@code null}, or if the  {@code locations} and {@code classes} are both non-empty
 * @deprecated as of Spring 3.2, use{@link #ContextConfigurationAttributes(Class,String[],Class[],boolean,Class[],boolean,String,Class)}instead
 */
@Deprecated public ContextConfigurationAttributes(Class<?> declaringClass,String[] locations,Class<?>[] classes,boolean inheritLocations,Class<? extends ContextLoader> contextLoaderClass){
  this(declaringClass,locations,classes,inheritLocations,null,true,null,contextLoaderClass);
}
"
"/** 
 * Call this method to signal that the  {@linkplain ApplicationContext applicationcontext} associated with this test context is <em>dirty</em> and should bediscarded. Do this if a test has modified the context &mdash; for example, by replacing a bean definition or modifying the state of a singleton bean.
 * @deprecated As of Spring 3.2.2, use {@link #markApplicationContextDirty(HierarchyMode)} instead.
 */
@Deprecated public void markApplicationContextDirty(){
  markApplicationContextDirty((HierarchyMode)null);
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied test class, resource locations, annotated classes, context initializers, active profiles, resource base path, and  {@code ContextLoader}. <p>If a  {@code null} value is supplied for {@code locations}, {@code classes}, or  {@code activeProfiles} an empty array willbe stored instead. If a  {@code null} value is supplied for the{@code contextInitializerClasses} an empty set will be stored instead.If an <em>empty</em> value is supplied for the  {@code resourceBasePath}an empty string will be used. Furthermore, active profiles will be sorted, and duplicate profiles will be removed.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @see #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)
 * @deprecated as of Spring 3.2.2, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)} instead.
 */
@Deprecated public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,resourceBasePath,contextLoader,null,null);
}
"
"/** 
 * Set the name of the factory bean to use for this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setFactoryBean(String factoryBean,String factoryMethod){
  this.beanDefinition.setFactoryBeanName(factoryBean);
  this.beanDefinition.setFactoryMethodName(factoryMethod);
  return this;
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Set whether or not this definition describes a singleton bean, as alternative to  {@link #setScope}.
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public BeanDefinitionBuilder setSingleton(boolean singleton){
  this.beanDefinition.setSingleton(singleton);
  return this;
}
"
"/** 
 * Set the source of this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setSource(Object source){
  this.beanDefinition.setSource(source);
  return this;
}
"
"/** 
 * Set the description associated with this definition.
 * @deprecated since Spring 2.5, in favor of preparing this on the{@link #getRawBeanDefinition() raw BeanDefinition object}
 */
@Deprecated public BeanDefinitionBuilder setResourceDescription(String resourceDescription){
  this.beanDefinition.setResourceDescription(resourceDescription);
  return this;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Construct a new  {@link ContextConfigurationAttributes} instance for the{@linkplain Class test class} that declared the{@link ContextConfiguration @ContextConfiguration} annotation and itscorresponding attributes.
 * @param declaringClass the test class that declared {@code @ContextConfiguration}
 * @param locations the resource locations declared via {@code @ContextConfiguration}
 * @param classes the annotated classes declared via {@code @ContextConfiguration}
 * @param inheritLocations the {@code inheritLocations} flag declared via {@code @ContextConfiguration}
 * @param contextLoaderClass the {@code ContextLoader} class declared via {@code @ContextConfiguration}
 * @throws IllegalArgumentException if the {@code declaringClass} or {@code contextLoaderClass} is{@code null}, or if the  {@code locations} and {@code classes} are both non-empty
 * @deprecated as of Spring 3.2, use{@link #ContextConfigurationAttributes(Class,String[],Class[],boolean,Class[],boolean,String,Class)}instead
 */
@Deprecated public ContextConfigurationAttributes(Class<?> declaringClass,String[] locations,Class<?>[] classes,boolean inheritLocations,Class<? extends ContextLoader> contextLoaderClass){
  this(declaringClass,locations,classes,inheritLocations,null,true,null,contextLoaderClass);
}
"
"/** 
 * Call this method to signal that the  {@linkplain ApplicationContext applicationcontext} associated with this test context is <em>dirty</em> and should bediscarded. Do this if a test has modified the context &mdash; for example, by replacing a bean definition or modifying the state of a singleton bean.
 * @deprecated As of Spring 3.2.2, use {@link #markApplicationContextDirty(HierarchyMode)} instead.
 */
@Deprecated public void markApplicationContextDirty(){
  markApplicationContextDirty((HierarchyMode)null);
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied test class, resource locations, annotated classes, context initializers, active profiles, resource base path, and  {@code ContextLoader}. <p>If a  {@code null} value is supplied for {@code locations}, {@code classes}, or  {@code activeProfiles} an empty array willbe stored instead. If a  {@code null} value is supplied for the{@code contextInitializerClasses} an empty set will be stored instead.If an <em>empty</em> value is supplied for the  {@code resourceBasePath}an empty string will be used. Furthermore, active profiles will be sorted, and duplicate profiles will be removed.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @see #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)
 * @deprecated as of Spring 3.2.2, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)} instead.
 */
@Deprecated public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,resourceBasePath,contextLoader,null,null);
}
"
"/** 
 * Apply the given method invocation to the given RMI stub. <p>Delegates to the corresponding method if the RMI stub does not directly implement the invoked method. This typically happens when a non-RMI service interface is used for an RMI service. The methods of such a service interface have to match the RMI stub methods, but they typically don't declare {@code java.rmi.RemoteException}: A RemoteException thrown by the RMI stub will be automatically converted to Spring's RemoteAccessException.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object invoke(MethodInvocation invocation,Remote stub,String serviceName) throws Throwable {
  try {
    return invokeRemoteMethod(invocation,stub);
  }
 catch (  InvocationTargetException ex) {
    Throwable targetEx=ex.getTargetException();
    if (targetEx instanceof RemoteException) {
      RemoteException rex=(RemoteException)targetEx;
      throw convertRmiAccessException(invocation.getMethod(),rex,serviceName);
    }
 else {
      throw targetEx;
    }
  }
}
"
"/** 
 * Perform a raw method invocation on the given RMI stub, letting reflection exceptions through as-is.
 * @deprecated as of Spring 2.5, in favor of {@link #invokeRemoteMethod}
 */
@Deprecated public static Object doInvoke(MethodInvocation invocation,Remote stub) throws InvocationTargetException {
  return invokeRemoteMethod(invocation,stub);
}
"
"/** 
 * Set a List of  {@code TemplateLoader}s that will be used to search for templates. For example, one or more custom loaders such as database loaders could be configured and injected here.
 * @deprecated as of Spring 2.0.1, in favor of the ""preTemplateLoaders""and ""postTemplateLoaders"" properties
 * @see #setPreTemplateLoaders
 * @see #setPostTemplateLoaders
 */
@Deprecated public void setTemplateLoaders(TemplateLoader... templateLoaders){
  if (templateLoaders != null) {
    this.templateLoaders.addAll(Arrays.asList(templateLoaders));
  }
}
"
"/** 
 * Set the registration behavior by the name of the corresponding constant, e.g. ""REGISTRATION_IGNORE_EXISTING"".
 * @see #setRegistrationBehavior
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehaviorName(String registrationBehavior){
  setRegistrationBehavior(constants.asNumber(registrationBehavior).intValue());
}
"
"/** 
 * Specify what action should be taken when attempting to register an MBean under an  {@link javax.management.ObjectName} that already exists.<p>Default is REGISTRATION_FAIL_ON_EXISTING.
 * @see #setRegistrationBehaviorName(String)
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehavior(int registrationBehavior){
  setRegistrationPolicy(RegistrationPolicy.valueOf(registrationBehavior));
}
"
"/** 
 * Return the Errors instance for this data binder.
 * @return the Errors instance, to be treated as Errors or as BindException
 * @deprecated in favor of {@link #getBindingResult()}. Use the  {@link BindException#BindException(BindingResult)} constructorto create a BindException instance if still needed.
 * @see #getBindingResult()
 */
@Deprecated public BindException getErrors(){
  if (this.bindException == null) {
    this.bindException=new BindException(getBindingResult());
  }
  return this.bindException;
}
"
"/** 
 * Merge the specified Velocity template with the given model and write the result to the given Writer.
 * @param velocityEngine VelocityEngine to work with
 * @param templateLocation the location of template, relative to Velocity's resource loader path
 * @param model the Map that contains model names as keys and model objects as values
 * @param writer the Writer to write the result to
 * @throws VelocityException if the template wasn't found or rendering failed
 * @deprecated Use {@link #mergeTemplate(VelocityEngine,String,String,Map,Writer)}instead, following Velocity 1.6's corresponding deprecation in its own API.
 */
@Deprecated public static void mergeTemplate(VelocityEngine velocityEngine,String templateLocation,Map<String,Object> model,Writer writer) throws VelocityException {
  VelocityContext velocityContext=new VelocityContext(model);
  velocityEngine.mergeTemplate(templateLocation,velocityContext,writer);
}
"
"/** 
 * Merge the specified Velocity template with the given model into a String. <p>When using this method to prepare a text for a mail to be sent with Spring's mail support, consider wrapping VelocityException in MailPreparationException.
 * @param velocityEngine VelocityEngine to work with
 * @param templateLocation the location of template, relative to Velocity's resource loader path
 * @param model the Map that contains model names as keys and model objects as values
 * @return the result as String
 * @throws VelocityException if the template wasn't found or rendering failed
 * @see org.springframework.mail.MailPreparationException
 * @deprecated Use {@link #mergeTemplateIntoString(VelocityEngine,String,String,Map)}instead, following Velocity 1.6's corresponding deprecation in its own API.
 */
@Deprecated public static String mergeTemplateIntoString(VelocityEngine velocityEngine,String templateLocation,Map<String,Object> model) throws VelocityException {
  StringWriter result=new StringWriter();
  mergeTemplate(velocityEngine,templateLocation,model,result);
  return result.toString();
}
"
"/** 
 * Specify WebServiceFeature specifications for the JAX-WS port stub: in the form of actual  {@link javax.xml.ws.WebServiceFeature} objects,WebServiceFeature Class references, or WebServiceFeature class names. <p>As of Spring 4.0, this is effectively just an alternative way of specifying  {@link #setPortFeatures ""portFeatures""}. Do not specify both properties at the same time; prefer ""portFeatures"" moving forward.
 * @deprecated as of Spring 4.0, in favor of the differentiated{@link #setServiceFeatures ""serviceFeatures""} and{@link #setPortFeatures ""portFeatures""} properties
 */
@Deprecated public void setWebServiceFeatures(Object[] webServiceFeatures){
  this.webServiceFeatures=webServiceFeatures;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Add a  {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.
 * @deprecated in favor of {@link #addDeclaredRowMapper(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public void addDeclaredRowMapper(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,(RowMapper)rowMapper);
}
"
"/** 
 * @deprecated in favor of {@link #returningResultSet(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public SimpleJdbcCall returningResultSet(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,rowMapper);
  return this;
}
"
"/** 
 * Set the expected root object for the unmarshaller, into which the source will be unmarshalled.
 * @see org.exolab.castor.xml.Unmarshaller#setObject(Object)
 * @deprecated in favor of {@link #setRootObject}
 */
@Deprecated public void setObject(Object root){
  this.rootObject=root;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.4.
 * @return {@code true} if the current JVM is at least Java 1.4
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_14
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava14(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.5 (Java 5).
 * @return {@code true} if the current JVM is at least Java 1.5
 * @deprecated as of Spring 3.0 which requires Java 1.5+
 * @see #getMajorJavaVersion()
 * @see #JAVA_15
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava15(){
  return true;
}
"
"/** 
 * Convenience method to determine if the current JVM is at least Java 1.6 (Java 6).
 * @return {@code true} if the current JVM is at least Java 1.6
 * @deprecated as of Spring 3.0, in favor of reflective checks forthe specific Java 1.6 classes of interest
 * @see #getMajorJavaVersion()
 * @see #JAVA_16
 * @see #JAVA_17
 */
@Deprecated public static boolean isAtLeastJava16(){
  return (majorJavaVersion >= JAVA_16);
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorPathExtension(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    Properties props=new Properties();
    props.putAll(mediaTypes);
    this.cnManagerFactoryBean.setMediaTypes(props);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Initialize the default settings assuming a  {@code null} parent delegate.
 * @deprecated in Spring 3.1 in favor of{@link #initDefaults(Element,BeanDefinitionParserDelegate)}
 */
@Deprecated public void initDefaults(Element root){
  initDefaults(root,null);
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Call this method to signal that the  {@linkplain ApplicationContext applicationcontext} associated with this test context is <em>dirty</em> and should bediscarded. Do this if a test has modified the context &mdash; for example, by replacing a bean definition or modifying the state of a singleton bean.
 * @deprecated as of Spring 3.2.2; use{@link #markApplicationContextDirty(DirtiesContext.HierarchyMode)} instead.
 */
@Deprecated public void markApplicationContextDirty(){
  markApplicationContextDirty((HierarchyMode)null);
}
"
"/** 
 * Call this method to signal that the  {@linkplain ApplicationContext applicationcontext} associated with this test context is <em>dirty</em> and should bediscarded. Do this if a test has modified the context &mdash; for example, by replacing a bean definition or modifying the state of a singleton bean.
 * @deprecated as of Spring 3.2.2; use{@link #markApplicationContextDirty(DirtiesContext.HierarchyMode)} instead.
 */
@Deprecated public void markApplicationContextDirty(){
  markApplicationContextDirty((HierarchyMode)null);
}
"
"/** 
 * Call this method to signal that the  {@linkplain ApplicationContext applicationcontext} associated with this test context is <em>dirty</em> and should bediscarded. Do this if a test has modified the context &mdash; for example, by replacing a bean definition or modifying the state of a singleton bean.
 * @deprecated as of Spring 3.2.2; use{@link #markApplicationContextDirty(DirtiesContext.HierarchyMode)} instead.
 */
@Deprecated public void markApplicationContextDirty(){
  markApplicationContextDirty((HierarchyMode)null);
}
"
"/** 
 * Encodes the given source URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre class=""code""> UriComponents uriComponents = UriComponentsBuilder.fromUri(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param uri the URI to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeUri(String uri,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(uri,""'uri' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=URI_PATTERN.matcher(uri);
  if (m.matches()) {
    String scheme=m.group(2);
    String authority=m.group(3);
    String userinfo=m.group(5);
    String host=m.group(6);
    String port=m.group(8);
    String path=m.group(9);
    String query=m.group(11);
    String fragment=m.group(13);
    return encodeUriComponents(scheme,authority,userinfo,host,port,path,query,fragment,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + uri + ""] is not a valid URI"");
  }
}
"
"/** 
 * Encodes the given HTTP URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not support fragments ( {@code #}), as these are not supposed to be sent to the server, but retained by the client. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre class=""code""> UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param httpUrl the HTTP URL to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URL
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeHttpUrl(String httpUrl,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(httpUrl,""'httpUrl' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=HTTP_URL_PATTERN.matcher(httpUrl);
  if (m.matches()) {
    String scheme=m.group(1);
    String authority=m.group(2);
    String userinfo=m.group(4);
    String host=m.group(5);
    String portString=m.group(7);
    String path=m.group(8);
    String query=m.group(10);
    return encodeUriComponents(scheme,authority,userinfo,host,portString,path,query,null,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + httpUrl + ""] is not a valid HTTP URL"");
  }
}
"
"/** 
 * Encodes the given source URI components into an encoded String. All various URI components are optional, but encoded according to their respective valid character sets.
 * @param scheme the scheme
 * @param authority the authority
 * @param userInfo the user info
 * @param host the host
 * @param port the port
 * @param path the path
 * @param query the query
 * @param fragment the fragment
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}
 */
@Deprecated public static String encodeUriComponents(String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,String encoding) throws UnsupportedEncodingException {
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  StringBuilder sb=new StringBuilder();
  if (scheme != null) {
    sb.append(encodeScheme(scheme,encoding));
    sb.append(':');
  }
  if (authority != null) {
    sb.append(""//"");
    if (userInfo != null) {
      sb.append(encodeUserInfo(userInfo,encoding));
      sb.append('@');
    }
    if (host != null) {
      sb.append(encodeHost(host,encoding));
    }
    if (port != null) {
      sb.append(':');
      sb.append(encodePort(port,encoding));
    }
  }
  sb.append(encodePath(path,encoding));
  if (query != null) {
    sb.append('?');
    sb.append(encodeQuery(query,encoding));
  }
  if (fragment != null) {
    sb.append('#');
    sb.append(encodeFragment(fragment,encoding));
  }
  return sb.toString();
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Call this method to signal that the  {@linkplain ApplicationContext applicationcontext} associated with this test context is <em>dirty</em> and should bediscarded. Do this if a test has modified the context &mdash; for example, by replacing a bean definition or modifying the state of a singleton bean.
 * @deprecated as of Spring 3.2.2; use{@link #markApplicationContextDirty(DirtiesContext.HierarchyMode)} instead.
 */
@Deprecated public void markApplicationContextDirty(){
  markApplicationContextDirty((HierarchyMode)null);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new ResourceEditorRegistrar for the given  {@link ResourceLoader}using a  {@link StandardEnvironment}.
 * @param resourceLoader the ResourceLoader (or ResourcePatternResolver)to create editors for (usually an ApplicationContext)
 * @see org.springframework.core.io.support.ResourcePatternResolver
 * @see org.springframework.context.ApplicationContext
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditorRegistrar(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditorRegistrar(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Set the expected root object for the unmarshaller, into which the source will be unmarshalled.
 * @see org.exolab.castor.xml.Unmarshaller#setObject(Object)
 * @deprecated in favor of {@link #setRootObject}
 */
@Deprecated public void setObject(Object root){
  this.rootObject=root;
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of HttpStatus.METHOD_FAILURE
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of HttpStatus.DESTINATION_LOCKED
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Specify WebServiceFeature specifications for the JAX-WS port stub: in the form of actual  {@link javax.xml.ws.WebServiceFeature} objects,WebServiceFeature Class references, or WebServiceFeature class names. <p>As of Spring 4.0, this is effectively just an alternative way of specifying  {@link #setPortFeatures ""portFeatures""}. Do not specify both properties at the same time; prefer ""portFeatures"" moving forward.
 * @deprecated as of Spring 4.0, in favor of the differentiated{@link #setServiceFeatures ""serviceFeatures""} and{@link #setPortFeatures ""portFeatures""} properties
 */
@Deprecated public void setWebServiceFeatures(Object[] webServiceFeatures){
  this.webServiceFeatures=webServiceFeatures;
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorPathExtension(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    Properties props=new Properties();
    props.putAll(mediaTypes);
    this.cnManagerFactoryBean.setMediaTypes(props);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Add a  {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.
 * @deprecated in favor of {@link #addDeclaredRowMapper(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public void addDeclaredRowMapper(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,(RowMapper)rowMapper);
}
"
"/** 
 * @deprecated in favor of {@link #returningResultSet(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public SimpleJdbcCall returningResultSet(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,rowMapper);
  return this;
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Set the expected root object for the unmarshaller, into which the source will be unmarshalled.
 * @see org.exolab.castor.xml.Unmarshaller#setObject(Object)
 * @deprecated in favor of {@link #setRootObject}
 */
@Deprecated public void setObject(Object root){
  this.rootObject=root;
}
"
"/** 
 * Create a new ResourceEditorRegistrar for the given  {@link ResourceLoader}using a  {@link StandardEnvironment}.
 * @param resourceLoader the ResourceLoader (or ResourcePatternResolver)to create editors for (usually an ApplicationContext)
 * @see org.springframework.core.io.support.ResourcePatternResolver
 * @see org.springframework.context.ApplicationContext
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditorRegistrar(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditorRegistrar(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment());
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader} and a {@link StandardEnvironment}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader){
  this(resourceLoader,null,true);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding property could be found
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver,boolean)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader,boolean ignoreUnresolvablePlaceholders){
  this(resourceLoader,null,ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver){
  this(resourcePatternResolver,null,true);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding system property could be found
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver,boolean)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver,boolean ignoreUnresolvablePlaceholders){
  this(resourcePatternResolver,null,ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Create a new ResourceEditorRegistrar for the given  {@link ResourceLoader}using a  {@link StandardEnvironment}.
 * @param resourceLoader the ResourceLoader (or ResourcePatternResolver)to create editors for (usually an ApplicationContext)
 * @see org.springframework.core.io.support.ResourcePatternResolver
 * @see org.springframework.context.ApplicationContext
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditorRegistrar(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditorRegistrar(ResourceLoader resourceLoader){
  this(resourceLoader,new StandardEnvironment());
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader} and a {@link StandardEnvironment}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader){
  this(resourceLoader,null,true);
}
"
"/** 
 * Create a new instance of the  {@link ResourceEditor} classusing the given  {@link ResourceLoader}.
 * @param resourceLoader the {@code ResourceLoader} to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding property could be found
 * @deprecated as of Spring 3.1 in favor of{@link #ResourceEditor(ResourceLoader,PropertyResolver,boolean)}
 */
@Deprecated public ResourceEditor(ResourceLoader resourceLoader,boolean ignoreUnresolvablePlaceholders){
  this(resourceLoader,null,ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver){
  this(resourcePatternResolver,null,true);
}
"
"/** 
 * Create a new ResourceArrayPropertyEditor with the given  {@link ResourcePatternResolver}and a  {@link StandardEnvironment}.
 * @param resourcePatternResolver the ResourcePatternResolver to use
 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholdersif no corresponding system property could be found
 * @deprecated as of 3.1 in favor of {@link #ResourceArrayPropertyEditor(ResourcePatternResolver,PropertyResolver,boolean)}
 */
@Deprecated public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver,boolean ignoreUnresolvablePlaceholders){
  this(resourcePatternResolver,null,ignoreUnresolvablePlaceholders);
}
"
"/** 
 * Determines if there is a type converter available in the specified context and attempts to use it to convert the supplied value to the specified type. Throws an exception if conversion is not possible.
 * @param context the evaluation context that may define a type converter
 * @param value the value to convert (may be null)
 * @param targetType the type to attempt conversion to
 * @return the converted value
 * @throws EvaluationException if there is a problem during conversion or conversionof the value to the specified type is not supported
 * @deprecated use {@link #convertTypedValue(EvaluationContext,TypedValue,Class)}
 */
@Deprecated public static <T>T convert(EvaluationContext context,Object value,Class<T> targetType) throws EvaluationException {
  return convertTypedValue(context,new TypedValue(value),targetType);
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Determines if there is a type converter available in the specified context and attempts to use it to convert the supplied value to the specified type. Throws an exception if conversion is not possible.
 * @param context the evaluation context that may define a type converter
 * @param value the value to convert (may be null)
 * @param targetType the type to attempt conversion to
 * @return the converted value
 * @throws EvaluationException if there is a problem during conversion or conversionof the value to the specified type is not supported
 * @deprecated use {@link #convertTypedValue(EvaluationContext,TypedValue,Class)}
 */
@Deprecated public static <T>T convert(EvaluationContext context,Object value,Class<T> targetType) throws EvaluationException {
  return convertTypedValue(context,new TypedValue(value),targetType);
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorPathExtension(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    Properties props=new Properties();
    props.putAll(mediaTypes);
    this.cnManagerFactoryBean.setMediaTypes(props);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorPathExtension(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    Properties props=new Properties();
    props.putAll(mediaTypes);
    this.cnManagerFactoryBean.setMediaTypes(props);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Set the classes for which mappings will be read from class-level annotation metadata.
 * @see XStream#processAnnotations(Class)
 * @deprecated in favor of {@link #setAnnotatedClasses} with varargs
 */
@Deprecated public void setAnnotatedClass(Class<?> annotatedClass){
  Assert.notNull(annotatedClass,""'annotatedClass' must not be null"");
  getXStream().processAnnotations(annotatedClass);
}
"
"/** 
 * @deprecated in favor of {@link #returningResultSet(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public SimpleJdbcCall returningResultSet(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,rowMapper);
  return this;
}
"
"/** 
 * Set the expected root object for the unmarshaller, into which the source will be unmarshalled.
 * @see org.exolab.castor.xml.Unmarshaller#setObject(Object)
 * @deprecated in favor of {@link #setRootObject}
 */
@Deprecated public void setObject(Object root){
  this.rootObject=root;
}
"
"/** 
 * Set the classes for which mappings will be read from class-level annotation metadata.
 * @see XStream#processAnnotations(Class)
 * @deprecated in favor of {@link #setAnnotatedClasses} with varargs
 */
@Deprecated public void setAnnotatedClass(Class<?> annotatedClass){
  Assert.notNull(annotatedClass,""'annotatedClass' must not be null"");
  getXStream().processAnnotations(annotatedClass);
}
"
"/** 
 * Set the connection timeout for the underlying HttpClient. A timeout value of 0 specifies an infinite timeout.
 * @param timeout the timeout value in milliseconds
 * @deprecated With no direct replacement
 */
@Deprecated public void setConnectTimeout(int timeout){
  Assert.isTrue(timeout >= 0,""Timeout must be a non-negative value"");
  getHttpClient().getParams().setIntParameter(CoreConnectionPNames.CONNECTION_TIMEOUT,timeout);
}
"
"/** 
 * Set the socket read timeout for the underlying HttpClient. A timeout value of 0 specifies an infinite timeout.
 * @param timeout the timeout value in milliseconds
 * @deprecated With no direct replacement
 */
@Deprecated public void setReadTimeout(int timeout){
  Assert.isTrue(timeout >= 0,""Timeout must be a non-negative value"");
  getHttpClient().getParams().setIntParameter(CoreConnectionPNames.SO_TIMEOUT,timeout);
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Add all of the given advisors to this proxy configuration.
 * @param advisors the advisors to register
 * @deprecated as of Spring 3.0, in favor of {@link #addAdvisors}
 */
@Deprecated public void addAllAdvisors(Advisor[] advisors){
  addAdvisors(Arrays.asList(advisors));
}
"
"/** 
 * Set the expected root object for the unmarshaller, into which the source will be unmarshalled.
 * @see org.exolab.castor.xml.Unmarshaller#setObject(Object)
 * @deprecated in favor of {@link #setRootObject}
 */
@Deprecated public void setObject(Object root){
  this.rootObject=root;
}
"
"/** 
 * Set the expected root object for the unmarshaller, into which the source will be unmarshalled.
 * @see org.exolab.castor.xml.Unmarshaller#setObject(Object)
 * @deprecated in favor of {@link #setRootObject}
 */
@Deprecated public void setObject(Object root){
  this.rootObject=root;
}
"
"/** 
 * Allows for providing JAX-WS 2.2 WebServiceFeature specifications: in the form of actual  {@link javax.xml.ws.WebServiceFeature} objects,WebServiceFeature Class references, or WebServiceFeature class names. <p>As of Spring 4.0, this is effectively just an alternative way of specifying  {@link #setEndpointFeatures ""endpointFeatures""}. Do not specify both properties at the same time; prefer ""endpointFeatures"" moving forward.
 * @deprecated as of Spring 4.0, in favor of {@link #setEndpointFeatures}
 */
@Deprecated public void setWebServiceFeatures(Object[] webServiceFeatures){
  this.webServiceFeatures=webServiceFeatures;
}
"
"/** 
 * Specify WebServiceFeature specifications for the JAX-WS port stub: in the form of actual  {@link javax.xml.ws.WebServiceFeature} objects,WebServiceFeature Class references, or WebServiceFeature class names. <p>As of Spring 4.0, this is effectively just an alternative way of specifying  {@link #setPortFeatures ""portFeatures""}. Do not specify both properties at the same time; prefer ""portFeatures"" moving forward.
 * @deprecated as of Spring 4.0, in favor of the differentiated{@link #setServiceFeatures ""serviceFeatures""} and{@link #setPortFeatures ""portFeatures""} properties
 */
@Deprecated public void setWebServiceFeatures(Object[] webServiceFeatures){
  this.webServiceFeatures=webServiceFeatures;
}
"
"/** 
 * Encodes the given source URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre class=""code""> UriComponents uriComponents = UriComponentsBuilder.fromUri(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param uri the URI to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeUri(String uri,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(uri,""'uri' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=URI_PATTERN.matcher(uri);
  if (m.matches()) {
    String scheme=m.group(2);
    String authority=m.group(3);
    String userinfo=m.group(5);
    String host=m.group(6);
    String port=m.group(8);
    String path=m.group(9);
    String query=m.group(11);
    String fragment=m.group(13);
    return encodeUriComponents(scheme,authority,userinfo,host,port,path,query,fragment,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + uri + ""] is not a valid URI"");
  }
}
"
"/** 
 * Encodes the given HTTP URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not support fragments ( {@code #}), as these are not supposed to be sent to the server, but retained by the client. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre class=""code""> UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param httpUrl the HTTP URL to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URL
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeHttpUrl(String httpUrl,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(httpUrl,""'httpUrl' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=HTTP_URL_PATTERN.matcher(httpUrl);
  if (m.matches()) {
    String scheme=m.group(1);
    String authority=m.group(2);
    String userinfo=m.group(4);
    String host=m.group(5);
    String portString=m.group(7);
    String path=m.group(8);
    String query=m.group(10);
    return encodeUriComponents(scheme,authority,userinfo,host,portString,path,query,null,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + httpUrl + ""] is not a valid HTTP URL"");
  }
}
"
"/** 
 * Encodes the given source URI components into an encoded String. All various URI components are optional, but encoded according to their respective valid character sets.
 * @param scheme the scheme
 * @param authority the authority
 * @param userInfo the user info
 * @param host the host
 * @param port the port
 * @param path the path
 * @param query the query
 * @param fragment the fragment
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}
 */
@Deprecated public static String encodeUriComponents(String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,String encoding) throws UnsupportedEncodingException {
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  StringBuilder sb=new StringBuilder();
  if (scheme != null) {
    sb.append(encodeScheme(scheme,encoding));
    sb.append(':');
  }
  if (authority != null) {
    sb.append(""//"");
    if (userInfo != null) {
      sb.append(encodeUserInfo(userInfo,encoding));
      sb.append('@');
    }
    if (host != null) {
      sb.append(encodeHost(host,encoding));
    }
    if (port != null) {
      sb.append(':');
      sb.append(encodePort(port,encoding));
    }
  }
  sb.append(encodePath(path,encoding));
  if (query != null) {
    sb.append('?');
    sb.append(encodeQuery(query,encoding));
  }
  if (fragment != null) {
    sb.append('#');
    sb.append(encodeFragment(fragment,encoding));
  }
  return sb.toString();
}
"
"/** 
 * Encodes the given source URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre class=""code""> UriComponents uriComponents = UriComponentsBuilder.fromUri(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param uri the URI to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeUri(String uri,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(uri,""'uri' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=URI_PATTERN.matcher(uri);
  if (m.matches()) {
    String scheme=m.group(2);
    String authority=m.group(3);
    String userinfo=m.group(5);
    String host=m.group(6);
    String port=m.group(8);
    String path=m.group(9);
    String query=m.group(11);
    String fragment=m.group(13);
    return encodeUriComponents(scheme,authority,userinfo,host,port,path,query,fragment,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + uri + ""] is not a valid URI"");
  }
}
"
"/** 
 * Encodes the given HTTP URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not support fragments ( {@code #}), as these are not supposed to be sent to the server, but retained by the client. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre class=""code""> UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param httpUrl the HTTP URL to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URL
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeHttpUrl(String httpUrl,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(httpUrl,""'httpUrl' must not be null"");
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  Matcher m=HTTP_URL_PATTERN.matcher(httpUrl);
  if (m.matches()) {
    String scheme=m.group(1);
    String authority=m.group(2);
    String userinfo=m.group(4);
    String host=m.group(5);
    String portString=m.group(7);
    String path=m.group(8);
    String query=m.group(10);
    return encodeUriComponents(scheme,authority,userinfo,host,portString,path,query,null,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + httpUrl + ""] is not a valid HTTP URL"");
  }
}
"
"/** 
 * Encodes the given source URI components into an encoded String. All various URI components are optional, but encoded according to their respective valid character sets.
 * @param scheme the scheme
 * @param authority the authority
 * @param userInfo the user info
 * @param host the host
 * @param port the port
 * @param path the path
 * @param query the query
 * @param fragment the fragment
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}
 */
@Deprecated public static String encodeUriComponents(String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,String encoding) throws UnsupportedEncodingException {
  Assert.hasLength(encoding,""'encoding' must not be empty"");
  StringBuilder sb=new StringBuilder();
  if (scheme != null) {
    sb.append(encodeScheme(scheme,encoding));
    sb.append(':');
  }
  if (authority != null) {
    sb.append(""//"");
    if (userInfo != null) {
      sb.append(encodeUserInfo(userInfo,encoding));
      sb.append('@');
    }
    if (host != null) {
      sb.append(encodeHost(host,encoding));
    }
    if (port != null) {
      sb.append(':');
      sb.append(encodePort(port,encoding));
    }
  }
  sb.append(encodePath(path,encoding));
  if (query != null) {
    sb.append('?');
    sb.append(encodeQuery(query,encoding));
  }
  if (fragment != null) {
    sb.append('#');
    sb.append(encodeFragment(fragment,encoding));
  }
  return sb.toString();
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Determine the target type for the given parameter specification.
 * @param methodParam the method parameter specification
 * @return the corresponding generic parameter type
 * @deprecated as of Spring 4.0 use {@link MethodParameter#getGenericParameterType()}
 */
@Deprecated public static Type getTargetType(MethodParameter methodParam){
  Assert.notNull(methodParam,""MethodParameter must not be null"");
  return methodParam.getGenericParameterType();
}
"
"/** 
 * Resolve the specified generic type against the given TypeVariable map.
 * @param genericType the generic type to resolve
 * @param typeVariableMap the TypeVariable Map to resolved against
 * @return the type if it resolves to a Class, or {@code Object.class} otherwise
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated public static Class<?> resolveType(Type genericType,Map<TypeVariable,Type> typeVariableMap){
  TypeVariableResolver variableResolver=new TypeVariableMapResolver(typeVariableMap);
  Class<?> resolved=ResolvableType.forType(genericType,variableResolver).resolve();
  return (resolved == null ? Object.class : resolved);
}
"
"/** 
 * Build a mapping of  {@link TypeVariable#getName TypeVariable names} to{@link Class concrete classes} for the specified {@link Class}. Searches all super types, enclosing types and interfaces.
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated public static Map<TypeVariable,Type> getTypeVariableMap(Class<?> clazz){
  Map<TypeVariable,Type> typeVariableMap=typeVariableCache.get(clazz);
  if (typeVariableMap == null) {
    typeVariableMap=new HashMap<TypeVariable,Type>();
    buildTypeVaraibleMap(ResolvableType.forClass(clazz),typeVariableMap);
    typeVariableCache.put(clazz,Collections.unmodifiableMap(typeVariableMap));
  }
  return typeVariableMap;
}
"
"/** 
 * Determine the generic element type of the given Collection field.
 * @param collectionField the collection field to introspect
 * @param nestingLevel the nesting level of the target type(typically 1; e.g. in case of a List of Lists, 1 would indicate the nested List, whereas 2 would indicate the element of the nested List)
 * @param typeIndexesPerLevel Map keyed by nesting level, with each valueexpressing the type index for traversal at that level
 * @return the generic type, or {@code null} if none
 * @deprecated as of 4.0 in favor of using {@link ResolvableType} for arbitrary nesting levels
 */
@Deprecated public static Class<?> getCollectionFieldType(Field collectionField,int nestingLevel,Map<Integer,Integer> typeIndexesPerLevel){
  return ResolvableType.forField(collectionField).getNested(nestingLevel,typeIndexesPerLevel).asCollection().resolveGeneric();
}
"
"/** 
 * Determine the generic key type of the given Map field.
 * @param mapField the map field to introspect
 * @param nestingLevel the nesting level of the target type(typically 1; e.g. in case of a List of Lists, 1 would indicate the nested List, whereas 2 would indicate the element of the nested List)
 * @param typeIndexesPerLevel Map keyed by nesting level, with each valueexpressing the type index for traversal at that level
 * @return the generic type, or {@code null} if none
 * @deprecated as of 4.0 in favor of using {@link ResolvableType} for arbitrary nesting levels
 */
@Deprecated public static Class<?> getMapKeyFieldType(Field mapField,int nestingLevel,Map<Integer,Integer> typeIndexesPerLevel){
  return ResolvableType.forField(mapField).getNested(nestingLevel,typeIndexesPerLevel).asMap().resolveGeneric(0);
}
"
"/** 
 * Determine the generic value type of the given Map field.
 * @param mapField the map field to introspect
 * @param nestingLevel the nesting level of the target type(typically 1; e.g. in case of a List of Lists, 1 would indicate the nested List, whereas 2 would indicate the element of the nested List)
 * @param typeIndexesPerLevel Map keyed by nesting level, with each valueexpressing the type index for traversal at that level
 * @return the generic type, or {@code null} if none
 * @deprecated as of 4.0 in favor of using {@link ResolvableType} for arbitrary nesting levels
 */
@Deprecated public static Class<?> getMapValueFieldType(Field mapField,int nestingLevel,Map<Integer,Integer> typeIndexesPerLevel){
  return ResolvableType.forField(mapField).getNested(nestingLevel,typeIndexesPerLevel).asMap().resolveGeneric(1);
}
"
"/** 
 * Determine the generic element type of the given Collection field.
 * @param collectionField the collection field to introspect
 * @param nestingLevel the nesting level of the target type(typically 1; e.g. in case of a List of Lists, 1 would indicate the nested List, whereas 2 would indicate the element of the nested List)
 * @param typeIndexesPerLevel Map keyed by nesting level, with each valueexpressing the type index for traversal at that level
 * @return the generic type, or {@code null} if none
 * @deprecated as of 4.0, in favor of using {@link ResolvableType} for arbitrary nesting levels
 */
@Deprecated public static Class<?> getCollectionFieldType(Field collectionField,int nestingLevel,Map<Integer,Integer> typeIndexesPerLevel){
  return ResolvableType.forField(collectionField).getNested(nestingLevel,typeIndexesPerLevel).asCollection().resolveGeneric();
}
"
"/** 
 * Determine the generic key type of the given Map field.
 * @param mapField the map field to introspect
 * @param nestingLevel the nesting level of the target type(typically 1; e.g. in case of a List of Lists, 1 would indicate the nested List, whereas 2 would indicate the element of the nested List)
 * @param typeIndexesPerLevel Map keyed by nesting level, with each valueexpressing the type index for traversal at that level
 * @return the generic type, or {@code null} if none
 * @deprecated as of 4.0, in favor of using {@link ResolvableType} for arbitrary nesting levels
 */
@Deprecated public static Class<?> getMapKeyFieldType(Field mapField,int nestingLevel,Map<Integer,Integer> typeIndexesPerLevel){
  return ResolvableType.forField(mapField).getNested(nestingLevel,typeIndexesPerLevel).asMap().resolveGeneric(0);
}
"
"/** 
 * Determine the generic value type of the given Map field.
 * @param mapField the map field to introspect
 * @param nestingLevel the nesting level of the target type(typically 1; e.g. in case of a List of Lists, 1 would indicate the nested List, whereas 2 would indicate the element of the nested List)
 * @param typeIndexesPerLevel Map keyed by nesting level, with each valueexpressing the type index for traversal at that level
 * @return the generic type, or {@code null} if none
 * @deprecated as of 4.0, in favor of using {@link ResolvableType} for arbitrary nesting levels
 */
@Deprecated public static Class<?> getMapValueFieldType(Field mapField,int nestingLevel,Map<Integer,Integer> typeIndexesPerLevel){
  return ResolvableType.forField(mapField).getNested(nestingLevel,typeIndexesPerLevel).asMap().resolveGeneric(1);
}
"
"/** 
 * Determine the target type for the given parameter specification.
 * @param methodParam the method parameter specification
 * @return the corresponding generic parameter type
 * @deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()}
 */
@Deprecated public static Type getTargetType(MethodParameter methodParam){
  Assert.notNull(methodParam,""MethodParameter must not be null"");
  return methodParam.getGenericParameterType();
}
"
"/** 
 * Resolve the specified generic type against the given TypeVariable map.
 * @param genericType the generic type to resolve
 * @param typeVariableMap the TypeVariable Map to resolved against
 * @return the type if it resolves to a Class, or {@code Object.class} otherwise
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated public static Class<?> resolveType(Type genericType,Map<TypeVariable,Type> typeVariableMap){
  TypeVariableResolver variableResolver=new TypeVariableMapResolver(typeVariableMap);
  Class<?> resolved=ResolvableType.forType(genericType,variableResolver).resolve();
  return (resolved == null ? Object.class : resolved);
}
"
"/** 
 * Build a mapping of  {@link TypeVariable#getName TypeVariable names} to{@link Class concrete classes} for the specified {@link Class}. Searches all super types, enclosing types and interfaces.
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated public static Map<TypeVariable,Type> getTypeVariableMap(Class<?> clazz){
  Map<TypeVariable,Type> typeVariableMap=typeVariableCache.get(clazz);
  if (typeVariableMap == null) {
    typeVariableMap=new HashMap<TypeVariable,Type>();
    buildTypeVariableMap(ResolvableType.forClass(clazz),typeVariableMap);
    typeVariableCache.put(clazz,Collections.unmodifiableMap(typeVariableMap));
  }
  return typeVariableMap;
}
"
"/** 
 * Determine the target type for the given parameter specification.
 * @param methodParam the method parameter specification
 * @return the corresponding generic parameter type
 * @deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()}
 */
@Deprecated public static Type getTargetType(MethodParameter methodParam){
  Assert.notNull(methodParam,""MethodParameter must not be null"");
  return methodParam.getGenericParameterType();
}
"
"/** 
 * Resolve the specified generic type against the given TypeVariable map.
 * @param genericType the generic type to resolve
 * @param typeVariableMap the TypeVariable Map to resolved against
 * @return the type if it resolves to a Class, or {@code Object.class} otherwise
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated public static Class<?> resolveType(Type genericType,Map<TypeVariable,Type> typeVariableMap){
  TypeVariableResolver variableResolver=new TypeVariableMapResolver(typeVariableMap);
  Class<?> resolved=ResolvableType.forType(genericType,variableResolver).resolve();
  return (resolved == null ? Object.class : resolved);
}
"
"/** 
 * Build a mapping of  {@link TypeVariable#getName TypeVariable names} to{@link Class concrete classes} for the specified {@link Class}. Searches all super types, enclosing types and interfaces.
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated public static Map<TypeVariable,Type> getTypeVariableMap(Class<?> clazz){
  Map<TypeVariable,Type> typeVariableMap=typeVariableCache.get(clazz);
  if (typeVariableMap == null) {
    typeVariableMap=new HashMap<TypeVariable,Type>();
    buildTypeVariableMap(ResolvableType.forClass(clazz),typeVariableMap);
    typeVariableCache.put(clazz,Collections.unmodifiableMap(typeVariableMap));
  }
  return typeVariableMap;
}
"
"/** 
 * Determine the target type for the given parameter specification.
 * @param methodParam the method parameter specification
 * @return the corresponding generic parameter type
 * @deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()}
 */
@Deprecated public static Type getTargetType(MethodParameter methodParam){
  Assert.notNull(methodParam,""MethodParameter must not be null"");
  return methodParam.getGenericParameterType();
}
"
"/** 
 * Resolve the specified generic type against the given TypeVariable map.
 * @param genericType the generic type to resolve
 * @param typeVariableMap the TypeVariable Map to resolved against
 * @return the type if it resolves to a Class, or {@code Object.class} otherwise
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated public static Class<?> resolveType(Type genericType,Map<TypeVariable,Type> typeVariableMap){
  TypeVariableResolver variableResolver=new TypeVariableMapResolver(typeVariableMap);
  Class<?> resolved=ResolvableType.forType(genericType,variableResolver).resolve();
  return (resolved == null ? Object.class : resolved);
}
"
"/** 
 * Build a mapping of  {@link TypeVariable#getName TypeVariable names} to{@link Class concrete classes} for the specified {@link Class}. Searches all super types, enclosing types and interfaces.
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated public static Map<TypeVariable,Type> getTypeVariableMap(Class<?> clazz){
  Map<TypeVariable,Type> typeVariableMap=typeVariableCache.get(clazz);
  if (typeVariableMap == null) {
    typeVariableMap=new HashMap<TypeVariable,Type>();
    buildTypeVariableMap(ResolvableType.forClass(clazz),typeVariableMap);
    typeVariableCache.put(clazz,Collections.unmodifiableMap(typeVariableMap));
  }
  return typeVariableMap;
}
"
"/** 
 * Determine the target type for the generic return type of the given <em>generic method</em>, where formal type variables are declared on the given method itself. <p>For example, given a factory method with the following signature, if  {@code resolveReturnTypeForGenericMethod()} is invoked with the reflectedmethod for  {@code creatProxy()} and an {@code Object[]} array containing{@code MyService.class},  {@code resolveReturnTypeForGenericMethod()} willinfer that the target return type is  {@code MyService}. <pre> {@code public static <T> T createProxy(Class<T> clazz)}</pre> <h4>Possible Return Values</h4> <ul> <li>the target return type, if it can be inferred</li> <li>the  {@linkplain Method#getReturnType() standard return type}, if the given  {@code method} does not declare any {@linkplain Method#getTypeParameters() formal type variables}</li> <li>the  {@linkplain Method#getReturnType() standard return type}, if the target return type cannot be inferred (e.g., due to type erasure)</li> <li> {@code null}, if the length of the given arguments array is shorter than the length of the  {@linkplain Method#getGenericParameterTypes() formal argument list} for the givenmethod</li> </ul>
 * @param method the method to introspect, never {@code null}
 * @param args the arguments that will be supplied to the method when it isinvoked, never  {@code null}
 * @return the resolved target return type, the standard return type, or {@code null}
 * @since 3.2
 * @deprecated in favor of resolveReturnTypeForFactoryMethod in the internalAutowireUtils class in the beans module; we do not expect other use of it!
 */
@Deprecated public static Class<?> resolveReturnTypeForGenericMethod(Method method,Object[] args){
  Assert.notNull(method,""Method must not be null"");
  Assert.notNull(args,""Argument array must not be null"");
  TypeVariable<Method>[] declaredTypeVariables=method.getTypeParameters();
  Type genericReturnType=method.getGenericReturnType();
  Type[] methodArgumentTypes=method.getGenericParameterTypes();
  if (declaredTypeVariables.length == 0) {
    return method.getReturnType();
  }
  if (args.length < methodArgumentTypes.length) {
    return null;
  }
  boolean locallyDeclaredTypeVariableMatchesReturnType=false;
  for (  TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {
    if (currentTypeVariable.equals(genericReturnType)) {
      locallyDeclaredTypeVariableMatchesReturnType=true;
      break;
    }
  }
  if (locallyDeclaredTypeVariableMatchesReturnType) {
    for (int i=0; i < methodArgumentTypes.length; i++) {
      Type currentMethodArgumentType=methodArgumentTypes[i];
      if (currentMethodArgumentType.equals(genericReturnType)) {
        return args[i].getClass();
      }
      if (currentMethodArgumentType instanceof ParameterizedType) {
        ParameterizedType parameterizedType=(ParameterizedType)currentMethodArgumentType;
        Type[] actualTypeArguments=parameterizedType.getActualTypeArguments();
        for (        Type typeArg : actualTypeArguments) {
          if (typeArg.equals(genericReturnType)) {
            if (args[i] instanceof Class) {
              return (Class<?>)args[i];
            }
 else {
              return method.getReturnType();
            }
          }
        }
      }
    }
  }
  return method.getReturnType();
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Determine the target type for the given parameter specification.
 * @param methodParam the method parameter specification
 * @return the corresponding generic parameter type
 * @deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()}
 */
@Deprecated public static Type getTargetType(MethodParameter methodParam){
  Assert.notNull(methodParam,""MethodParameter must not be null"");
  return methodParam.getGenericParameterType();
}
"
"/** 
 * Resolve the specified generic type against the given TypeVariable map.
 * @param genericType the generic type to resolve
 * @param typeVariableMap the TypeVariable Map to resolved against
 * @return the type if it resolves to a Class, or {@code Object.class} otherwise
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated public static Class<?> resolveType(Type genericType,final Map<TypeVariable,Type> typeVariableMap){
  ResolvableType.VariableResolver variableResolver=new ResolvableType.VariableResolver(){
    @Override public ResolvableType resolveVariable(    TypeVariable<?> variable){
      Type type=typeVariableMap.get(variable);
      return (type == null ? null : ResolvableType.forType(type));
    }
    @Override public Object getSource(){
      return typeVariableMap;
    }
  }
;
  return ResolvableType.forType(genericType,variableResolver).resolve(Object.class);
}
"
"/** 
 * Build a mapping of  {@link TypeVariable#getName TypeVariable names} to{@link Class concrete classes} for the specified {@link Class}. Searches all super types, enclosing types and interfaces.
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated public static Map<TypeVariable,Type> getTypeVariableMap(Class<?> clazz){
  Map<TypeVariable,Type> typeVariableMap=typeVariableCache.get(clazz);
  if (typeVariableMap == null) {
    typeVariableMap=new HashMap<TypeVariable,Type>();
    buildTypeVariableMap(ResolvableType.forClass(clazz),typeVariableMap);
    typeVariableCache.put(clazz,Collections.unmodifiableMap(typeVariableMap));
  }
  return typeVariableMap;
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Determine the target type for the given parameter specification.
 * @param methodParam the method parameter specification
 * @return the corresponding generic parameter type
 * @deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()}
 */
@Deprecated public static Type getTargetType(MethodParameter methodParam){
  Assert.notNull(methodParam,""MethodParameter must not be null"");
  return methodParam.getGenericParameterType();
}
"
"/** 
 * Resolve the specified generic type against the given TypeVariable map.
 * @param genericType the generic type to resolve
 * @param map the TypeVariable Map to resolved against
 * @return the type if it resolves to a Class, or {@code Object.class} otherwise
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated public static Class<?> resolveType(Type genericType,Map<TypeVariable,Type> map){
  return ResolvableType.forType(genericType,new TypeVariableMapVariableResolver(map)).resolve(Object.class);
}
"
"/** 
 * Build a mapping of  {@link TypeVariable#getName TypeVariable names} to{@link Class concrete classes} for the specified {@link Class}. Searches all super types, enclosing types and interfaces.
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated public static Map<TypeVariable,Type> getTypeVariableMap(Class<?> clazz){
  Map<TypeVariable,Type> typeVariableMap=typeVariableCache.get(clazz);
  if (typeVariableMap == null) {
    typeVariableMap=new HashMap<TypeVariable,Type>();
    buildTypeVariableMap(ResolvableType.forClass(clazz),typeVariableMap);
    typeVariableCache.put(clazz,Collections.unmodifiableMap(typeVariableMap));
  }
  return typeVariableMap;
}
"
"/** 
 * Determine the target type for the given parameter specification.
 * @param methodParam the method parameter specification
 * @return the corresponding generic parameter type
 * @deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()}
 */
@Deprecated public static Type getTargetType(MethodParameter methodParam){
  Assert.notNull(methodParam,""MethodParameter must not be null"");
  return methodParam.getGenericParameterType();
}
"
"/** 
 * Resolve the specified generic type against the given TypeVariable map.
 * @param genericType the generic type to resolve
 * @param map the TypeVariable Map to resolved against
 * @return the type if it resolves to a Class, or {@code Object.class} otherwise
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated public static Class<?> resolveType(Type genericType,Map<TypeVariable,Type> map){
  return ResolvableType.forType(genericType,new TypeVariableMapVariableResolver(map)).resolve(Object.class);
}
"
"/** 
 * Build a mapping of  {@link TypeVariable#getName TypeVariable names} to{@link Class concrete classes} for the specified {@link Class}. Searches all super types, enclosing types and interfaces.
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated public static Map<TypeVariable,Type> getTypeVariableMap(Class<?> clazz){
  Map<TypeVariable,Type> typeVariableMap=typeVariableCache.get(clazz);
  if (typeVariableMap == null) {
    typeVariableMap=new HashMap<TypeVariable,Type>();
    buildTypeVariableMap(ResolvableType.forClass(clazz),typeVariableMap);
    typeVariableCache.put(clazz,Collections.unmodifiableMap(typeVariableMap));
  }
  return typeVariableMap;
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Replacement for  {@code Class.forName()} that also returns Class instancesfor primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return  {@code false} if either the class orone of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Determine the target type for the generic return type of the given <em>generic method</em>, where formal type variables are declared on the given method itself. <p>For example, given a factory method with the following signature, if  {@code resolveReturnTypeForGenericMethod()} is invoked with the reflectedmethod for  {@code creatProxy()} and an {@code Object[]} array containing{@code MyService.class},  {@code resolveReturnTypeForGenericMethod()} willinfer that the target return type is  {@code MyService}. <pre> {@code public static <T> T createProxy(Class<T> clazz)}</pre> <h4>Possible Return Values</h4> <ul> <li>the target return type, if it can be inferred</li> <li>the  {@linkplain Method#getReturnType() standard return type}, if the given  {@code method} does not declare any {@linkplain Method#getTypeParameters() formal type variables}</li> <li>the  {@linkplain Method#getReturnType() standard return type}, if the target return type cannot be inferred (e.g., due to type erasure)</li> <li> {@code null}, if the length of the given arguments array is shorter than the length of the  {@linkplain Method#getGenericParameterTypes() formal argument list} for the givenmethod</li> </ul>
 * @param method the method to introspect, never {@code null}
 * @param args the arguments that will be supplied to the method when it isinvoked, never  {@code null}
 * @return the resolved target return type, the standard return type, or {@code null}
 * @since 3.2
 * @deprecated in favor of resolveReturnTypeForFactoryMethod in the internalAutowireUtils class in the beans module; we do not expect other use of it!
 */
@Deprecated public static Class<?> resolveReturnTypeForGenericMethod(Method method,Object[] args){
  Assert.notNull(method,""Method must not be null"");
  Assert.notNull(args,""Argument array must not be null"");
  TypeVariable<Method>[] declaredTypeVariables=method.getTypeParameters();
  Type genericReturnType=method.getGenericReturnType();
  Type[] methodArgumentTypes=method.getGenericParameterTypes();
  if (declaredTypeVariables.length == 0) {
    return method.getReturnType();
  }
  if (args.length < methodArgumentTypes.length) {
    return null;
  }
  boolean locallyDeclaredTypeVariableMatchesReturnType=false;
  for (  TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {
    if (currentTypeVariable.equals(genericReturnType)) {
      locallyDeclaredTypeVariableMatchesReturnType=true;
      break;
    }
  }
  if (locallyDeclaredTypeVariableMatchesReturnType) {
    for (int i=0; i < methodArgumentTypes.length; i++) {
      Type currentMethodArgumentType=methodArgumentTypes[i];
      if (currentMethodArgumentType.equals(genericReturnType)) {
        return args[i].getClass();
      }
      if (currentMethodArgumentType instanceof ParameterizedType) {
        ParameterizedType parameterizedType=(ParameterizedType)currentMethodArgumentType;
        Type[] actualTypeArguments=parameterizedType.getActualTypeArguments();
        for (        Type typeArg : actualTypeArguments) {
          if (typeArg.equals(genericReturnType)) {
            if (args[i] instanceof Class) {
              return (Class<?>)args[i];
            }
 else {
              return method.getReturnType();
            }
          }
        }
      }
    }
  }
  return method.getReturnType();
}
"
"/** 
 * Determine the target type for the given parameter specification.
 * @param methodParam the method parameter specification
 * @return the corresponding generic parameter type
 * @deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()}
 */
@Deprecated public static Type getTargetType(MethodParameter methodParam){
  Assert.notNull(methodParam,""MethodParameter must not be null"");
  return methodParam.getGenericParameterType();
}
"
"/** 
 * Resolve the specified generic type against the given TypeVariable map.
 * @param genericType the generic type to resolve
 * @param map the TypeVariable Map to resolved against
 * @return the type if it resolves to a Class, or {@code Object.class} otherwise
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated public static Class<?> resolveType(Type genericType,Map<TypeVariable,Type> map){
  return ResolvableType.forType(genericType,new TypeVariableMapVariableResolver(map)).resolve(Object.class);
}
"
"/** 
 * Build a mapping of  {@link TypeVariable#getName TypeVariable names} to{@link Class concrete classes} for the specified {@link Class}. Searches all super types, enclosing types and interfaces.
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated public static Map<TypeVariable,Type> getTypeVariableMap(Class<?> clazz){
  Map<TypeVariable,Type> typeVariableMap=typeVariableCache.get(clazz);
  if (typeVariableMap == null) {
    typeVariableMap=new HashMap<TypeVariable,Type>();
    buildTypeVariableMap(ResolvableType.forClass(clazz),typeVariableMap);
    typeVariableCache.put(clazz,Collections.unmodifiableMap(typeVariableMap));
  }
  return typeVariableMap;
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of HttpStatus.METHOD_FAILURE
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of HttpStatus.DESTINATION_LOCKED
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of HttpStatus.METHOD_FAILURE
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of HttpStatus.DESTINATION_LOCKED
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorPathExtension(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    Properties props=new Properties();
    props.putAll(mediaTypes);
    this.cnManagerFactoryBean.setMediaTypes(props);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorPathExtension(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    Properties props=new Properties();
    props.putAll(mediaTypes);
    this.cnManagerFactoryBean.setMediaTypes(props);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Check whether the specified class is a CGLIB-generated class.
 * @param clazz the class to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)}
 */
@Deprecated public static boolean isCglibProxyClass(Class<?> clazz){
  return ClassUtils.isCglibProxyClass(clazz);
}
"
"/** 
 * Check whether the specified class name is a CGLIB-generated class.
 * @param className the class name to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)}
 */
@Deprecated public static boolean isCglibProxyClassName(String className){
  return ClassUtils.isCglibProxyClassName(className);
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Determine the generic element type of the given Collection field.
 * @param collectionField the collection field to introspect
 * @param nestingLevel the nesting level of the target type(typically 1; e.g. in case of a List of Lists, 1 would indicate the nested List, whereas 2 would indicate the element of the nested List)
 * @param typeIndexesPerLevel Map keyed by nesting level, with each valueexpressing the type index for traversal at that level
 * @return the generic type, or {@code null} if none
 * @deprecated as of 4.0, in favor of using {@link ResolvableType} for arbitrary nesting levels
 */
@Deprecated public static Class<?> getCollectionFieldType(Field collectionField,int nestingLevel,Map<Integer,Integer> typeIndexesPerLevel){
  return ResolvableType.forField(collectionField).getNested(nestingLevel,typeIndexesPerLevel).asCollection().resolveGeneric();
}
"
"/** 
 * Determine the generic key type of the given Map field.
 * @param mapField the map field to introspect
 * @param nestingLevel the nesting level of the target type(typically 1; e.g. in case of a List of Lists, 1 would indicate the nested List, whereas 2 would indicate the element of the nested List)
 * @param typeIndexesPerLevel Map keyed by nesting level, with each valueexpressing the type index for traversal at that level
 * @return the generic type, or {@code null} if none
 * @deprecated as of 4.0, in favor of using {@link ResolvableType} for arbitrary nesting levels
 */
@Deprecated public static Class<?> getMapKeyFieldType(Field mapField,int nestingLevel,Map<Integer,Integer> typeIndexesPerLevel){
  return ResolvableType.forField(mapField).getNested(nestingLevel,typeIndexesPerLevel).asMap().resolveGeneric(0);
}
"
"/** 
 * Determine the generic value type of the given Map field.
 * @param mapField the map field to introspect
 * @param nestingLevel the nesting level of the target type(typically 1; e.g. in case of a List of Lists, 1 would indicate the nested List, whereas 2 would indicate the element of the nested List)
 * @param typeIndexesPerLevel Map keyed by nesting level, with each valueexpressing the type index for traversal at that level
 * @return the generic type, or {@code null} if none
 * @deprecated as of 4.0, in favor of using {@link ResolvableType} for arbitrary nesting levels
 */
@Deprecated public static Class<?> getMapValueFieldType(Field mapField,int nestingLevel,Map<Integer,Integer> typeIndexesPerLevel){
  return ResolvableType.forField(mapField).getNested(nestingLevel,typeIndexesPerLevel).asMap().resolveGeneric(1);
}
"
"/** 
 * Determine the target type for the given parameter specification.
 * @param methodParam the method parameter specification
 * @return the corresponding generic parameter type
 * @deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()}
 */
@Deprecated public static Type getTargetType(MethodParameter methodParam){
  Assert.notNull(methodParam,""MethodParameter must not be null"");
  return methodParam.getGenericParameterType();
}
"
"/** 
 * Resolve the specified generic type against the given TypeVariable map.
 * @param genericType the generic type to resolve
 * @param map the TypeVariable Map to resolved against
 * @return the type if it resolves to a Class, or {@code Object.class} otherwise
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated @SuppressWarnings(""rawtypes"") public static Class<?> resolveType(Type genericType,Map<TypeVariable,Type> map){
  return ResolvableType.forType(genericType,new TypeVariableMapVariableResolver(map)).resolve(Object.class);
}
"
"/** 
 * Build a mapping of  {@link TypeVariable#getName TypeVariable names} to{@link Class concrete classes} for the specified {@link Class}. Searches all super types, enclosing types and interfaces.
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated @SuppressWarnings(""rawtypes"") public static Map<TypeVariable,Type> getTypeVariableMap(Class<?> clazz){
  Map<TypeVariable,Type> typeVariableMap=typeVariableCache.get(clazz);
  if (typeVariableMap == null) {
    typeVariableMap=new HashMap<TypeVariable,Type>();
    buildTypeVariableMap(ResolvableType.forClass(clazz),typeVariableMap);
    typeVariableCache.put(clazz,Collections.unmodifiableMap(typeVariableMap));
  }
  return typeVariableMap;
}
"
"/** 
 * Construct a new  {@link ContextConfigurationAttributes} instance for the{@linkplain Class test class} that declared the{@link ContextConfiguration @ContextConfiguration} annotation and itscorresponding attributes.
 * @param declaringClass the test class that declared {@code @ContextConfiguration}
 * @param locations the resource locations declared via {@code @ContextConfiguration}
 * @param classes the annotated classes declared via {@code @ContextConfiguration}
 * @param inheritLocations the {@code inheritLocations} flag declared via {@code @ContextConfiguration}
 * @param contextLoaderClass the {@code ContextLoader} class declared via {@code @ContextConfiguration}
 * @throws IllegalArgumentException if the {@code declaringClass} or {@code contextLoaderClass} is{@code null}, or if the  {@code locations} and {@code classes} are both non-empty
 * @deprecated as of Spring 3.2, use{@link #ContextConfigurationAttributes(Class,String[],Class[],boolean,Class[],boolean,String,Class)}instead
 */
@Deprecated public ContextConfigurationAttributes(Class<?> declaringClass,String[] locations,Class<?>[] classes,boolean inheritLocations,Class<? extends ContextLoader> contextLoaderClass){
  this(declaringClass,locations,classes,inheritLocations,null,true,null,contextLoaderClass);
}
"
"/** 
 * Construct a new  {@link ContextConfigurationAttributes} instance for the{@linkplain Class test class} that declared the{@link ContextConfiguration @ContextConfiguration} annotation and itscorresponding attributes.
 * @param declaringClass the test class that declared {@code @ContextConfiguration}
 * @param locations the resource locations declared via {@code @ContextConfiguration}
 * @param classes the annotated classes declared via {@code @ContextConfiguration}
 * @param inheritLocations the {@code inheritLocations} flag declared via {@code @ContextConfiguration}
 * @param contextLoaderClass the {@code ContextLoader} class declared via {@code @ContextConfiguration}
 * @throws IllegalArgumentException if the {@code declaringClass} or {@code contextLoaderClass} is{@code null}, or if the  {@code locations} and {@code classes} are both non-empty
 * @deprecated as of Spring 3.2, use{@link #ContextConfigurationAttributes(Class,String[],Class[],boolean,Class[],boolean,String,Class)}instead
 */
@Deprecated public ContextConfigurationAttributes(Class<?> declaringClass,String[] locations,Class<?>[] classes,boolean inheritLocations,Class<? extends ContextLoader> contextLoaderClass){
  this(declaringClass,locations,classes,inheritLocations,null,true,null,contextLoaderClass);
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Replacement for  {@code Class.forName()} that also returns Class instancesfor primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return  {@code false} if either the class orone of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Call this method to signal that the  {@linkplain ApplicationContext applicationcontext} associated with this test context is <em>dirty</em> and should bediscarded. Do this if a test has modified the context &mdash; for example, by replacing a bean definition or modifying the state of a singleton bean.
 * @deprecated as of Spring 3.2.2; use{@link #markApplicationContextDirty(DirtiesContext.HierarchyMode)} instead.
 */
@Deprecated public void markApplicationContextDirty(){
  markApplicationContextDirty((HierarchyMode)null);
}
"
"/** 
 * Set the registration behavior by the name of the corresponding constant, e.g. ""REGISTRATION_IGNORE_EXISTING"".
 * @see #setRegistrationBehavior
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehaviorName(String registrationBehavior){
  setRegistrationBehavior(constants.asNumber(registrationBehavior).intValue());
}
"
"/** 
 * Specify what action should be taken when attempting to register an MBean under an  {@link javax.management.ObjectName} that already exists.<p>Default is REGISTRATION_FAIL_ON_EXISTING.
 * @see #setRegistrationBehaviorName(String)
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehavior(int registrationBehavior){
  setRegistrationPolicy(RegistrationPolicy.valueOf(registrationBehavior));
}
"
"/** 
 * Set the registration behavior by the name of the corresponding constant, e.g. ""REGISTRATION_IGNORE_EXISTING"".
 * @see #setRegistrationBehavior
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehaviorName(String registrationBehavior){
  setRegistrationBehavior(constants.asNumber(registrationBehavior).intValue());
}
"
"/** 
 * Specify what action should be taken when attempting to register an MBean under an  {@link javax.management.ObjectName} that already exists.<p>Default is REGISTRATION_FAIL_ON_EXISTING.
 * @see #setRegistrationBehaviorName(String)
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehavior(int registrationBehavior){
  setRegistrationPolicy(RegistrationPolicy.valueOf(registrationBehavior));
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Determines if there is a type converter available in the specified context and attempts to use it to convert the supplied value to the specified type. Throws an exception if conversion is not possible.
 * @param context the evaluation context that may define a type converter
 * @param value the value to convert (may be null)
 * @param targetType the type to attempt conversion to
 * @return the converted value
 * @throws EvaluationException if there is a problem during conversion or conversionof the value to the specified type is not supported
 * @deprecated use {@link #convertTypedValue(EvaluationContext,TypedValue,Class)}
 */
@Deprecated public static <T>T convert(EvaluationContext context,Object value,Class<T> targetType) throws EvaluationException {
  return convertTypedValue(context,new TypedValue(value),targetType);
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Set a list of TriggerListener names for this job, referring to non-global TriggerListeners registered with the Scheduler. <p>A TriggerListener name always refers to the name returned by the TriggerListener implementation.
 * @see SchedulerFactoryBean#setTriggerListeners
 * @see org.quartz.TriggerListener#getName
 * @deprecated as of Spring 4.0, since it only works on Quartz 1.x
 */
@Deprecated public void setTriggerListenerNames(String... names){
  for (  String name : names) {
    addTriggerListener(name);
  }
}
"
"/** 
 * Set a list of JobListener names for this job, referring to non-global JobListeners registered with the Scheduler. <p>A JobListener name always refers to the name returned by the JobListener implementation.
 * @see SchedulerFactoryBean#setJobListeners
 * @see org.quartz.JobListener#getName
 * @deprecated as of Spring 4.0, since it only works on Quartz 1.x
 */
@Deprecated public void setJobListenerNames(String... names){
  for (  String name : names) {
    addJobListener(name);
  }
}
"
"/** 
 * Set a list of JobListener names for this job, referring to non-global JobListeners registered with the Scheduler. <p>A JobListener name always refers to the name returned by the JobListener implementation.
 * @see SchedulerFactoryBean#setJobListeners
 * @see org.quartz.JobListener#getName
 * @deprecated as of Spring 4.0, since it only works on Quartz 1.x
 */
@Deprecated public void setJobListenerNames(String... names){
  this.jobListenerNames=names;
}
"
"/** 
 * Specify named Quartz JobListeners to be registered with the Scheduler. Such JobListeners will only apply to Jobs that explicitly activate them via their name. <p>Note that non-global JobListeners are not supported on Quartz 2.x - manually register a Matcher against the Quartz ListenerManager instead.
 * @see org.quartz.JobListener#getName
 * @see JobDetailBean#setJobListenerNames
 * @deprecated as of Spring 4.0, since it only works on Quartz 1.x
 */
@Deprecated public void setJobListeners(JobListener... jobListeners){
  this.jobListeners=jobListeners;
}
"
"/** 
 * Specify named Quartz TriggerListeners to be registered with the Scheduler. Such TriggerListeners will only apply to Triggers that explicitly activate them via their name. <p>Note that non-global TriggerListeners are not supported on Quartz 2.x - manually register a Matcher against the Quartz ListenerManager instead.
 * @see org.quartz.TriggerListener#getName
 * @see CronTriggerBean#setTriggerListenerNames
 * @see SimpleTriggerBean#setTriggerListenerNames
 * @deprecated as of Spring 4.0, since it only works on Quartz 1.x
 */
@Deprecated public void setTriggerListeners(TriggerListener... triggerListeners){
  this.triggerListeners=triggerListeners;
}
"
"/** 
 * Set a list of TriggerListener names for this job, referring to non-global TriggerListeners registered with the Scheduler. <p>A TriggerListener name always refers to the name returned by the TriggerListener implementation.
 * @see SchedulerFactoryBean#setTriggerListeners
 * @see org.quartz.TriggerListener#getName
 * @deprecated as of Spring 4.0, since it only works on Quartz 1.x
 */
@Deprecated public void setTriggerListenerNames(String... names){
  for (  String name : names) {
    addTriggerListener(name);
  }
}
"
"/** 
 * Replacement for  {@code Class.forName()} that also returns Class instancesfor primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return  {@code false} if either the class orone of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status.
 * @param beanClass the class of the bean to instantiate
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,boolean singleton){
  super();
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, using the given autowire mode.
 * @param beanClass the class of the bean to instantiate
 * @param autowireMode by name or type, using the constants in this interface
 * @deprecated as of Spring 3.0, in favor of {@link #setAutowireMode} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,int autowireMode){
  super();
  setBeanClass(beanClass);
  setAutowireMode(autowireMode);
}
"
"/** 
 * Create a new RootBeanDefinition for a singleton, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @deprecated as of Spring 3.0, in favor of {@link #getPropertyValues} usage
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs){
  super(null,pvs);
  setBeanClass(beanClass);
}
"
"/** 
 * Create a new RootBeanDefinition with the given singleton status, providing property values.
 * @param beanClass the class of the bean to instantiate
 * @param pvs the property values to apply
 * @param singleton the singleton status of the bean
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 */
@Deprecated public RootBeanDefinition(Class beanClass,MutablePropertyValues pvs,boolean singleton){
  super(null,pvs);
  setBeanClass(beanClass);
  setSingleton(singleton);
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Set the Hibernate CacheProvider to use for the SessionFactory. Allows for using a Spring-managed CacheProvider instance. <p>Note: If this is set, the Hibernate settings should not define a cache provider to avoid meaningless double configuration.
 * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecationof the CacheProvider SPI
 * @see #setCacheRegionFactory
 */
@Deprecated public void setCacheProvider(org.hibernate.cache.CacheProvider cacheProvider){
  this.cacheProvider=cacheProvider;
}
"
"/** 
 * Specify named Quartz JobListeners to be registered with the Scheduler. Such JobListeners will only apply to Jobs that explicitly activate them via their name. <p>Note that non-global JobListeners are not supported on Quartz 2.x - manually register a Matcher against the Quartz ListenerManager instead.
 * @see org.quartz.JobListener#getName
 * @see JobDetailBean#setJobListenerNames
 * @deprecated as of Spring 4.0, since it only works on Quartz 1.x
 */
@Deprecated public void setJobListeners(JobListener... jobListeners){
  this.jobListeners=jobListeners;
}
"
"/** 
 * Specify named Quartz TriggerListeners to be registered with the Scheduler. Such TriggerListeners will only apply to Triggers that explicitly activate them via their name. <p>Note that non-global TriggerListeners are not supported on Quartz 2.x - manually register a Matcher against the Quartz ListenerManager instead.
 * @see org.quartz.TriggerListener#getName
 * @see CronTriggerBean#setTriggerListenerNames
 * @see SimpleTriggerBean#setTriggerListenerNames
 * @deprecated as of Spring 4.0, since it only works on Quartz 1.x
 */
@Deprecated public void setTriggerListeners(TriggerListener... triggerListeners){
  this.triggerListeners=triggerListeners;
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the {@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Override settings in this bean definition (presumably a copied parent from a parent-child inheritance relationship) from the given bean definition (presumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of HttpStatus.METHOD_FAILURE
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of HttpStatus.DESTINATION_LOCKED
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Set the expected root object for the unmarshaller, into which the source will be unmarshalled.
 * @see org.exolab.castor.xml.Unmarshaller#setObject(Object)
 * @deprecated in favor of {@link #setRootObject}
 */
@Deprecated public void setObject(Object root){
  this.rootObject=root;
}
"
"/** 
 * Set the expected root object for the unmarshaller, into which the source will be unmarshalled.
 * @see org.exolab.castor.xml.Unmarshaller#setObject(Object)
 * @deprecated in favor of {@link #setRootObject}
 */
@Deprecated public void setObject(Object root){
  this.rootObject=root;
}
"
"/** 
 * Set the classes for which mappings will be read from class-level annotation metadata.
 * @see XStream#processAnnotations(Class)
 * @deprecated in favor of {@link #setAnnotatedClasses} with varargs
 */
@Deprecated public void setAnnotatedClass(Class<?> annotatedClass){
  Assert.notNull(annotatedClass,""'annotatedClass' must not be null"");
  getXStream().processAnnotations(annotatedClass);
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Collection} or array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resourceLoader the resource loader with which to load the SQL script
 * @param sqlResourcePath the Spring resource path for the SQL script
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see #executeSqlScript(JdbcTemplate,Resource,boolean)
 * @deprecated as of Spring 4.0.3, in favor of using {@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript(ScriptStatementExecutor,EncodedResource,boolean,boolean,String,String,String,String)}  
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,ResourceLoader resourceLoader,String sqlResourcePath,boolean continueOnError) throws DataAccessException {
  Resource resource=resourceLoader.getResource(sqlResourcePath);
  executeSqlScript(jdbcTemplate,resource,continueOnError);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. Statements should be delimited with a semicolon. If statements are not delimited with a semicolon then there should be one statement per line. Statements are allowed to span lines only if they are delimited with a semicolon. Any line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource to load the SQL script from
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see #executeSqlScript(JdbcTemplate,EncodedResource,boolean)
 * @deprecated as of Spring 4.0.3, in favor of using {@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript(ScriptStatementExecutor,EncodedResource,boolean,boolean,String,String,String,String)}  
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,Resource resource,boolean continueOnError) throws DataAccessException {
  executeSqlScript(jdbcTemplate,new EncodedResource(resource),continueOnError);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource (potentially associated with a specific encoding)to load the SQL script from
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @deprecated as of Spring 4.0.3, in favor of using {@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript(ScriptStatementExecutor,EncodedResource,boolean,boolean,String,String,String,String)}  
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,EncodedResource resource,boolean continueOnError) throws DataAccessException {
  ScriptUtils.executeSqlScript(new JdbcTemplateScriptStatementExecutor(jdbcTemplate),resource,continueOnError,continueOnError,ScriptUtils.DEFAULT_COMMENT_PREFIX,ScriptUtils.DEFAULT_STATEMENT_SEPARATOR,ScriptUtils.DEFAULT_BLOCK_COMMENT_START_DELIMITER,ScriptUtils.DEFAULT_BLOCK_COMMENT_END_DELIMITER);
}
"
"/** 
 * Read a script from the provided  {@code LineNumberReader}, using "" {@code --}"" as the comment prefix, and build a  {@code String} containingthe lines.
 * @param lineNumberReader the {@code LineNumberReader} containing the scriptto be processed
 * @return a {@code String} containing the script lines
 * @see #readScript(LineNumberReader,String)
 * @deprecated as of Spring 4.0.3, in favor of using {@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader)}  
 */
@Deprecated public static String readScript(LineNumberReader lineNumberReader) throws IOException {
  return ScriptUtils.readScript(lineNumberReader);
}
"
"/** 
 * Read a script from the provided  {@code LineNumberReader}, using the supplied comment prefix, and build a  {@code String} containing the lines.<p>Lines <em>beginning</em> with the comment prefix are excluded from the results; however, line comments anywhere else &mdash; for example, within a statement &mdash; will be included in the results.
 * @param lineNumberReader the {@code LineNumberReader} containing the scriptto be processed
 * @param commentPrefix the prefix that identifies comments in the SQL script &mdash; typically ""--""
 * @return a {@code String} containing the script lines
 * @deprecated as of Spring 4.0.3, in favor of using {@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader,String,String)}  
 */
@Deprecated public static String readScript(LineNumberReader lineNumberReader,String commentPrefix) throws IOException {
  return ScriptUtils.readScript(lineNumberReader,commentPrefix,ScriptUtils.DEFAULT_STATEMENT_SEPARATOR);
}
"
"/** 
 * Determine if the provided SQL script contains the specified delimiter.
 * @param script the SQL script
 * @param delim character delimiting each statement &mdash; typically a ';' character
 * @return {@code true} if the script contains the delimiter; {@code false} otherwise
 * @deprecated as of Spring 4.0.3, in favor of using {@link org.springframework.jdbc.datasource.init.ScriptUtils#containsSqlScriptDelimiters(String,char)}  
 */
@Deprecated public static boolean containsSqlScriptDelimiters(String script,char delim){
  return ScriptUtils.containsSqlScriptDelimiters(script,delim);
}
"
"/** 
 * Split an SQL script into separate statements delimited by the provided delimiter character. Each individual statement will be added to the provided  {@code List}. <p>Within a statement, "" {@code --}"" will be used as the comment prefix; any text beginning with the comment prefix and extending to the end of the line will be omitted from the statement. In addition, multiple adjacent whitespace characters will be collapsed into a single space.
 * @param script the SQL script
 * @param delim character delimiting each statement &mdash; typically a ';' character
 * @param statements the list that will contain the individual statements
 * @deprecated as of Spring 4.0.3, in favor of using {@link org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(String,char,List)}  
 */
@Deprecated public static void splitSqlScript(String script,char delim,List<String> statements){
  ScriptUtils.splitSqlScript(script,delim,statements);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of HttpStatus.METHOD_FAILURE
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of HttpStatus.DESTINATION_LOCKED
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resourceLoader the resource loader with which to load the SQL script
 * @param sqlResourcePath the Spring resource path for the SQL script
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see DatabasePopulatorUtils
 * @see #executeSqlScript(JdbcTemplate,Resource,boolean)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,ResourceLoader resourceLoader,String sqlResourcePath,boolean continueOnError) throws DataAccessException {
  Resource resource=resourceLoader.getResource(sqlResourcePath);
  executeSqlScript(jdbcTemplate,resource,continueOnError);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. Statements should be delimited with a semicolon. If statements are not delimited with a semicolon then there should be one statement per line. Statements are allowed to span lines only if they are delimited with a semicolon. Any line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource to load the SQL script from
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see DatabasePopulatorUtils
 * @see #executeSqlScript(JdbcTemplate,EncodedResource,boolean)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,Resource resource,boolean continueOnError) throws DataAccessException {
  executeSqlScript(jdbcTemplate,new EncodedResource(resource),continueOnError);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource (potentially associated with a specific encoding)to load the SQL script from
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see DatabasePopulatorUtils
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,EncodedResource resource,boolean continueOnError) throws DataAccessException {
  DatabasePopulator databasePopulator=new ResourceDatabasePopulator(continueOnError,false,resource.getEncoding(),resource.getResource());
  DatabasePopulatorUtils.execute(databasePopulator,jdbcTemplate.getDataSource());
}
"
"/** 
 * Read a script from the provided  {@code LineNumberReader}, using "" {@code --}"" as the comment prefix, and build a  {@code String} containingthe lines.
 * @param lineNumberReader the {@code LineNumberReader} containing the scriptto be processed
 * @return a {@code String} containing the script lines
 * @see #readScript(LineNumberReader,String)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader,String,String)}
 */
@Deprecated public static String readScript(LineNumberReader lineNumberReader) throws IOException {
  return readScript(lineNumberReader,ScriptUtils.DEFAULT_COMMENT_PREFIX);
}
"
"/** 
 * Read a script from the provided  {@code LineNumberReader}, using the supplied comment prefix, and build a  {@code String} containing the lines.<p>Lines <em>beginning</em> with the comment prefix are excluded from the results; however, line comments anywhere else &mdash; for example, within a statement &mdash; will be included in the results.
 * @param lineNumberReader the {@code LineNumberReader} containing the scriptto be processed
 * @param commentPrefix the prefix that identifies comments in the SQL script &mdash; typically ""--""
 * @return a {@code String} containing the script lines
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader,String,String)} 
 */
@Deprecated public static String readScript(LineNumberReader lineNumberReader,String commentPrefix) throws IOException {
  return ScriptUtils.readScript(lineNumberReader,commentPrefix,ScriptUtils.DEFAULT_STATEMENT_SEPARATOR);
}
"
"/** 
 * Determine if the provided SQL script contains the specified delimiter.
 * @param script the SQL script
 * @param delim character delimiting each statement &mdash; typically a ';' character
 * @return {@code true} if the script contains the delimiter; {@code false} otherwise
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#containsSqlScriptDelimiters}
 */
@Deprecated public static boolean containsSqlScriptDelimiters(String script,char delim){
  return ScriptUtils.containsSqlScriptDelimiters(script,String.valueOf(delim));
}
"
"/** 
 * Split an SQL script into separate statements delimited by the provided delimiter character. Each individual statement will be added to the provided  {@code List}. <p>Within a statement, "" {@code --}"" will be used as the comment prefix; any text beginning with the comment prefix and extending to the end of the line will be omitted from the statement. In addition, multiple adjacent whitespace characters will be collapsed into a single space.
 * @param script the SQL script
 * @param delim character delimiting each statement &mdash; typically a ';' character
 * @param statements the list that will contain the individual statements
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(String,char,List)} 
 */
@Deprecated public static void splitSqlScript(String script,char delim,List<String> statements){
  ScriptUtils.splitSqlScript(script,delim,statements);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resourceLoader the resource loader with which to load the SQL script
 * @param sqlResourcePath the Spring resource path for the SQL script
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see DatabasePopulatorUtils
 * @see #executeSqlScript(JdbcTemplate,Resource,boolean)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,ResourceLoader resourceLoader,String sqlResourcePath,boolean continueOnError) throws DataAccessException {
  Resource resource=resourceLoader.getResource(sqlResourcePath);
  executeSqlScript(jdbcTemplate,resource,continueOnError);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. Statements should be delimited with a semicolon. If statements are not delimited with a semicolon then there should be one statement per line. Statements are allowed to span lines only if they are delimited with a semicolon. Any line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource to load the SQL script from
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see DatabasePopulatorUtils
 * @see #executeSqlScript(JdbcTemplate,EncodedResource,boolean)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,Resource resource,boolean continueOnError) throws DataAccessException {
  executeSqlScript(jdbcTemplate,new EncodedResource(resource),continueOnError);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource (potentially associated with a specific encoding)to load the SQL script from
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see DatabasePopulatorUtils
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,EncodedResource resource,boolean continueOnError) throws DataAccessException {
  ResourceDatabasePopulator databasePopulator=new ResourceDatabasePopulator();
  databasePopulator.setContinueOnError(continueOnError);
  databasePopulator.addScript(resource.getResource());
  databasePopulator.setSqlScriptEncoding(resource.getEncoding());
  DatabasePopulatorUtils.execute(databasePopulator,jdbcTemplate.getDataSource());
}
"
"/** 
 * Read a script from the provided  {@code LineNumberReader}, using "" {@code --}"" as the comment prefix, and build a  {@code String} containingthe lines.
 * @param lineNumberReader the {@code LineNumberReader} containing the scriptto be processed
 * @return a {@code String} containing the script lines
 * @see #readScript(LineNumberReader,String)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader,String,String)}
 */
@Deprecated public static String readScript(LineNumberReader lineNumberReader) throws IOException {
  return readScript(lineNumberReader,ScriptUtils.DEFAULT_COMMENT_PREFIX);
}
"
"/** 
 * Read a script from the provided  {@code LineNumberReader}, using the supplied comment prefix, and build a  {@code String} containing the lines.<p>Lines <em>beginning</em> with the comment prefix are excluded from the results; however, line comments anywhere else &mdash; for example, within a statement &mdash; will be included in the results.
 * @param lineNumberReader the {@code LineNumberReader} containing the scriptto be processed
 * @param commentPrefix the prefix that identifies comments in the SQL script &mdash; typically ""--""
 * @return a {@code String} containing the script lines
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader,String,String)}  
 */
@Deprecated public static String readScript(LineNumberReader lineNumberReader,String commentPrefix) throws IOException {
  return ScriptUtils.readScript(lineNumberReader,commentPrefix,ScriptUtils.DEFAULT_STATEMENT_SEPARATOR);
}
"
"/** 
 * Determine if the provided SQL script contains the specified delimiter.
 * @param script the SQL script
 * @param delim character delimiting each statement &mdash; typically a ';' character
 * @return {@code true} if the script contains the delimiter; {@code false} otherwise
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#containsSqlScriptDelimiters}
 */
@Deprecated public static boolean containsSqlScriptDelimiters(String script,char delim){
  return ScriptUtils.containsSqlScriptDelimiters(script,String.valueOf(delim));
}
"
"/** 
 * Split an SQL script into separate statements delimited by the provided delimiter character. Each individual statement will be added to the provided  {@code List}. <p>Within a statement, "" {@code --}"" will be used as the comment prefix; any text beginning with the comment prefix and extending to the end of the line will be omitted from the statement. In addition, multiple adjacent whitespace characters will be collapsed into a single space.
 * @param script the SQL script
 * @param delim character delimiting each statement &mdash; typically a ';' character
 * @param statements the list that will contain the individual statements
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(String,char,List)}  
 */
@Deprecated public static void splitSqlScript(String script,char delim,List<String> statements){
  ScriptUtils.splitSqlScript(script,delim,statements);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resourceLoader the resource loader with which to load the SQL script
 * @param sqlResourcePath the Spring resource path for the SQL script
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see DatabasePopulatorUtils
 * @see #executeSqlScript(JdbcTemplate,Resource,boolean)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,ResourceLoader resourceLoader,String sqlResourcePath,boolean continueOnError) throws DataAccessException {
  Resource resource=resourceLoader.getResource(sqlResourcePath);
  executeSqlScript(jdbcTemplate,resource,continueOnError);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. Statements should be delimited with a semicolon. If statements are not delimited with a semicolon then there should be one statement per line. Statements are allowed to span lines only if they are delimited with a semicolon. Any line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource to load the SQL script from
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see DatabasePopulatorUtils
 * @see #executeSqlScript(JdbcTemplate,EncodedResource,boolean)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,Resource resource,boolean continueOnError) throws DataAccessException {
  executeSqlScript(jdbcTemplate,new EncodedResource(resource),continueOnError);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource (potentially associated with a specific encoding)to load the SQL script from
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see DatabasePopulatorUtils
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,EncodedResource resource,boolean continueOnError) throws DataAccessException {
  ResourceDatabasePopulator databasePopulator=new ResourceDatabasePopulator();
  databasePopulator.setContinueOnError(continueOnError);
  databasePopulator.addScript(resource.getResource());
  databasePopulator.setSqlScriptEncoding(resource.getEncoding());
  DatabasePopulatorUtils.execute(databasePopulator,jdbcTemplate.getDataSource());
}
"
"/** 
 * Read a script from the provided  {@code LineNumberReader}, using "" {@code --}"" as the comment prefix, and build a  {@code String} containingthe lines.
 * @param lineNumberReader the {@code LineNumberReader} containing the scriptto be processed
 * @return a {@code String} containing the script lines
 * @see #readScript(LineNumberReader,String)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader,String,String)}
 */
@Deprecated public static String readScript(LineNumberReader lineNumberReader) throws IOException {
  return readScript(lineNumberReader,ScriptUtils.DEFAULT_COMMENT_PREFIX);
}
"
"/** 
 * Read a script from the provided  {@code LineNumberReader}, using the supplied comment prefix, and build a  {@code String} containing the lines.<p>Lines <em>beginning</em> with the comment prefix are excluded from the results; however, line comments anywhere else &mdash; for example, within a statement &mdash; will be included in the results.
 * @param lineNumberReader the {@code LineNumberReader} containing the scriptto be processed
 * @param commentPrefix the prefix that identifies comments in the SQL script &mdash; typically ""--""
 * @return a {@code String} containing the script lines
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader,String,String)}  
 */
@Deprecated public static String readScript(LineNumberReader lineNumberReader,String commentPrefix) throws IOException {
  return ScriptUtils.readScript(lineNumberReader,commentPrefix,ScriptUtils.DEFAULT_STATEMENT_SEPARATOR);
}
"
"/** 
 * Determine if the provided SQL script contains the specified delimiter.
 * @param script the SQL script
 * @param delim character delimiting each statement &mdash; typically a ';' character
 * @return {@code true} if the script contains the delimiter; {@code false} otherwise
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#containsSqlScriptDelimiters}
 */
@Deprecated public static boolean containsSqlScriptDelimiters(String script,char delim){
  return ScriptUtils.containsSqlScriptDelimiters(script,String.valueOf(delim));
}
"
"/** 
 * Split an SQL script into separate statements delimited by the provided delimiter character. Each individual statement will be added to the provided  {@code List}. <p>Within a statement, "" {@code --}"" will be used as the comment prefix; any text beginning with the comment prefix and extending to the end of the line will be omitted from the statement. In addition, multiple adjacent whitespace characters will be collapsed into a single space.
 * @param script the SQL script
 * @param delim character delimiting each statement &mdash; typically a ';' character
 * @param statements the list that will contain the individual statements
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(String,char,List)}  
 */
@Deprecated public static void splitSqlScript(String script,char delim,List<String> statements){
  ScriptUtils.splitSqlScript(script,delim,statements);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resourceLoader the resource loader with which to load the SQL script
 * @param sqlResourcePath the Spring resource path for the SQL script
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see DatabasePopulatorUtils
 * @see #executeSqlScript(JdbcTemplate,Resource,boolean)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,ResourceLoader resourceLoader,String sqlResourcePath,boolean continueOnError) throws DataAccessException {
  Resource resource=resourceLoader.getResource(sqlResourcePath);
  executeSqlScript(jdbcTemplate,resource,continueOnError);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. Statements should be delimited with a semicolon. If statements are not delimited with a semicolon then there should be one statement per line. Statements are allowed to span lines only if they are delimited with a semicolon. Any line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource to load the SQL script from
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see DatabasePopulatorUtils
 * @see #executeSqlScript(JdbcTemplate,EncodedResource,boolean)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,Resource resource,boolean continueOnError) throws DataAccessException {
  executeSqlScript(jdbcTemplate,new EncodedResource(resource),continueOnError);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource (potentially associated with a specific encoding)to load the SQL script from
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see DatabasePopulatorUtils
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,EncodedResource resource,boolean continueOnError) throws DataAccessException {
  ResourceDatabasePopulator databasePopulator=new ResourceDatabasePopulator();
  databasePopulator.setContinueOnError(continueOnError);
  databasePopulator.addScript(resource.getResource());
  databasePopulator.setSqlScriptEncoding(resource.getEncoding());
  DatabasePopulatorUtils.execute(databasePopulator,jdbcTemplate.getDataSource());
}
"
"/** 
 * Read a script from the provided  {@code LineNumberReader}, using "" {@code --}"" as the comment prefix, and build a  {@code String} containingthe lines.
 * @param lineNumberReader the {@code LineNumberReader} containing the scriptto be processed
 * @return a {@code String} containing the script lines
 * @see #readScript(LineNumberReader,String)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader,String,String)}
 */
@Deprecated public static String readScript(LineNumberReader lineNumberReader) throws IOException {
  return readScript(lineNumberReader,ScriptUtils.DEFAULT_COMMENT_PREFIX);
}
"
"/** 
 * Read a script from the provided  {@code LineNumberReader}, using the supplied comment prefix, and build a  {@code String} containing the lines.<p>Lines <em>beginning</em> with the comment prefix are excluded from the results; however, line comments anywhere else &mdash; for example, within a statement &mdash; will be included in the results.
 * @param lineNumberReader the {@code LineNumberReader} containing the scriptto be processed
 * @param commentPrefix the prefix that identifies comments in the SQL script &mdash; typically ""--""
 * @return a {@code String} containing the script lines
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader,String,String)} 
 */
@Deprecated public static String readScript(LineNumberReader lineNumberReader,String commentPrefix) throws IOException {
  return ScriptUtils.readScript(lineNumberReader,commentPrefix,ScriptUtils.DEFAULT_STATEMENT_SEPARATOR);
}
"
"/** 
 * Determine if the provided SQL script contains the specified delimiter.
 * @param script the SQL script
 * @param delim character delimiting each statement &mdash; typically a ';' character
 * @return {@code true} if the script contains the delimiter; {@code false} otherwise
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#containsSqlScriptDelimiters}
 */
@Deprecated public static boolean containsSqlScriptDelimiters(String script,char delim){
  return ScriptUtils.containsSqlScriptDelimiters(script,String.valueOf(delim));
}
"
"/** 
 * Split an SQL script into separate statements delimited by the provided delimiter character. Each individual statement will be added to the provided  {@code List}. <p>Within a statement, "" {@code --}"" will be used as the comment prefix; any text beginning with the comment prefix and extending to the end of the line will be omitted from the statement. In addition, multiple adjacent whitespace characters will be collapsed into a single space.
 * @param script the SQL script
 * @param delim character delimiting each statement &mdash; typically a ';' character
 * @param statements the list that will contain the individual statements
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(String,char,List)} 
 */
@Deprecated public static void splitSqlScript(String script,char delim,List<String> statements){
  ScriptUtils.splitSqlScript(script,delim,statements);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resourceLoader the resource loader with which to load the SQL script
 * @param sqlResourcePath the Spring resource path for the SQL script
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see DatabasePopulatorUtils
 * @see #executeSqlScript(JdbcTemplate,Resource,boolean)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,ResourceLoader resourceLoader,String sqlResourcePath,boolean continueOnError) throws DataAccessException {
  Resource resource=resourceLoader.getResource(sqlResourcePath);
  executeSqlScript(jdbcTemplate,resource,continueOnError);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. Statements should be delimited with a semicolon. If statements are not delimited with a semicolon then there should be one statement per line. Statements are allowed to span lines only if they are delimited with a semicolon. Any line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource to load the SQL script from
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see DatabasePopulatorUtils
 * @see #executeSqlScript(JdbcTemplate,EncodedResource,boolean)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,Resource resource,boolean continueOnError) throws DataAccessException {
  executeSqlScript(jdbcTemplate,new EncodedResource(resource),continueOnError);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource (potentially associated with a specific encoding)to load the SQL script from
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see DatabasePopulatorUtils
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,EncodedResource resource,boolean continueOnError) throws DataAccessException {
  DatabasePopulator databasePopulator=new ResourceDatabasePopulator(continueOnError,false,resource.getEncoding(),resource.getResource());
  DatabasePopulatorUtils.execute(databasePopulator,jdbcTemplate.getDataSource());
}
"
"/** 
 * Read a script from the provided  {@code LineNumberReader}, using "" {@code --}"" as the comment prefix, and build a  {@code String} containingthe lines.
 * @param lineNumberReader the {@code LineNumberReader} containing the scriptto be processed
 * @return a {@code String} containing the script lines
 * @see #readScript(LineNumberReader,String)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader,String,String)}
 */
@Deprecated public static String readScript(LineNumberReader lineNumberReader) throws IOException {
  return readScript(lineNumberReader,ScriptUtils.DEFAULT_COMMENT_PREFIX);
}
"
"/** 
 * Read a script from the provided  {@code LineNumberReader}, using the supplied comment prefix, and build a  {@code String} containing the lines.<p>Lines <em>beginning</em> with the comment prefix are excluded from the results; however, line comments anywhere else &mdash; for example, within a statement &mdash; will be included in the results.
 * @param lineNumberReader the {@code LineNumberReader} containing the scriptto be processed
 * @param commentPrefix the prefix that identifies comments in the SQL script &mdash; typically ""--""
 * @return a {@code String} containing the script lines
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader,String,String)} 
 */
@Deprecated public static String readScript(LineNumberReader lineNumberReader,String commentPrefix) throws IOException {
  return ScriptUtils.readScript(lineNumberReader,commentPrefix,ScriptUtils.DEFAULT_STATEMENT_SEPARATOR);
}
"
"/** 
 * Determine if the provided SQL script contains the specified delimiter.
 * @param script the SQL script
 * @param delim character delimiting each statement &mdash; typically a ';' character
 * @return {@code true} if the script contains the delimiter; {@code false} otherwise
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#containsSqlScriptDelimiters}
 */
@Deprecated public static boolean containsSqlScriptDelimiters(String script,char delim){
  return ScriptUtils.containsSqlScriptDelimiters(script,String.valueOf(delim));
}
"
"/** 
 * Split an SQL script into separate statements delimited by the provided delimiter character. Each individual statement will be added to the provided  {@code List}. <p>Within a statement, "" {@code --}"" will be used as the comment prefix; any text beginning with the comment prefix and extending to the end of the line will be omitted from the statement. In addition, multiple adjacent whitespace characters will be collapsed into a single space.
 * @param script the SQL script
 * @param delim character delimiting each statement &mdash; typically a ';' character
 * @param statements the list that will contain the individual statements
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(String,char,List)} 
 */
@Deprecated public static void splitSqlScript(String script,char delim,List<String> statements){
  ScriptUtils.splitSqlScript(script,delim,statements);
}
"
"/** 
 * Encodes the given source URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre class=""code""> UriComponents uriComponents = UriComponentsBuilder.fromUri(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param uri the URI to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeUri(String uri,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(uri,""URI must not be null"");
  Assert.hasLength(encoding,""Encoding must not be empty"");
  Matcher matcher=URI_PATTERN.matcher(uri);
  if (matcher.matches()) {
    String scheme=matcher.group(2);
    String authority=matcher.group(3);
    String userinfo=matcher.group(5);
    String host=matcher.group(6);
    String port=matcher.group(8);
    String path=matcher.group(9);
    String query=matcher.group(11);
    String fragment=matcher.group(13);
    return encodeUriComponents(scheme,authority,userinfo,host,port,path,query,fragment,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + uri + ""] is not a valid URI"");
  }
}
"
"/** 
 * Encodes the given HTTP URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not support fragments ( {@code #}), as these are not supposed to be sent to the server, but retained by the client. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre class=""code""> UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param httpUrl the HTTP URL to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URL
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeHttpUrl(String httpUrl,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(httpUrl,""HTTP URL must not be null"");
  Assert.hasLength(encoding,""Encoding must not be empty"");
  Matcher matcher=HTTP_URL_PATTERN.matcher(httpUrl);
  if (matcher.matches()) {
    String scheme=matcher.group(1);
    String authority=matcher.group(2);
    String userinfo=matcher.group(4);
    String host=matcher.group(5);
    String portString=matcher.group(7);
    String path=matcher.group(8);
    String query=matcher.group(10);
    return encodeUriComponents(scheme,authority,userinfo,host,portString,path,query,null,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + httpUrl + ""] is not a valid HTTP URL"");
  }
}
"
"/** 
 * Encodes the given source URI components into an encoded String. All various URI components are optional, but encoded according to their respective valid character sets.
 * @param scheme the scheme
 * @param authority the authority
 * @param userInfo the user info
 * @param host the host
 * @param port the port
 * @param path the path
 * @param query the query
 * @param fragment the fragment
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}
 */
@Deprecated public static String encodeUriComponents(String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,String encoding) throws UnsupportedEncodingException {
  Assert.hasLength(encoding,""Encoding must not be empty"");
  StringBuilder sb=new StringBuilder();
  if (scheme != null) {
    sb.append(encodeScheme(scheme,encoding));
    sb.append(':');
  }
  if (authority != null) {
    sb.append(""//"");
    if (userInfo != null) {
      sb.append(encodeUserInfo(userInfo,encoding));
      sb.append('@');
    }
    if (host != null) {
      sb.append(encodeHost(host,encoding));
    }
    if (port != null) {
      sb.append(':');
      sb.append(encodePort(port,encoding));
    }
  }
  sb.append(encodePath(path,encoding));
  if (query != null) {
    sb.append('?');
    sb.append(encodeQuery(query,encoding));
  }
  if (fragment != null) {
    sb.append('#');
    sb.append(encodeFragment(fragment,encoding));
  }
  return sb.toString();
}
"
"/** 
 * Encodes the given source URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre class=""code""> UriComponents uriComponents = UriComponentsBuilder.fromUri(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param uri the URI to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeUri(String uri,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(uri,""URI must not be null"");
  Assert.hasLength(encoding,""Encoding must not be empty"");
  Matcher matcher=URI_PATTERN.matcher(uri);
  if (matcher.matches()) {
    String scheme=matcher.group(2);
    String authority=matcher.group(3);
    String userinfo=matcher.group(5);
    String host=matcher.group(6);
    String port=matcher.group(8);
    String path=matcher.group(9);
    String query=matcher.group(11);
    String fragment=matcher.group(13);
    return encodeUriComponents(scheme,authority,userinfo,host,port,path,query,fragment,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + uri + ""] is not a valid URI"");
  }
}
"
"/** 
 * Encodes the given HTTP URI into an encoded String. All various URI components are encoded according to their respective valid character sets. <p><strong>Note</strong> that this method does not support fragments ( {@code #}), as these are not supposed to be sent to the server, but retained by the client. <p><strong>Note</strong> that this method does not attempt to encode ""="" and ""&"" characters in query parameter names and query parameter values because they cannot be parsed in a reliable way. Instead use: <pre class=""code""> UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(""/path?name={value}"").buildAndExpand(""a=b""); String encodedUri = uriComponents.encode().toUriString(); </pre>
 * @param httpUrl the HTTP URL to be encoded
 * @param encoding the character encoding to encode to
 * @return the encoded URL
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}; see note about query param encoding
 */
@Deprecated public static String encodeHttpUrl(String httpUrl,String encoding) throws UnsupportedEncodingException {
  Assert.notNull(httpUrl,""HTTP URL must not be null"");
  Assert.hasLength(encoding,""Encoding must not be empty"");
  Matcher matcher=HTTP_URL_PATTERN.matcher(httpUrl);
  if (matcher.matches()) {
    String scheme=matcher.group(1);
    String authority=matcher.group(2);
    String userinfo=matcher.group(4);
    String host=matcher.group(5);
    String portString=matcher.group(7);
    String path=matcher.group(8);
    String query=matcher.group(10);
    return encodeUriComponents(scheme,authority,userinfo,host,portString,path,query,null,encoding);
  }
 else {
    throw new IllegalArgumentException(""["" + httpUrl + ""] is not a valid HTTP URL"");
  }
}
"
"/** 
 * Encodes the given source URI components into an encoded String. All various URI components are optional, but encoded according to their respective valid character sets.
 * @param scheme the scheme
 * @param authority the authority
 * @param userInfo the user info
 * @param host the host
 * @param port the port
 * @param path the path
 * @param query the query
 * @param fragment the fragment
 * @param encoding the character encoding to encode to
 * @return the encoded URI
 * @throws IllegalArgumentException when the given uri parameter is not a valid URI
 * @throws UnsupportedEncodingException when the given encoding parameter is not supported
 * @deprecated in favor of {@link UriComponentsBuilder}
 */
@Deprecated public static String encodeUriComponents(String scheme,String authority,String userInfo,String host,String port,String path,String query,String fragment,String encoding) throws UnsupportedEncodingException {
  Assert.hasLength(encoding,""Encoding must not be empty"");
  StringBuilder sb=new StringBuilder();
  if (scheme != null) {
    sb.append(encodeScheme(scheme,encoding));
    sb.append(':');
  }
  if (authority != null) {
    sb.append(""//"");
    if (userInfo != null) {
      sb.append(encodeUserInfo(userInfo,encoding));
      sb.append('@');
    }
    if (host != null) {
      sb.append(encodeHost(host,encoding));
    }
    if (port != null) {
      sb.append(':');
      sb.append(encodePort(port,encoding));
    }
  }
  sb.append(encodePath(path,encoding));
  if (query != null) {
    sb.append('?');
    sb.append(encodeQuery(query,encoding));
  }
  if (fragment != null) {
    sb.append('#');
    sb.append(encodeFragment(fragment,encoding));
  }
  return sb.toString();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Collection} or array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Set the expected root object for the unmarshaller, into which the source will be unmarshalled.
 * @see org.exolab.castor.xml.Unmarshaller#setObject(Object)
 * @deprecated in favor of {@link #setRootObject}
 */
@Deprecated public void setObject(Object root){
  this.rootObject=root;
}
"
"/** 
 * Replacement for  {@code Class.forName()} that also returns Class instancesfor primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return  {@code false} if either the class orone of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resourceLoader the resource loader with which to load the SQL script
 * @param sqlResourcePath the Spring resource path for the SQL script
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see #executeSqlScript(JdbcTemplate,Resource,boolean)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,ResourceLoader resourceLoader,String sqlResourcePath,boolean continueOnError) throws DataAccessException {
  Resource resource=resourceLoader.getResource(sqlResourcePath);
  executeSqlScript(jdbcTemplate,resource,continueOnError);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. Statements should be delimited with a semicolon. If statements are not delimited with a semicolon then there should be one statement per line. Statements are allowed to span lines only if they are delimited with a semicolon. Any line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource to load the SQL script from
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see #executeSqlScript(JdbcTemplate,EncodedResource,boolean)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,Resource resource,boolean continueOnError) throws DataAccessException {
  executeSqlScript(jdbcTemplate,new EncodedResource(resource),continueOnError);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource (potentially associated with a specific encoding)to load the SQL script from
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,EncodedResource resource,boolean continueOnError) throws DataAccessException {
  new ResourceDatabasePopulator(continueOnError,false,resource.getEncoding(),resource.getResource()).execute(jdbcTemplate.getDataSource());
}
"
"/** 
 * Read a script from the provided  {@code LineNumberReader}, using "" {@code --}"" as the comment prefix, and build a  {@code String} containingthe lines.
 * @param lineNumberReader the {@code LineNumberReader} containing the scriptto be processed
 * @return a {@code String} containing the script lines
 * @see #readScript(LineNumberReader,String)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader,String,String)}
 */
@Deprecated public static String readScript(LineNumberReader lineNumberReader) throws IOException {
  return readScript(lineNumberReader,ScriptUtils.DEFAULT_COMMENT_PREFIX);
}
"
"/** 
 * Read a script from the provided  {@code LineNumberReader}, using the supplied comment prefix, and build a  {@code String} containing the lines.<p>Lines <em>beginning</em> with the comment prefix are excluded from the results; however, line comments anywhere else &mdash; for example, within a statement &mdash; will be included in the results.
 * @param lineNumberReader the {@code LineNumberReader} containing the scriptto be processed
 * @param commentPrefix the prefix that identifies comments in the SQL script &mdash; typically ""--""
 * @return a {@code String} containing the script lines
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader,String,String)} 
 */
@Deprecated public static String readScript(LineNumberReader lineNumberReader,String commentPrefix) throws IOException {
  return ScriptUtils.readScript(lineNumberReader,commentPrefix,ScriptUtils.DEFAULT_STATEMENT_SEPARATOR);
}
"
"/** 
 * Determine if the provided SQL script contains the specified delimiter.
 * @param script the SQL script
 * @param delim character delimiting each statement &mdash; typically a ';' character
 * @return {@code true} if the script contains the delimiter; {@code false} otherwise
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#containsSqlScriptDelimiters}
 */
@Deprecated public static boolean containsSqlScriptDelimiters(String script,char delim){
  return ScriptUtils.containsSqlScriptDelimiters(script,String.valueOf(delim));
}
"
"/** 
 * Split an SQL script into separate statements delimited by the provided delimiter character. Each individual statement will be added to the provided  {@code List}. <p>Within a statement, "" {@code --}"" will be used as the comment prefix; any text beginning with the comment prefix and extending to the end of the line will be omitted from the statement. In addition, multiple adjacent whitespace characters will be collapsed into a single space.
 * @param script the SQL script
 * @param delim character delimiting each statement &mdash; typically a ';' character
 * @param statements the list that will contain the individual statements
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(String,char,List)} 
 */
@Deprecated public static void splitSqlScript(String script,char delim,List<String> statements){
  ScriptUtils.splitSqlScript(script,delim,statements);
}
"
"/** 
 * Construct a new  {@link ContextConfigurationAttributes} instance for the{@linkplain Class test class} that declared the{@link ContextConfiguration @ContextConfiguration} annotation and itscorresponding attributes.
 * @param declaringClass the test class that declared {@code @ContextConfiguration}
 * @param locations the resource locations declared via {@code @ContextConfiguration}
 * @param classes the annotated classes declared via {@code @ContextConfiguration}
 * @param inheritLocations the {@code inheritLocations} flag declared via {@code @ContextConfiguration}
 * @param contextLoaderClass the {@code ContextLoader} class declared via {@code @ContextConfiguration}
 * @throws IllegalArgumentException if the {@code declaringClass} or {@code contextLoaderClass} is{@code null}
 * @deprecated as of Spring 3.2, use{@link #ContextConfigurationAttributes(Class,String[],Class[],boolean,Class[],boolean,String,Class)}instead
 */
@Deprecated public ContextConfigurationAttributes(Class<?> declaringClass,String[] locations,Class<?>[] classes,boolean inheritLocations,Class<? extends ContextLoader> contextLoaderClass){
  this(declaringClass,locations,classes,inheritLocations,null,true,null,contextLoaderClass);
}
"
"/** 
 * Construct a new  {@link ContextConfigurationAttributes} instance for the{@linkplain Class test class} that declared the{@link ContextConfiguration @ContextConfiguration} annotation and itscorresponding attributes.
 * @param declaringClass the test class that declared {@code @ContextConfiguration}
 * @param locations the resource locations declared via {@code @ContextConfiguration}
 * @param classes the annotated classes declared via {@code @ContextConfiguration}
 * @param inheritLocations the {@code inheritLocations} flag declared via {@code @ContextConfiguration}
 * @param contextLoaderClass the {@code ContextLoader} class declared via {@code @ContextConfiguration}
 * @throws IllegalArgumentException if the {@code declaringClass} or {@code contextLoaderClass} is{@code null}
 * @deprecated as of Spring 3.2, use{@link #ContextConfigurationAttributes(Class,String[],Class[],boolean,Class[],boolean,String,Class)}instead
 */
@Deprecated public ContextConfigurationAttributes(Class<?> declaringClass,String[] locations,Class<?>[] classes,boolean inheritLocations,Class<? extends ContextLoader> contextLoaderClass){
  this(declaringClass,locations,classes,inheritLocations,null,true,null,contextLoaderClass);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resourceLoader the resource loader with which to load the SQL script
 * @param sqlResourcePath the Spring resource path for the SQL script
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see #executeSqlScript(JdbcTemplate,Resource,boolean)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,ResourceLoader resourceLoader,String sqlResourcePath,boolean continueOnError) throws DataAccessException {
  Resource resource=resourceLoader.getResource(sqlResourcePath);
  executeSqlScript(jdbcTemplate,resource,continueOnError);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. Statements should be delimited with a semicolon. If statements are not delimited with a semicolon then there should be one statement per line. Statements are allowed to span lines only if they are delimited with a semicolon. Any line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource to load the SQL script from
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see #executeSqlScript(JdbcTemplate,EncodedResource,boolean)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,Resource resource,boolean continueOnError) throws DataAccessException {
  executeSqlScript(jdbcTemplate,new EncodedResource(resource),continueOnError);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource (potentially associated with a specific encoding)to load the SQL script from
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,EncodedResource resource,boolean continueOnError) throws DataAccessException {
  new ResourceDatabasePopulator(continueOnError,false,resource.getEncoding(),resource.getResource()).execute(jdbcTemplate.getDataSource());
}
"
"/** 
 * Read a script from the provided  {@code LineNumberReader}, using "" {@code --}"" as the comment prefix, and build a  {@code String} containingthe lines.
 * @param lineNumberReader the {@code LineNumberReader} containing the scriptto be processed
 * @return a {@code String} containing the script lines
 * @see #readScript(LineNumberReader,String)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader,String,String)}
 */
@Deprecated public static String readScript(LineNumberReader lineNumberReader) throws IOException {
  return readScript(lineNumberReader,ScriptUtils.DEFAULT_COMMENT_PREFIX);
}
"
"/** 
 * Read a script from the provided  {@code LineNumberReader}, using the supplied comment prefix, and build a  {@code String} containing the lines.<p>Lines <em>beginning</em> with the comment prefix are excluded from the results; however, line comments anywhere else &mdash; for example, within a statement &mdash; will be included in the results.
 * @param lineNumberReader the {@code LineNumberReader} containing the scriptto be processed
 * @param commentPrefix the prefix that identifies comments in the SQL script &mdash; typically ""--""
 * @return a {@code String} containing the script lines
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader,String,String)}
 */
@Deprecated public static String readScript(LineNumberReader lineNumberReader,String commentPrefix) throws IOException {
  return ScriptUtils.readScript(lineNumberReader,commentPrefix,ScriptUtils.DEFAULT_STATEMENT_SEPARATOR);
}
"
"/** 
 * Determine if the provided SQL script contains the specified delimiter.
 * @param script the SQL script
 * @param delim character delimiting each statement &mdash; typically a ';' character
 * @return {@code true} if the script contains the delimiter; {@code false} otherwise
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#containsSqlScriptDelimiters}
 */
@Deprecated public static boolean containsSqlScriptDelimiters(String script,char delim){
  return ScriptUtils.containsSqlScriptDelimiters(script,String.valueOf(delim));
}
"
"/** 
 * Split an SQL script into separate statements delimited by the provided delimiter character. Each individual statement will be added to the provided  {@code List}. <p>Within a statement, "" {@code --}"" will be used as the comment prefix; any text beginning with the comment prefix and extending to the end of the line will be omitted from the statement. In addition, multiple adjacent whitespace characters will be collapsed into a single space.
 * @param script the SQL script
 * @param delim character delimiting each statement &mdash; typically a ';' character
 * @param statements the list that will contain the individual statements
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(String,char,List)}
 */
@Deprecated public static void splitSqlScript(String script,char delim,List<String> statements){
  ScriptUtils.splitSqlScript(script,delim,statements);
}
"
"/** 
 * Construct a new  {@link ContextConfigurationAttributes} instance for the{@linkplain Class test class} that declared the{@link ContextConfiguration @ContextConfiguration} annotation and itscorresponding attributes.
 * @param declaringClass the test class that declared {@code @ContextConfiguration}
 * @param locations the resource locations declared via {@code @ContextConfiguration}
 * @param classes the annotated classes declared via {@code @ContextConfiguration}
 * @param inheritLocations the {@code inheritLocations} flag declared via {@code @ContextConfiguration}
 * @param contextLoaderClass the {@code ContextLoader} class declared via {@code @ContextConfiguration}
 * @throws IllegalArgumentException if the {@code declaringClass} or {@code contextLoaderClass} is{@code null}
 * @deprecated as of Spring 3.2, use{@link #ContextConfigurationAttributes(Class,String[],Class[],boolean,Class[],boolean,String,Class)}instead
 */
@Deprecated public ContextConfigurationAttributes(Class<?> declaringClass,String[] locations,Class<?>[] classes,boolean inheritLocations,Class<? extends ContextLoader> contextLoaderClass){
  this(declaringClass,locations,classes,inheritLocations,null,true,null,contextLoaderClass);
}
"
"/** 
 * Specify named Quartz JobListeners to be registered with the Scheduler. Such JobListeners will only apply to Jobs that explicitly activate them via their name. <p>Note that non-global JobListeners are not supported on Quartz 2.x - manually register a Matcher against the Quartz ListenerManager instead.
 * @see org.quartz.JobListener#getName
 * @see JobDetailBean#setJobListenerNames
 * @deprecated as of Spring 4.0, since it only works on Quartz 1.x
 */
@Deprecated public void setJobListeners(JobListener... jobListeners){
  this.jobListeners=jobListeners;
}
"
"/** 
 * Specify named Quartz TriggerListeners to be registered with the Scheduler. Such TriggerListeners will only apply to Triggers that explicitly activate them via their name. <p>Note that non-global TriggerListeners are not supported on Quartz 2.x - manually register a Matcher against the Quartz ListenerManager instead.
 * @see org.quartz.TriggerListener#getName
 * @see CronTriggerBean#setTriggerListenerNames
 * @see SimpleTriggerBean#setTriggerListenerNames
 * @deprecated as of Spring 4.0, since it only works on Quartz 1.x
 */
@Deprecated public void setTriggerListeners(TriggerListener... triggerListeners){
  this.triggerListeners=triggerListeners;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Constructs a new  {@code TestContextManager} for the specified {@linkplain Class test class} and automatically {@link #registerTestExecutionListeners registers} the{@link TestExecutionListener TestExecutionListeners} configured for the test classvia the  {@link TestExecutionListeners @TestExecutionListeners} annotation.
 * @param testClass the test class to be managed
 * @param defaultContextLoaderClassName the name of the default {@code ContextLoader}class to use (may be  {@code null})
 * @see #registerTestExecutionListeners(TestExecutionListener)
 * @deprecated Spring Framework 4.1 will introduce a bootstrap strategy forthe TestContext framework at which point this constructor will be removed.
 */
@Deprecated public TestContextManager(Class<?> testClass,String defaultContextLoaderClassName){
  this.testContext=new DefaultTestContext(testClass,contextCache,defaultContextLoaderClassName);
  registerTestExecutionListeners(retrieveTestExecutionListeners(testClass));
}
"
"/** 
 * Override settings in this bean definition (presumably a copied parent from a parent-child inheritance relationship) from the given bean definition (presumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Set the classes for which mappings will be read from class-level annotation metadata.
 * @see XStream#processAnnotations(Class)
 * @deprecated in favor of {@link #setAnnotatedClasses} with varargs
 */
@Deprecated public void setAnnotatedClass(Class<?> annotatedClass){
  Assert.notNull(annotatedClass,""'annotatedClass' must not be null"");
  getXStream().processAnnotations(annotatedClass);
}
"
"/** 
 * Create a linked Set if possible: This implementation always creates a  {@link java.util.LinkedHashSet}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Set
 * @return the new Set instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <T>Set<T> createLinkedSetIfPossible(int initialCapacity){
  return new LinkedHashSet<T>(initialCapacity);
}
"
"/** 
 * Create a copy-on-write Set (allowing for synchronization-less iteration) if possible: This implementation always creates a  {@link java.util.concurrent.CopyOnWriteArraySet}, since Spring 3 requires JDK 1.5 anyway.
 * @return the new Set instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static <T>Set<T> createCopyOnWriteSet(){
  return new CopyOnWriteArraySet<T>();
}
"
"/** 
 * Create a linked Map if possible: This implementation always creates a  {@link java.util.LinkedHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static <K,V>Map<K,V> createLinkedMapIfPossible(int initialCapacity){
  return new LinkedHashMap<K,V>(initialCapacity);
}
"
"/** 
 * Create a linked case-insensitive Map if possible: This implementation always returns a  {@link org.springframework.util.LinkedCaseInsensitiveMap}.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createLinkedCaseInsensitiveMapIfPossible(int initialCapacity){
  return new LinkedCaseInsensitiveMap(initialCapacity);
}
"
"/** 
 * Create an identity Map if possible: This implementation always creates a  {@link java.util.IdentityHashMap}, since Spring 2.5 requires JDK 1.4 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 2.5, for usage on JDK 1.4 or higher
 */
@Deprecated public static Map createIdentityMapIfPossible(int initialCapacity){
  return new IdentityHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map if possible: This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new Map instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static Map createConcurrentMapIfPossible(int initialCapacity){
  return new ConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Create a concurrent Map with a dedicated  {@link ConcurrentMap} interface:This implementation always creates a  {@link java.util.concurrent.ConcurrentHashMap}, since Spring 3.0 requires JDK 1.5 anyway.
 * @param initialCapacity the initial capacity of the Map
 * @return the new ConcurrentMap instance
 * @deprecated as of Spring 3.0, for usage on JDK 1.5 or higher
 */
@Deprecated public static ConcurrentMap createConcurrentMap(int initialCapacity){
  return new JdkConcurrentHashMap(initialCapacity);
}
"
"/** 
 * Replacement for  {@code Class.forName()} that also returns Class instancesfor primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return  {@code false} if either the class orone of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Set a list of JobListener names for this job, referring to non-global JobListeners registered with the Scheduler. <p>A JobListener name always refers to the name returned by the JobListener implementation.
 * @see SchedulerFactoryBean#setJobListeners
 * @see org.quartz.JobListener#getName
 * @deprecated as of Spring 4.0, since it only works on Quartz 1.x
 */
@Deprecated public void setJobListenerNames(String... names){
  this.jobListenerNames=names;
}
"
"/** 
 * Specify named Quartz JobListeners to be registered with the Scheduler. Such JobListeners will only apply to Jobs that explicitly activate them via their name. <p>Note that non-global JobListeners are not supported on Quartz 2.x - manually register a Matcher against the Quartz ListenerManager instead.
 * @see org.quartz.JobListener#getName
 * @see JobDetailBean#setJobListenerNames
 * @deprecated as of Spring 4.0, since it only works on Quartz 1.x
 */
@Deprecated public void setJobListeners(JobListener... jobListeners){
  this.jobListeners=jobListeners;
}
"
"/** 
 * Specify named Quartz TriggerListeners to be registered with the Scheduler. Such TriggerListeners will only apply to Triggers that explicitly activate them via their name. <p>Note that non-global TriggerListeners are not supported on Quartz 2.x - manually register a Matcher against the Quartz ListenerManager instead.
 * @see org.quartz.TriggerListener#getName
 * @see CronTriggerBean#setTriggerListenerNames
 * @see SimpleTriggerBean#setTriggerListenerNames
 * @deprecated as of Spring 4.0, since it only works on Quartz 1.x
 */
@Deprecated public void setTriggerListeners(TriggerListener... triggerListeners){
  this.triggerListeners=triggerListeners;
}
"
"/** 
 * Constructs a new  {@code TestContextManager} for the specified {@linkplain Class test class} and automatically {@link #registerTestExecutionListeners registers} the{@link TestExecutionListener TestExecutionListeners} configured for the test classvia the  {@link TestExecutionListeners @TestExecutionListeners} annotation.
 * @param testClass the test class to be managed
 * @param defaultContextLoaderClassName the name of the default {@code ContextLoader}class to use (may be  {@code null})
 * @see #registerTestExecutionListeners(TestExecutionListener)
 * @deprecated Spring Framework 4.1 will introduce a bootstrap strategy forthe TestContext framework at which point this constructor will be removed.
 */
@Deprecated public TestContextManager(Class<?> testClass,String defaultContextLoaderClassName){
  this.testContext=new DefaultTestContext(testClass,contextCache,defaultContextLoaderClassName);
  registerTestExecutionListeners(retrieveTestExecutionListeners(testClass));
}
"
"/** 
 * Allows for providing JAX-WS 2.2 WebServiceFeature specifications: in the form of actual  {@link javax.xml.ws.WebServiceFeature} objects,WebServiceFeature Class references, or WebServiceFeature class names. <p>As of Spring 4.0, this is effectively just an alternative way of specifying  {@link #setEndpointFeatures ""endpointFeatures""}. Do not specify both properties at the same time; prefer ""endpointFeatures"" moving forward.
 * @deprecated as of Spring 4.0, in favor of {@link #setEndpointFeatures}
 */
@Deprecated public void setWebServiceFeatures(Object[] webServiceFeatures){
  this.webServiceFeatures=webServiceFeatures;
}
"
"/** 
 * Override settings in this bean definition (presumably a copied parent from a parent-child inheritance relationship) from the given bean definition (presumably the child).
 * @deprecated since Spring 2.5, in favor of {@link #overrideFrom(BeanDefinition)}
 */
@Deprecated public void overrideFrom(AbstractBeanDefinition other){
  overrideFrom((BeanDefinition)other);
}
"
"/** 
 * Set if this a <b>Singleton</b>, with a single, shared instance returned on all calls. In case of ""false"", the BeanFactory will apply the <b>Prototype</b> design pattern, with each caller requesting an instance getting an independent instance. How this is exactly defined will depend on the BeanFactory. <p>""Singletons"" are the commoner type, so the default is ""true"". Note that as of Spring 2.0, this flag is just an alternative way to specify scope=""singleton"" or scope=""prototype"".
 * @deprecated since Spring 2.5, in favor of {@link #setScope}
 * @see #setScope
 * @see #SCOPE_SINGLETON
 * @see #SCOPE_PROTOTYPE
 */
@Deprecated public void setSingleton(boolean singleton){
  this.scope=(singleton ? SCOPE_SINGLETON : SCOPE_PROTOTYPE);
  this.singleton=singleton;
  this.prototype=!singleton;
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Determine the target type for the given parameter specification.
 * @param methodParam the method parameter specification
 * @return the corresponding generic parameter type
 * @deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()}
 */
@Deprecated public static Type getTargetType(MethodParameter methodParam){
  Assert.notNull(methodParam,""MethodParameter must not be null"");
  return methodParam.getGenericParameterType();
}
"
"/** 
 * Resolve the specified generic type against the given TypeVariable map.
 * @param genericType the generic type to resolve
 * @param map the TypeVariable Map to resolved against
 * @return the type if it resolves to a Class, or {@code Object.class} otherwise
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated @SuppressWarnings(""rawtypes"") public static Class<?> resolveType(Type genericType,Map<TypeVariable,Type> map){
  return ResolvableType.forType(genericType,new TypeVariableMapVariableResolver(map)).resolve(Object.class);
}
"
"/** 
 * Build a mapping of  {@link TypeVariable#getName TypeVariable names} to{@link Class concrete classes} for the specified {@link Class}. Searches all super types, enclosing types and interfaces.
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated @SuppressWarnings(""rawtypes"") public static Map<TypeVariable,Type> getTypeVariableMap(Class<?> clazz){
  Map<TypeVariable,Type> typeVariableMap=typeVariableCache.get(clazz);
  if (typeVariableMap == null) {
    typeVariableMap=new HashMap<TypeVariable,Type>();
    buildTypeVariableMap(ResolvableType.forClass(clazz),typeVariableMap);
    typeVariableCache.put(clazz,Collections.unmodifiableMap(typeVariableMap));
  }
  return typeVariableMap;
}
"
"/** 
 * Determine the target type for the given parameter specification.
 * @param methodParam the method parameter specification
 * @return the corresponding generic parameter type
 * @deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()}
 */
@Deprecated public static Type getTargetType(MethodParameter methodParam){
  Assert.notNull(methodParam,""MethodParameter must not be null"");
  return methodParam.getGenericParameterType();
}
"
"/** 
 * Resolve the specified generic type against the given TypeVariable map.
 * @param genericType the generic type to resolve
 * @param map the TypeVariable Map to resolved against
 * @return the type if it resolves to a Class, or {@code Object.class} otherwise
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated @SuppressWarnings(""rawtypes"") public static Class<?> resolveType(Type genericType,Map<TypeVariable,Type> map){
  return ResolvableType.forType(genericType,new TypeVariableMapVariableResolver(map)).resolve(Object.class);
}
"
"/** 
 * Build a mapping of  {@link TypeVariable#getName TypeVariable names} to{@link Class concrete classes} for the specified {@link Class}. Searches all super types, enclosing types and interfaces.
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated @SuppressWarnings(""rawtypes"") public static Map<TypeVariable,Type> getTypeVariableMap(Class<?> clazz){
  Map<TypeVariable,Type> typeVariableMap=typeVariableCache.get(clazz);
  if (typeVariableMap == null) {
    typeVariableMap=new HashMap<TypeVariable,Type>();
    buildTypeVariableMap(ResolvableType.forClass(clazz),typeVariableMap);
    typeVariableCache.put(clazz,Collections.unmodifiableMap(typeVariableMap));
  }
  return typeVariableMap;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Allows for providing JAX-WS 2.2 WebServiceFeature specifications: in the form of actual  {@link javax.xml.ws.WebServiceFeature} objects,WebServiceFeature Class references, or WebServiceFeature class names. <p>As of Spring 4.0, this is effectively just an alternative way of specifying  {@link #setEndpointFeatures ""endpointFeatures""}. Do not specify both properties at the same time; prefer ""endpointFeatures"" moving forward.
 * @deprecated as of Spring 4.0, in favor of {@link #setEndpointFeatures}
 */
@Deprecated public void setWebServiceFeatures(Object[] webServiceFeatures){
  this.webServiceFeatures=webServiceFeatures;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of HttpStatus.METHOD_FAILURE
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of HttpStatus.DESTINATION_LOCKED
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Collection} or array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Set the registration behavior by the name of the corresponding constant, e.g. ""REGISTRATION_IGNORE_EXISTING"".
 * @see #setRegistrationBehavior
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehaviorName(String registrationBehavior){
  setRegistrationBehavior(constants.asNumber(registrationBehavior).intValue());
}
"
"/** 
 * Specify what action should be taken when attempting to register an MBean under an  {@link javax.management.ObjectName} that already exists.<p>Default is REGISTRATION_FAIL_ON_EXISTING.
 * @see #setRegistrationBehaviorName(String)
 * @see #REGISTRATION_FAIL_ON_EXISTING
 * @see #REGISTRATION_IGNORE_EXISTING
 * @see #REGISTRATION_REPLACE_EXISTING
 * @deprecated since Spring 3.2, in favor of {@link #setRegistrationPolicy(RegistrationPolicy)}
 */
@Deprecated public void setRegistrationBehavior(int registrationBehavior){
  setRegistrationPolicy(RegistrationPolicy.valueOf(registrationBehavior));
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Collection} or array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorPathExtension(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    Properties props=new Properties();
    props.putAll(mediaTypes);
    this.cnManagerFactoryBean.setMediaTypes(props);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Collection} or array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorPathExtension(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    Properties props=new Properties();
    props.putAll(mediaTypes);
    this.cnManagerFactoryBean.setMediaTypes(props);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Collection} or array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Collection} or array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * @deprecated as of Spring 4.1, in favor of {@link #setBeanFactory}
 */
@Deprecated public void setApplicationContext(ApplicationContext applicationContext){
  this.beanFactory=applicationContext;
}
"
"/** 
 * Replacement for  {@code Class.forName()} that also returns Class instancesfor primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return  {@code false} if either the class orone of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.USE_PROXY} (305).
 * @deprecated matching the deprecation of {@code HttpStatus.USE_PROXY}
 */
@Deprecated public ResultMatcher isUseProxy(){
  return matcher(HttpStatus.USE_PROXY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE} (413).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE}
 * @see #isPayloadTooLarge()
 */
@Deprecated public ResultMatcher isRequestEntityTooLarge(){
  return matcher(HttpStatus.REQUEST_ENTITY_TOO_LARGE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_URI_TOO_LONG} (414).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_URI_TOO_LONG}
 * @see #isUriTooLong()
 */
@Deprecated public ResultMatcher isRequestUriTooLong(){
  return matcher(HttpStatus.REQUEST_URI_TOO_LONG);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE}
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of {@code HttpStatus.METHOD_FAILURE}
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of {@code HttpStatus.DESTINATION_LOCKED}
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Construct a new  {@link ContextConfigurationAttributes} instance for the{@linkplain Class test class} that declared the{@link ContextConfiguration @ContextConfiguration} annotation and itscorresponding attributes.
 * @param declaringClass the test class that declared {@code @ContextConfiguration}
 * @param locations the resource locations declared via {@code @ContextConfiguration}
 * @param classes the annotated classes declared via {@code @ContextConfiguration}
 * @param inheritLocations the {@code inheritLocations} flag declared via {@code @ContextConfiguration}
 * @param contextLoaderClass the {@code ContextLoader} class declared via {@code @ContextConfiguration}
 * @throws IllegalArgumentException if the {@code declaringClass} or {@code contextLoaderClass} is{@code null}
 * @deprecated as of Spring 3.2, use{@link #ContextConfigurationAttributes(Class,String[],Class[],boolean,Class[],boolean,String,Class)}instead
 */
@Deprecated public ContextConfigurationAttributes(Class<?> declaringClass,String[] locations,Class<?>[] classes,boolean inheritLocations,Class<? extends ContextLoader> contextLoaderClass){
  this(declaringClass,locations,classes,inheritLocations,null,true,null,contextLoaderClass);
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Construct a new  {@link ContextConfigurationAttributes} instance for the{@linkplain Class test class} that declared the{@link ContextConfiguration @ContextConfiguration} annotation and itscorresponding attributes.
 * @param declaringClass the test class that declared {@code @ContextConfiguration}
 * @param locations the resource locations declared via {@code @ContextConfiguration}
 * @param classes the annotated classes declared via {@code @ContextConfiguration}
 * @param inheritLocations the {@code inheritLocations} flag declared via {@code @ContextConfiguration}
 * @param contextLoaderClass the {@code ContextLoader} class declared via {@code @ContextConfiguration}
 * @throws IllegalArgumentException if the {@code declaringClass} or {@code contextLoaderClass} is{@code null}
 * @deprecated as of Spring 3.2, use{@link #ContextConfigurationAttributes(Class,String[],Class[],boolean,Class[],boolean,String,Class)}instead
 */
@Deprecated public ContextConfigurationAttributes(Class<?> declaringClass,String[] locations,Class<?>[] classes,boolean inheritLocations,Class<? extends ContextLoader> contextLoaderClass){
  this(declaringClass,locations,classes,inheritLocations,null,true,null,contextLoaderClass);
}
"
"/** 
 * Construct a new  {@link ContextConfigurationAttributes} instance for the{@linkplain Class test class} that declared the{@link ContextConfiguration @ContextConfiguration} annotation and itscorresponding attributes.
 * @param declaringClass the test class that declared {@code @ContextConfiguration}
 * @param locations the resource locations declared via {@code @ContextConfiguration}
 * @param classes the annotated classes declared via {@code @ContextConfiguration}
 * @param inheritLocations the {@code inheritLocations} flag declared via {@code @ContextConfiguration}
 * @param contextLoaderClass the {@code ContextLoader} class declared via {@code @ContextConfiguration}
 * @throws IllegalArgumentException if the {@code declaringClass} or {@code contextLoaderClass} is{@code null}
 * @deprecated as of Spring 3.2, use{@link #ContextConfigurationAttributes(Class,String[],Class[],boolean,Class[],boolean,String,Class)}instead
 */
@Deprecated public ContextConfigurationAttributes(Class<?> declaringClass,String[] locations,Class<?>[] classes,boolean inheritLocations,Class<? extends ContextLoader> contextLoaderClass){
  this(declaringClass,locations,classes,inheritLocations,null,true,null,contextLoaderClass);
}
"
"/** 
 * Add a  {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.
 * @deprecated in favor of {@link #addDeclaredRowMapper(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public void addDeclaredRowMapper(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,(RowMapper)rowMapper);
}
"
"/** 
 * Construct a new  {@link ContextConfigurationAttributes} instance for the{@linkplain Class test class} that declared the{@link ContextConfiguration @ContextConfiguration} annotation and itscorresponding attributes.
 * @param declaringClass the test class that declared {@code @ContextConfiguration}
 * @param locations the resource locations declared via {@code @ContextConfiguration}
 * @param classes the annotated classes declared via {@code @ContextConfiguration}
 * @param inheritLocations the {@code inheritLocations} flag declared via {@code @ContextConfiguration}
 * @param contextLoaderClass the {@code ContextLoader} class declared via {@code @ContextConfiguration}
 * @throws IllegalArgumentException if the {@code declaringClass} or {@code contextLoaderClass} is{@code null}
 * @deprecated as of Spring 3.2, use{@link #ContextConfigurationAttributes(Class,String[],Class[],boolean,Class[],boolean,String,Class)}instead
 */
@Deprecated public ContextConfigurationAttributes(Class<?> declaringClass,String[] locations,Class<?>[] classes,boolean inheritLocations,Class<? extends ContextLoader> contextLoaderClass){
  this(declaringClass,locations,classes,inheritLocations,null,true,null,contextLoaderClass);
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.MOVED_TEMPORARILY} (302).
 * @see #isFound()
 * @deprecated in favor of {@link #isFound()}
 */
@Deprecated public ResultMatcher isMovedTemporarily(){
  return matcher(HttpStatus.MOVED_TEMPORARILY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.USE_PROXY} (305).
 * @deprecated matching the deprecation of {@code HttpStatus.USE_PROXY}
 */
@Deprecated public ResultMatcher isUseProxy(){
  return matcher(HttpStatus.USE_PROXY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE} (413).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE}
 * @see #isPayloadTooLarge()
 */
@Deprecated public ResultMatcher isRequestEntityTooLarge(){
  return matcher(HttpStatus.REQUEST_ENTITY_TOO_LARGE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_URI_TOO_LONG} (414).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_URI_TOO_LONG}
 * @see #isUriTooLong()
 */
@Deprecated public ResultMatcher isRequestUriTooLong(){
  return matcher(HttpStatus.REQUEST_URI_TOO_LONG);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE}
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of {@code HttpStatus.METHOD_FAILURE}
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of {@code HttpStatus.DESTINATION_LOCKED}
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied parameters. <p>Delegates to {@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @see #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)
 * @deprecated as of Spring 3.2.2, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)} instead.
 */
@Deprecated public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,null,null,resourceBasePath,contextLoader,null,null);
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied parameters. <p>Delegates to {@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @param cacheAwareContextLoaderDelegate a cache-aware context loaderdelegate with which to retrieve the parent context
 * @param parent the parent configuration or {@code null} if there is no parent
 * @since 3.2.2
 * @deprecated as of Spring 4.1, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}instead.
 */
@Deprecated public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader,CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,MergedContextConfiguration parent){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,null,null,resourceBasePath,contextLoader,cacheAwareContextLoaderDelegate,parent);
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied parameters. <p>Delegates to {@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @see #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)
 * @deprecated as of Spring 3.2.2, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)} instead.
 */
@Deprecated public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,null,null,resourceBasePath,contextLoader,null,null);
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied parameters. <p>Delegates to {@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @param cacheAwareContextLoaderDelegate a cache-aware context loaderdelegate with which to retrieve the parent context
 * @param parent the parent configuration or {@code null} if there is no parent
 * @since 3.2.2
 * @deprecated as of Spring 4.1, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}instead.
 */
public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader,CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,MergedContextConfiguration parent){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,null,null,resourceBasePath,contextLoader,cacheAwareContextLoaderDelegate,parent);
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied parameters. <p>Delegates to {@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @see #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)
 * @deprecated as of Spring 3.2.2, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)} instead.
 */
@Deprecated public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,null,null,resourceBasePath,contextLoader,null,null);
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied parameters. <p>Delegates to {@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @param cacheAwareContextLoaderDelegate a cache-aware context loaderdelegate with which to retrieve the parent context
 * @param parent the parent configuration or {@code null} if there is no parent
 * @since 3.2.2
 * @deprecated as of Spring 4.1, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}instead.
 */
@Deprecated public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader,CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,MergedContextConfiguration parent){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,null,null,resourceBasePath,contextLoader,cacheAwareContextLoaderDelegate,parent);
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied parameters. <p>Delegates to {@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @see #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)
 * @deprecated as of Spring 3.2.2, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)} instead.
 */
@Deprecated public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,null,null,resourceBasePath,contextLoader,null,null);
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied parameters. <p>Delegates to {@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @param cacheAwareContextLoaderDelegate a cache-aware context loaderdelegate with which to retrieve the parent context
 * @param parent the parent configuration or {@code null} if there is no parent
 * @since 3.2.2
 * @deprecated as of Spring 4.1, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}instead.
 */
public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader,CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,MergedContextConfiguration parent){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,null,null,resourceBasePath,contextLoader,cacheAwareContextLoaderDelegate,parent);
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied parameters. <p>Delegates to {@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @see #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)
 * @deprecated as of Spring 3.2.2, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)} instead.
 */
@Deprecated public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,null,null,resourceBasePath,contextLoader,null,null);
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied parameters. <p>Delegates to {@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @param cacheAwareContextLoaderDelegate a cache-aware context loaderdelegate with which to retrieve the parent context
 * @param parent the parent configuration or {@code null} if there is no parent
 * @since 3.2.2
 * @deprecated as of Spring 4.1, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}instead.
 */
@Deprecated public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader,CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,MergedContextConfiguration parent){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,null,null,resourceBasePath,contextLoader,cacheAwareContextLoaderDelegate,parent);
}
"
"/** 
 * Specify named Quartz JobListeners to be registered with the Scheduler. Such JobListeners will only apply to Jobs that explicitly activate them via their name. <p>Note that non-global JobListeners are not supported on Quartz 2.x - manually register a Matcher against the Quartz ListenerManager instead.
 * @see org.quartz.JobListener#getName
 * @see JobDetailBean#setJobListenerNames
 * @deprecated as of Spring 4.0, since it only works on Quartz 1.x
 */
@Deprecated public void setJobListeners(JobListener... jobListeners){
  this.jobListeners=jobListeners;
}
"
"/** 
 * Specify named Quartz TriggerListeners to be registered with the Scheduler. Such TriggerListeners will only apply to Triggers that explicitly activate them via their name. <p>Note that non-global TriggerListeners are not supported on Quartz 2.x - manually register a Matcher against the Quartz ListenerManager instead.
 * @see org.quartz.TriggerListener#getName
 * @see CronTriggerBean#setTriggerListenerNames
 * @see SimpleTriggerBean#setTriggerListenerNames
 * @deprecated as of Spring 4.0, since it only works on Quartz 1.x
 */
@Deprecated public void setTriggerListeners(TriggerListener... triggerListeners){
  this.triggerListeners=triggerListeners;
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * @deprecated as of Spring 4.1, in favor of {@link #setBeanFactory}
 */
@Deprecated public void setApplicationContext(ApplicationContext applicationContext){
  if (this.beanFactory == null) {
    this.beanFactory=applicationContext;
  }
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied  {@link XmlReaderContext} and a new {@link StandardEnvironment}.
 * @deprecated since Spring 3.1 in favor of{@link #BeanDefinitionParserDelegate(XmlReaderContext,Environment)}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext){
  this(readerContext,new StandardEnvironment());
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Create a new BeanDefinitionParserDelegate associated with the supplied {@link XmlReaderContext}.
 * @deprecated since the given {@link Environment} parameter is effectivelyignored in favor of  {@link XmlReaderContext#getEnvironment()}
 */
@Deprecated public BeanDefinitionParserDelegate(XmlReaderContext readerContext,Environment environment){
  this(readerContext);
}
"
"/** 
 * Get the  {@link Environment} associated with this helper instance.
 * @deprecated in favor of {@link XmlReaderContext#getEnvironment()}
 */
@Deprecated public final Environment getEnvironment(){
  return this.readerContext.getEnvironment();
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Collection} or array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Collection} or array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * @deprecated as of Spring 4.1, in favor of {@link #setBeanFactory}
 */
@Deprecated public void setApplicationContext(ApplicationContext applicationContext){
  if (this.beanFactory == null) {
    this.beanFactory=applicationContext;
  }
}
"
"/** 
 * Check whether the specified class is a CGLIB-generated class.
 * @param clazz the class to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)}
 */
@Deprecated public static boolean isCglibProxyClass(Class<?> clazz){
  return ClassUtils.isCglibProxyClass(clazz);
}
"
"/** 
 * Check whether the specified class name is a CGLIB-generated class.
 * @param className the class name to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)}
 */
@Deprecated public static boolean isCglibProxyClassName(String className){
  return ClassUtils.isCglibProxyClassName(className);
}
"
"/** 
 * Check whether the specified class is a CGLIB-generated class.
 * @param clazz the class to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)}
 */
@Deprecated public static boolean isCglibProxyClass(Class<?> clazz){
  return ClassUtils.isCglibProxyClass(clazz);
}
"
"/** 
 * Check whether the specified class name is a CGLIB-generated class.
 * @param className the class name to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)}
 */
@Deprecated public static boolean isCglibProxyClassName(String className){
  return ClassUtils.isCglibProxyClassName(className);
}
"
"/** 
 * Check whether the specified class is a CGLIB-generated class.
 * @param clazz the class to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClass(Class)}
 */
@Deprecated public static boolean isCglibProxyClass(Class<?> clazz){
  return ClassUtils.isCglibProxyClass(clazz);
}
"
"/** 
 * Check whether the specified class name is a CGLIB-generated class.
 * @param className the class name to check
 * @deprecated as of Spring 3.1 in favor of {@link ClassUtils#isCglibProxyClassName(String)}
 */
@Deprecated public static boolean isCglibProxyClassName(String className){
  return ClassUtils.isCglibProxyClassName(className);
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Returns the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @return the header value
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Return the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Return the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is false)
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.MOVED_TEMPORARILY} (302).
 * @see #isFound()
 * @deprecated in favor of {@link #isFound()}
 */
@Deprecated public ResultMatcher isMovedTemporarily(){
  return matcher(HttpStatus.MOVED_TEMPORARILY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.USE_PROXY} (305).
 * @deprecated matching the deprecation of {@code HttpStatus.USE_PROXY}
 */
@Deprecated public ResultMatcher isUseProxy(){
  return matcher(HttpStatus.USE_PROXY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE} (413).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE}
 * @see #isPayloadTooLarge()
 */
@Deprecated public ResultMatcher isRequestEntityTooLarge(){
  return matcher(HttpStatus.REQUEST_ENTITY_TOO_LARGE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_URI_TOO_LONG} (414).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_URI_TOO_LONG}
 * @see #isUriTooLong()
 */
@Deprecated public ResultMatcher isRequestUriTooLong(){
  return matcher(HttpStatus.REQUEST_URI_TOO_LONG);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE}
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of {@code HttpStatus.METHOD_FAILURE}
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of {@code HttpStatus.DESTINATION_LOCKED}
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorPathExtension(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    Properties props=new Properties();
    props.putAll(mediaTypes);
    this.cnManagerFactoryBean.setMediaTypes(props);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * @deprecated as of Spring 4.1, in favor of {@link #setBeanFactory}
 */
@Deprecated public void setApplicationContext(ApplicationContext applicationContext){
  if (this.beanFactory == null) {
    this.beanFactory=applicationContext;
  }
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Collection} or array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Collection or Array type
 */
@Deprecated public Class<?> getElementType(){
  return getElementTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapKeyType(){
  return getMapKeyTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a java.util.Map
 */
@Deprecated public Class<?> getMapValueType(){
  return getMapValueTypeDescriptor().getType();
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Collection} or array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Call this method to signal that the  {@linkplain ApplicationContext applicationcontext} associated with this test context is <em>dirty</em> and should bediscarded. Do this if a test has modified the context &mdash; for example, by replacing a bean definition or modifying the state of a singleton bean.
 * @deprecated as of Spring 3.2.2; use{@link #markApplicationContextDirty(DirtiesContext.HierarchyMode)} instead.
 */
@Deprecated public void markApplicationContextDirty(){
  markApplicationContextDirty((HierarchyMode)null);
}
"
"/** 
 * Add a  {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.
 * @deprecated in favor of {@link #addDeclaredRowMapper(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public void addDeclaredRowMapper(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,(RowMapper)rowMapper);
}
"
"/** 
 * @deprecated in favor of {@link #returningResultSet(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public SimpleJdbcCall returningResultSet(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,rowMapper);
  return this;
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Collection} or array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Check whether MXBean support is available, i.e. whether we're running on Java 6 or above.
 * @return {@code true} if available; {@code false} otherwise
 * @deprecated as of Spring 4.0, since Java 6 is required anyway now
 */
@Deprecated public static boolean isMXBeanSupportAvailable(){
  return true;
}
"
"/** 
 * Check whether MXBean support is available, i.e. whether we're running on Java 6 or above.
 * @return {@code true} if available; {@code false} otherwise
 * @deprecated as of Spring 4.0, since Java 6 is required anyway now
 */
@Deprecated public static boolean isMXBeanSupportAvailable(){
  return true;
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is false)
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is false)
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is false)
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied parameters. <p>Delegates to {@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @see #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)
 * @deprecated as of Spring 3.2.2, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)} instead.
 */
@Deprecated public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,null,null,resourceBasePath,contextLoader,null,null);
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied parameters. <p>Delegates to {@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @param cacheAwareContextLoaderDelegate a cache-aware context loaderdelegate with which to retrieve the parent context
 * @param parent the parent configuration or {@code null} if there is no parent
 * @since 3.2.2
 * @deprecated as of Spring 4.1, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}instead.
 */
@Deprecated public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader,CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,MergedContextConfiguration parent){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,null,null,resourceBasePath,contextLoader,cacheAwareContextLoaderDelegate,parent);
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied parameters. <p>Delegates to {@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @param cacheAwareContextLoaderDelegate a cache-aware context loaderdelegate with which to retrieve the parent context
 * @param parent the parent configuration or {@code null} if there is no parent
 * @since 3.2.2
 * @deprecated as of Spring 4.1, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}instead.
 */
@Deprecated public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader,CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,MergedContextConfiguration parent){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,null,null,resourceBasePath,contextLoader,cacheAwareContextLoaderDelegate,parent);
}
"
"/** 
 * Get the  {@link Environment} associated with this helper instance.
 * @deprecated in favor of {@link XmlReaderContext#getEnvironment()}
 */
@Deprecated public final Environment getEnvironment(){
  return this.readerContext.getEnvironment();
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied parameters. <p>Delegates to {@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @param cacheAwareContextLoaderDelegate a cache-aware context loaderdelegate with which to retrieve the parent context
 * @param parent the parent configuration or {@code null} if there is no parent
 * @since 3.2.2
 * @deprecated as of Spring 4.1, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}instead.
 */
@Deprecated public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader,CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,MergedContextConfiguration parent){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,null,null,resourceBasePath,contextLoader,cacheAwareContextLoaderDelegate,parent);
}
"
"/** 
 * Set the default maximum request size. <p>By default this is set to  {@link #DEFAULT_MAX_REQUEST_SIZE}.
 * @see HttpObjectAggregator#HttpObjectAggregator(int)
 * @deprecated as of 4.1.5 this property is no longer supported;effectively renamed to  {@link #setMaxResponseSize(int)}.
 */
public void setMaxRequestSize(int maxRequestSize){
  this.maxRequestSize=maxRequestSize;
}
"
"/** 
 * Set the default maximum request size. <p>By default this is set to  {@link #DEFAULT_MAX_REQUEST_SIZE}.
 * @see HttpObjectAggregator#HttpObjectAggregator(int)
 * @deprecated as of 4.1.5 this property is no longer supported;effectively renamed to  {@link #setMaxResponseSize(int)}.
 */
@Deprecated public void setMaxRequestSize(int maxRequestSize){
  this.maxRequestSize=maxRequestSize;
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is false)
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is false)
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is false)
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is false)
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is false)
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is false)
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is false)
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is false)
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorPathExtension(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    Properties props=new Properties();
    props.putAll(mediaTypes);
    this.cnManagerFactoryBean.setMediaTypes(props);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a lastModified calculation as described in {@link WebRequest#checkNotModified(long)}. Default is ""false"".
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.MOVED_TEMPORARILY} (302).
 * @see #isFound()
 * @deprecated in favor of {@link #isFound()}
 */
@Deprecated public ResultMatcher isMovedTemporarily(){
  return matcher(HttpStatus.MOVED_TEMPORARILY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.USE_PROXY} (305).
 * @deprecated matching the deprecation of {@code HttpStatus.USE_PROXY}
 */
@Deprecated public ResultMatcher isUseProxy(){
  return matcher(HttpStatus.USE_PROXY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE} (413).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE}
 * @see #isPayloadTooLarge()
 */
@Deprecated public ResultMatcher isRequestEntityTooLarge(){
  return matcher(HttpStatus.REQUEST_ENTITY_TOO_LARGE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_URI_TOO_LONG} (414).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_URI_TOO_LONG}
 * @see #isUriTooLong()
 */
@Deprecated public ResultMatcher isRequestUriTooLong(){
  return matcher(HttpStatus.REQUEST_URI_TOO_LONG);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE}
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of {@code HttpStatus.METHOD_FAILURE}
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of {@code HttpStatus.DESTINATION_LOCKED}
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is false)
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is false)
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Get the  {@link Environment} associated with this helper instance.
 * @deprecated in favor of {@link XmlReaderContext#getEnvironment()}
 */
@Deprecated public final Environment getEnvironment(){
  return this.readerContext.getEnvironment();
}
"
"/** 
 * See  {@link #fromMethod(Class,Method,Object)}.
 * @deprecated as of 4.2 this is deprecated in favor of the overloadedmethod that also accepts a controllerType.
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @deprecated as of 4.2 deprecated in favor of alternative constructorsthat accept the controllerType.
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * See  {@link #fromMethod(Class,Method,Object)}.
 * @deprecated as of 4.2 this is deprecated in favor of the overloadedmethod that also accepts a controllerType.
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @deprecated as of 4.2 deprecated in favor of alternative constructorsthat accept the controllerType.
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * Get the  {@link Environment} associated with this helper instance.
 * @deprecated in favor of {@link XmlReaderContext#getEnvironment()}
 */
@Deprecated public final Environment getEnvironment(){
  return this.readerContext.getEnvironment();
}
"
"/** 
 * See  {@link #fromMethod(Class,Method,Object)}.
 * @deprecated as of 4.2 this is deprecated in favor of the overloadedmethod that also accepts a controllerType.
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @deprecated as of 4.2 deprecated in favor of alternative constructorsthat accept the controllerType.
 */
@Deprecated @SuppressWarnings(""unused"") public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * See  {@link #fromMethod(Class,Method,Object)}.
 * @deprecated as of 4.2 this is deprecated in favor of the overloadedmethod that also accepts a controllerType.
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @deprecated as of 4.2 deprecated in favor of alternative constructorsthat accept the controllerType.
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a lastModified calculation as described in {@link WebRequest#checkNotModified(long)}. Default is ""false"".
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Replacement for  {@code Class.forName()} that also returns Class instancesfor primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return  {@code false} if either the class orone of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Provide a registry with which to register active user session ids.
 * @see org.springframework.messaging.simp.user.UserDestinationMessageHandler
 * @deprecated as of 4.2 in favor of {@link DefaultSimpUserRegistry} which relieson the ApplicationContext events published by this class and is created via {@link org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#createLocalUserRegistry WebSocketMessageBrokerConfigurationSupport.createLocalUserRegistry}
 */
@Deprecated public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry){
  this.userSessionRegistry=registry;
}
"
"/** 
 * @deprecated as of 4.2
 */
@Deprecated public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry(){
  return this.userSessionRegistry;
}
"
"/** 
 * Provide a registry with which to register active user session ids.
 * @see org.springframework.messaging.simp.user.UserDestinationMessageHandler
 * @deprecated as of 4.2 in favor of {@link DefaultSimpUserRegistry} which relieson the ApplicationContext events published by this class and is created via {@link org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#createLocalUserRegistry WebSocketMessageBrokerConfigurationSupport.createLocalUserRegistry}
 */
@Deprecated public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry){
  this.userSessionRegistry=registry;
}
"
"/** 
 * @deprecated as of 4.2
 */
@Deprecated public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry(){
  return this.userSessionRegistry;
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is {@code false})
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is {@code false})
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is {@code false})
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * See  {@link #fromMethod(Class,Method,Object)}.
 * @deprecated as of 4.2 this is deprecated in favor of the overloadedmethod that also accepts a controllerType.
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @deprecated as of 4.2 deprecated in favor of alternative constructorsthat accept the controllerType.
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * See  {@link #fromMethod(Class,Method,Object)}.
 * @deprecated as of 4.2 this is deprecated in favor of the overloadedmethod that also accepts a controllerType.
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @deprecated as of 4.2 deprecated in favor of alternative constructorsthat accept the controllerType.
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * See  {@link #fromMethod(Class,Method,Object)}.
 * @deprecated as of 4.2 this is deprecated in favor of the overloadedmethod that also accepts a controllerType.
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @deprecated as of 4.2 deprecated in favor of alternative constructorsthat accept the controllerType.
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a lastModified calculation as described in {@link WebRequest#checkNotModified(long)}. Default is ""false"".
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * See  {@link #fromMethod(Class,Method,Object)}.
 * @deprecated as of 4.2 this is deprecated in favor of the overloadedmethod that also accepts a controllerType.
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @deprecated as of 4.2 deprecated in favor of alternative constructorsthat accept the controllerType.
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * See  {@link #fromMethod(Class,Method,Object)}.
 * @deprecated as of 4.2 this is deprecated in favor of the overloadedmethod that also accepts a controllerType.
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @deprecated as of 4.2 deprecated in favor of alternative constructorsthat accept the controllerType.
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations}.
 * @since 4.0
 * @deprecated As of Spring Framework 4.2, use {@link #getRepeatableAnnotations}or  {@link #getDeclaredRepeatableAnnotations} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations}.
 * @since 4.0
 * @deprecated As of Spring Framework 4.2, use {@link #getRepeatableAnnotations}or  {@link #getDeclaredRepeatableAnnotations} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * See  {@link #fromMethod(Class,Method,Object)}.
 * @deprecated as of 4.2 this is deprecated in favor of the overloadedmethod that also accepts a controllerType.
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @deprecated as of 4.2 deprecated in favor of alternative constructorsthat accept the controllerType.
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations}.
 * @since 4.0
 * @deprecated As of Spring Framework 4.2, use {@link #getRepeatableAnnotations}or  {@link #getDeclaredRepeatableAnnotations} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations}.
 * @since 4.0
 * @deprecated As of Spring Framework 4.2, use {@link #getRepeatableAnnotations}or  {@link #getDeclaredRepeatableAnnotations} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations}.
 * @since 4.0
 * @deprecated As of Spring Framework 4.2, use {@link #getRepeatableAnnotations}or  {@link #getDeclaredRepeatableAnnotations} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations}.
 * @since 4.0
 * @deprecated As of Spring Framework 4.2, use {@link #getRepeatableAnnotations}or  {@link #getDeclaredRepeatableAnnotations} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * See  {@link #fromMethod(Class,Method,Object)}.
 * @deprecated as of 4.2 this is deprecated in favor of the overloadedmethod that also accepts a controllerType.
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @deprecated as of 4.2 deprecated in favor of alternative constructorsthat accept the controllerType.
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is {@code false})
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a lastModified calculation as described in {@link WebRequest#checkNotModified(long)}. Default is ""false"".
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is {@code false})
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations}.
 * @since 4.0
 * @deprecated As of Spring Framework 4.2, use {@link #getRepeatableAnnotations}or  {@link #getDeclaredRepeatableAnnotations} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,containerAnnotationType,annotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations}.
 * @since 4.0
 * @deprecated As of Spring Framework 4.2, use {@link #getRepeatableAnnotations}or  {@link #getDeclaredRepeatableAnnotations} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,containerAnnotationType,annotationType);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.MOVED_TEMPORARILY} (302).
 * @see #isFound()
 * @deprecated in favor of {@link #isFound()}
 */
@Deprecated public ResultMatcher isMovedTemporarily(){
  return matcher(HttpStatus.MOVED_TEMPORARILY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.USE_PROXY} (305).
 * @deprecated matching the deprecation of {@code HttpStatus.USE_PROXY}
 */
@Deprecated public ResultMatcher isUseProxy(){
  return matcher(HttpStatus.USE_PROXY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE} (413).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE}
 * @see #isPayloadTooLarge()
 */
@Deprecated public ResultMatcher isRequestEntityTooLarge(){
  return matcher(HttpStatus.REQUEST_ENTITY_TOO_LARGE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_URI_TOO_LONG} (414).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_URI_TOO_LONG}
 * @see #isUriTooLong()
 */
@Deprecated public ResultMatcher isRequestUriTooLong(){
  return matcher(HttpStatus.REQUEST_URI_TOO_LONG);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE}
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of {@code HttpStatus.METHOD_FAILURE}
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of {@code HttpStatus.DESTINATION_LOCKED}
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a lastModified calculation as described in {@link WebRequest#checkNotModified(long)}. Default is ""false"".
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a lastModified calculation as described in {@link WebRequest#checkNotModified(long)}. Default is ""false"".
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated in favor of {@link #getCacheControl}.
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated in favor of {@link #getCacheControl}.
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated in favor of {@link #getCacheControl}.
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a lastModified calculation as described in {@link WebRequest#checkNotModified(long)}. Default is ""false"".
 * @deprecated in favor of {@link #setCacheSeconds} or {@link #setCacheControl}.
 */
@Deprecated public void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
  this.usePreviousHttpCachingBehavior=true;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated in favor of {@link #getCacheControl}.
 */
@Deprecated public boolean isAlwaysMustRevalidate(){
  return alwaysMustRevalidate;
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * Convert the message payload from serialized form to an Object.
 * @deprecated as of Spring 4.2, in favor of {@link #convertFromInternal(Message,Class,Object)}(which is also protected instead of public)
 */
@Deprecated public Object convertFromInternal(Message<?> message,Class<?> targetClass){
  return null;
}
"
"/** 
 * Convert the payload object to serialized form.
 * @deprecated as of Spring 4.2, in favor of {@link #convertFromInternal(Message,Class,Object)}(which is also protected instead of public)
 */
@Deprecated public Object convertToInternal(Object payload,MessageHeaders headers){
  return null;
}
"
"/** 
 * Configure headers to be added to every executed HTTP request.
 * @param requestHeaders the headers to add to requests
 * @deprecated as of 4.2 in favor of {@link SockJsClient#setHttpHeaderNames}.
 */
@Deprecated public void setRequestHeaders(HttpHeaders requestHeaders){
  this.requestHeaders.clear();
  if (requestHeaders != null) {
    this.requestHeaders.putAll(requestHeaders);
  }
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Return the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * @see #fromMethod(Class,Method,Object)
 * @see #fromMethod(UriComponentsBuilder,Class,Method,Object)
 * @deprecated as of 4.2, this is deprecated in favor of the overloadedmethod that also accepts a controllerType argument
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @see #MethodArgumentBuilder(Class,Method)
 * @deprecated as of 4.2, this is deprecated in favor of alternative constructorsthat accept a controllerType argument
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * Convert the message payload from serialized form to an Object.
 * @deprecated as of Spring 4.2, in favor of {@link #convertFromInternal(Message,Class,Object)}(which is also protected instead of public)
 */
@Deprecated public Object convertFromInternal(Message<?> message,Class<?> targetClass){
  return null;
}
"
"/** 
 * Convert the payload object to serialized form.
 * @deprecated as of Spring 4.2, in favor of {@link #convertFromInternal(Message,Class,Object)}(which is also protected instead of public)
 */
@Deprecated public Object convertToInternal(Object payload,MessageHeaders headers){
  return null;
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Provide a registry with which to register active user session ids.
 * @see org.springframework.messaging.simp.user.UserDestinationMessageHandler
 * @deprecated as of 4.2 in favor of {@link DefaultSimpUserRegistry} which relieson the ApplicationContext events published by this class and is created via {@link org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#createLocalUserRegistry WebSocketMessageBrokerConfigurationSupport.createLocalUserRegistry}
 */
@Deprecated public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry){
  this.userSessionRegistry=registry;
}
"
"/** 
 * @deprecated as of 4.2
 */
@Deprecated public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry(){
  return this.userSessionRegistry;
}
"
"/** 
 * Provide a registry with which to register active user session ids.
 * @see org.springframework.messaging.simp.user.UserDestinationMessageHandler
 * @deprecated as of 4.2 in favor of {@link DefaultSimpUserRegistry} which relieson the ApplicationContext events published by this class and is created via {@link org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#createLocalUserRegistry WebSocketMessageBrokerConfigurationSupport.createLocalUserRegistry}
 */
@Deprecated public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry){
  this.userSessionRegistry=registry;
}
"
"/** 
 * @deprecated as of 4.2
 */
@Deprecated public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry(){
  return this.userSessionRegistry;
}
"
"/** 
 * Configure headers to be added to every executed HTTP request.
 * @param requestHeaders the headers to add to requests
 * @deprecated as of 4.2 in favor of {@link SockJsClient#setHttpHeaderNames}.
 */
@Deprecated public void setRequestHeaders(HttpHeaders requestHeaders){
  this.requestHeaders.clear();
  if (requestHeaders != null) {
    this.requestHeaders.putAll(requestHeaders);
  }
}
"
"/** 
 * Look for the WebApplicationContext associated with the DispatcherServlet that has initiated request processing.
 * @param request current HTTP request
 * @return the request-specific web application context
 * @throws IllegalStateException if no servlet-specific context has been found
 * @see #getWebApplicationContext(ServletRequest,ServletContext)
 * @deprecated as of Spring 4.2.1, in favor of{@link #findWebApplicationContext(HttpServletRequest)}
 */
@Deprecated public static WebApplicationContext getWebApplicationContext(ServletRequest request) throws IllegalStateException {
  return getWebApplicationContext(request,null);
}
"
"/** 
 * Look for the WebApplicationContext associated with the DispatcherServlet that has initiated request processing, and for the global context if none was found associated with the current request. This method is useful to allow components outside the framework, such as JSP tag handlers, to access the most specific application context available.
 * @param request current HTTP request
 * @param servletContext current servlet context
 * @return the request-specific WebApplicationContext, or the global oneif no request-specific context has been found
 * @throws IllegalStateException if neither a servlet-specific nor aglobal context has been found
 * @see DispatcherServlet#WEB_APPLICATION_CONTEXT_ATTRIBUTE
 * @see WebApplicationContextUtils#getRequiredWebApplicationContext(ServletContext)
 * @deprecated as of Spring 4.2.1, in favor of{@link #findWebApplicationContext(HttpServletRequest,ServletContext)}
 */
@Deprecated public static WebApplicationContext getWebApplicationContext(ServletRequest request,ServletContext servletContext) throws IllegalStateException {
  WebApplicationContext webApplicationContext=(WebApplicationContext)request.getAttribute(DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE);
  if (webApplicationContext == null) {
    if (servletContext == null) {
      throw new IllegalStateException(""No WebApplicationContext found: not in a DispatcherServlet request?"");
    }
    webApplicationContext=WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);
  }
  return webApplicationContext;
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getElementTypeDescriptor() elementTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getElementTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Collection} or array type
 */
@Deprecated public Class<?> getElementType(){
  return getType(getElementTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapKeyTypeDescriptor() getMapKeyTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapKeyTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapKeyType(){
  return getType(getMapKeyTypeDescriptor());
}
"
"/** 
 * Returns the value of  {@link TypeDescriptor#getType() getType()} for the{@link #getMapValueTypeDescriptor() getMapValueTypeDescriptor}.
 * @deprecated in Spring 3.1 in favor of {@link #getMapValueTypeDescriptor()}
 * @throws IllegalStateException if this type is not a {@code java.util.Map}
 */
@Deprecated public Class<?> getMapValueType(){
  return getType(getMapValueTypeDescriptor());
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorPathExtension(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    Properties props=new Properties();
    props.putAll(mediaTypes);
    this.cnManagerFactoryBean.setMediaTypes(props);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is {@code false})
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Set the attributes in the model that should be rendered by this view. When set, all other model attributes will be ignored.
 * @deprecated use {@link #setModelKeys(Set)} instead
 */
@Deprecated public void setRenderedAttributes(Set<String> renderedAttributes){
  this.modelKeys=renderedAttributes;
}
"
"/** 
 * Return the attributes in the model that should be rendered by this view.
 * @deprecated use {@link #getModelKeys()} instead
 */
@Deprecated public final Set<String> getRenderedAttributes(){
  return this.modelKeys;
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is {@code false})
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorPathExtension(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    Properties props=new Properties();
    props.putAll(mediaTypes);
    this.cnManagerFactoryBean.setMediaTypes(props);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element} andmerge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy. <p>Attributes from lower levels in the annotation hierarchy override attributes of the same name from higher levels, and {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>In contrast to  {@link #getAllAnnotationAttributes}, the search algorithm used by this method will stop searching the annotation hierarchy once the first annotation of the specified {@code annotationName} has been found. As a consequence, additionalannotations of the specified  {@code annotationName} will be ignored.<p>This method follows <em>find semantics</em> as described in the {@linkplain AnnotatedElementUtils class-level javadoc}.
 * @param element the annotated element
 * @param annotationType the annotation type to find
 * @param classValuesAsString whether to convert Class references intoStrings or to preserve them as Class references
 * @param nestedAnnotationsAsMap whether to convert nested Annotationinstances into  {@code AnnotationAttributes} maps or to preserve themas Annotation instances
 * @return the merged {@code AnnotationAttributes}, or  {@code null} ifnot found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @deprecated as of 4.2.3; use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead
 */
@Deprecated public static AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,Class<? extends Annotation> annotationType,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  AnnotationAttributes attributes=searchWithFindSemantics(element,annotationType,null,new MergedAnnotationAttributesProcessor(annotationType,null,classValuesAsString,nestedAnnotationsAsMap));
  AnnotationUtils.postProcessAnnotationAttributes(element,attributes,classValuesAsString,nestedAnnotationsAsMap);
  return attributes;
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element} andmerge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy. <p>Attributes from lower levels in the annotation hierarchy override attributes of the same name from higher levels, and {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>In contrast to  {@link #getAllAnnotationAttributes}, the search algorithm used by this method will stop searching the annotation hierarchy once the first annotation of the specified {@code annotationName} has been found. As a consequence, additionalannotations of the specified  {@code annotationName} will be ignored.<p>This method follows <em>find semantics</em> as described in the {@linkplain AnnotatedElementUtils class-level javadoc}.
 * @param element the annotated element
 * @param annotationType the annotation type to find
 * @param classValuesAsString whether to convert Class references intoStrings or to preserve them as Class references
 * @param nestedAnnotationsAsMap whether to convert nested Annotationinstances into  {@code AnnotationAttributes} maps or to preserve themas Annotation instances
 * @return the merged {@code AnnotationAttributes}, or  {@code null} ifnot found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @deprecated as of 4.2.3; use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead
 */
@Deprecated public static AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,Class<? extends Annotation> annotationType,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  AnnotationAttributes attributes=searchWithFindSemantics(element,annotationType,null,new MergedAnnotationAttributesProcessor(annotationType,null,classValuesAsString,nestedAnnotationsAsMap));
  AnnotationUtils.postProcessAnnotationAttributes(element,attributes,classValuesAsString,nestedAnnotationsAsMap);
  return attributes;
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return (attributes != null ? AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element) : null);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return (attributes != null ? AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element) : null);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * @see #fromMethod(Class,Method,Object)
 * @see #fromMethod(UriComponentsBuilder,Class,Method,Object)
 * @deprecated as of 4.2, this is deprecated in favor of the overloadedmethod that also accepts a controllerType argument
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @see #MethodArgumentBuilder(Class,Method)
 * @deprecated as of 4.2, this is deprecated in favor of alternative constructorsthat accept a controllerType argument
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * Get the  {@link Environment} associated with this helper instance.
 * @deprecated in favor of {@link XmlReaderContext#getEnvironment()}
 */
@Deprecated public final Environment getEnvironment(){
  return this.readerContext.getEnvironment();
}
"
"/** 
 * Indicate whether the extension of the request path should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code true}. <p>For instance, when this flag is  {@code true} (the default), a request for {@code /hotels.pdf}will result in an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be thebrowser-defined  {@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorPathExtension(boolean favorPathExtension){
  this.cnManagerFactoryBean.setFavorPathExtension(favorPathExtension);
}
"
"/** 
 * Indicate whether to use the Java Activation Framework to map from file extensions to media types. <p>Default is  {@code true}, i.e. the Java Activation Framework is used (if available).
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setUseJaf(boolean useJaf){
  this.cnManagerFactoryBean.setUseJaf(useJaf);
}
"
"/** 
 * Indicate whether a request parameter should be used to determine the requested media type, in favor of looking at the  {@code Accept} header. The default value is {@code false}. <p>For instance, when this flag is  {@code true}, a request for  {@code /hotels?format=pdf} will resultin an  {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined{@code text/html,application/xhtml+xml}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setFavorParameter(boolean favorParameter){
  this.cnManagerFactoryBean.setFavorParameter(favorParameter);
}
"
"/** 
 * Set the parameter name that can be used to determine the requested media type if the  {@link #setFavorParameter} property is {@code true}. The default parameter name is  {@code format}.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setParameterName(String parameterName){
  this.cnManagerFactoryBean.setParameterName(parameterName);
}
"
"/** 
 * Indicate whether the HTTP  {@code Accept} header should be ignored. Default is {@code false}. <p>If set to  {@code true}, this view resolver will only refer to the file extension and/or parameter, as indicated by the  {@link #setFavorPathExtension favorPathExtension} and{@link #setFavorParameter favorParameter} properties.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader){
  this.cnManagerFactoryBean.setIgnoreAcceptHeader(ignoreAcceptHeader);
}
"
"/** 
 * Set the mapping from file extensions to media types. <p>When this mapping is not set or when an extension is not present, this view resolver will fall back to using a  {@link FileTypeMap} when the Java Action Framework is available.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setMediaTypes(Map<String,String> mediaTypes){
  if (mediaTypes != null) {
    Properties props=new Properties();
    props.putAll(mediaTypes);
    this.cnManagerFactoryBean.setMediaTypes(props);
  }
}
"
"/** 
 * Set the default content type. <p>This content type will be used when file extension, parameter, nor  {@code Accept}header define a content-type, either through being disabled or empty.
 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 */
@Deprecated public void setDefaultContentType(MediaType defaultContentType){
  this.cnManagerFactoryBean.setDefaultContentType(defaultContentType);
}
"
"/** 
 * Add a  {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.
 * @deprecated in favor of {@link #addDeclaredRowMapper(String,org.springframework.jdbc.core.RowMapper)}
 */
@Deprecated public void addDeclaredRowMapper(String parameterName,ParameterizedRowMapper rowMapper){
  addDeclaredRowMapper(parameterName,(RowMapper)rowMapper);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Determine the target type for the given parameter specification.
 * @param methodParameter the method parameter specification
 * @return the corresponding generic parameter type
 * @deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()}
 */
@Deprecated public static Type getTargetType(MethodParameter methodParameter){
  Assert.notNull(methodParameter,""MethodParameter must not be null"");
  return methodParameter.getGenericParameterType();
}
"
"/** 
 * Resolve the specified generic type against the given TypeVariable map.
 * @param genericType the generic type to resolve
 * @param map the TypeVariable Map to resolved against
 * @return the type if it resolves to a Class, or {@code Object.class} otherwise
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated @SuppressWarnings(""rawtypes"") public static Class<?> resolveType(Type genericType,Map<TypeVariable,Type> map){
  return ResolvableType.forType(genericType,new TypeVariableMapVariableResolver(map)).resolve(Object.class);
}
"
"/** 
 * Build a mapping of  {@link TypeVariable#getName TypeVariable names} to{@link Class concrete classes} for the specified {@link Class}. Searches all super types, enclosing types and interfaces.
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated @SuppressWarnings(""rawtypes"") public static Map<TypeVariable,Type> getTypeVariableMap(Class<?> clazz){
  Map<TypeVariable,Type> typeVariableMap=typeVariableCache.get(clazz);
  if (typeVariableMap == null) {
    typeVariableMap=new HashMap<TypeVariable,Type>();
    buildTypeVariableMap(ResolvableType.forClass(clazz),typeVariableMap);
    typeVariableCache.put(clazz,Collections.unmodifiableMap(typeVariableMap));
  }
  return typeVariableMap;
}
"
"/** 
 * Determine the target type for the given parameter specification.
 * @param methodParameter the method parameter specification
 * @return the corresponding generic parameter type
 * @deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()}
 */
@Deprecated public static Type getTargetType(MethodParameter methodParameter){
  Assert.notNull(methodParameter,""MethodParameter must not be null"");
  return methodParameter.getGenericParameterType();
}
"
"/** 
 * Resolve the specified generic type against the given TypeVariable map.
 * @param genericType the generic type to resolve
 * @param map the TypeVariable Map to resolved against
 * @return the type if it resolves to a Class, or {@code Object.class} otherwise
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated @SuppressWarnings(""rawtypes"") public static Class<?> resolveType(Type genericType,Map<TypeVariable,Type> map){
  return ResolvableType.forType(genericType,new TypeVariableMapVariableResolver(map)).resolve(Object.class);
}
"
"/** 
 * Build a mapping of  {@link TypeVariable#getName TypeVariable names} to{@link Class concrete classes} for the specified {@link Class}. Searches all super types, enclosing types and interfaces.
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated @SuppressWarnings(""rawtypes"") public static Map<TypeVariable,Type> getTypeVariableMap(Class<?> clazz){
  Map<TypeVariable,Type> typeVariableMap=typeVariableCache.get(clazz);
  if (typeVariableMap == null) {
    typeVariableMap=new HashMap<TypeVariable,Type>();
    buildTypeVariableMap(ResolvableType.forClass(clazz),typeVariableMap);
    typeVariableCache.put(clazz,Collections.unmodifiableMap(typeVariableMap));
  }
  return typeVariableMap;
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Return the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Return the value of the  {@code IfModifiedSince} header.<p>The date is returned as the number of milliseconds since January 1, 1970 GMT. Returns -1 when the date is unknown.
 * @deprecated use {@link #getIfModifiedSince()}
 */
@Deprecated public long getIfNotModifiedSince(){
  return getIfModifiedSince();
}
"
"/** 
 * Merge the specified Velocity template with the given model and write the result to the given Writer.
 * @param velocityEngine VelocityEngine to work with
 * @param templateLocation the location of template, relative to Velocity's resource loader path
 * @param model the Map that contains model names as keys and model objects as values
 * @param writer the Writer to write the result to
 * @throws VelocityException if the template wasn't found or rendering failed
 * @deprecated Use {@link #mergeTemplate(VelocityEngine,String,String,Map,Writer)}instead, following Velocity 1.6's corresponding deprecation in its own API.
 */
@Deprecated public static void mergeTemplate(VelocityEngine velocityEngine,String templateLocation,Map<String,Object> model,Writer writer) throws VelocityException {
  VelocityContext velocityContext=new VelocityContext(model);
  velocityEngine.mergeTemplate(templateLocation,velocityContext,writer);
}
"
"/** 
 * Merge the specified Velocity template with the given model into a String. <p>When using this method to prepare a text for a mail to be sent with Spring's mail support, consider wrapping VelocityException in MailPreparationException.
 * @param velocityEngine VelocityEngine to work with
 * @param templateLocation the location of template, relative to Velocity's resource loader path
 * @param model the Map that contains model names as keys and model objects as values
 * @return the result as String
 * @throws VelocityException if the template wasn't found or rendering failed
 * @see org.springframework.mail.MailPreparationException
 * @deprecated Use {@link #mergeTemplateIntoString(VelocityEngine,String,String,Map)}instead, following Velocity 1.6's corresponding deprecation in its own API.
 */
@Deprecated public static String mergeTemplateIntoString(VelocityEngine velocityEngine,String templateLocation,Map<String,Object> model) throws VelocityException {
  StringWriter result=new StringWriter();
  mergeTemplate(velocityEngine,templateLocation,model,result);
  return result.toString();
}
"
"/** 
 * Register Velocity view resolver with an empty default view name prefix and a default suffix of "".vm"". <p><strong>Note</strong> that you must also configure Velocity by adding a {@link org.springframework.web.servlet.view.velocity.VelocityConfigurer} bean.
 * @deprecated as of Spring 4.3, in favor of FreeMarker
 */
@Deprecated public UrlBasedViewResolverRegistration velocity(){
  if (this.applicationContext != null && !hasBeanOfType(org.springframework.web.servlet.view.velocity.VelocityConfigurer.class)) {
    throw new BeanInitializationException(""In addition to a Velocity view resolver "" + ""there must also be a single VelocityConfig bean in this web application context "" + ""(or its parent): VelocityConfigurer is the usual implementation. ""+ ""This bean may be given any name."");
  }
  VelocityRegistration registration=new VelocityRegistration();
  this.viewResolvers.add(registration.getViewResolver());
  return registration;
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.MOVED_TEMPORARILY} (302).
 * @see #isFound()
 * @deprecated in favor of {@link #isFound()}
 */
@Deprecated public ResultMatcher isMovedTemporarily(){
  return matcher(HttpStatus.MOVED_TEMPORARILY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.USE_PROXY} (305).
 * @deprecated matching the deprecation of {@code HttpStatus.USE_PROXY}
 */
@Deprecated public ResultMatcher isUseProxy(){
  return matcher(HttpStatus.USE_PROXY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE} (413).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE}
 * @see #isPayloadTooLarge()
 */
@Deprecated public ResultMatcher isRequestEntityTooLarge(){
  return matcher(HttpStatus.REQUEST_ENTITY_TOO_LARGE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_URI_TOO_LONG} (414).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_URI_TOO_LONG}
 * @see #isUriTooLong()
 */
@Deprecated public ResultMatcher isRequestUriTooLong(){
  return matcher(HttpStatus.REQUEST_URI_TOO_LONG);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE}
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of {@code HttpStatus.METHOD_FAILURE}
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of {@code HttpStatus.DESTINATION_LOCKED}
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied parameters. <p>Delegates to {@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @param cacheAwareContextLoaderDelegate a cache-aware context loaderdelegate with which to retrieve the parent context
 * @param parent the parent configuration or {@code null} if there is no parent
 * @since 3.2.2
 * @deprecated as of Spring 4.1, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}instead.
 */
@Deprecated public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader,CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,MergedContextConfiguration parent){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,null,null,resourceBasePath,contextLoader,cacheAwareContextLoaderDelegate,parent);
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied parameters. <p>Delegates to {@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @param cacheAwareContextLoaderDelegate a cache-aware context loaderdelegate with which to retrieve the parent context
 * @param parent the parent configuration or {@code null} if there is no parent
 * @since 3.2.2
 * @deprecated as of Spring 4.1, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}instead.
 */
@Deprecated public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader,CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,MergedContextConfiguration parent){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,null,null,resourceBasePath,contextLoader,cacheAwareContextLoaderDelegate,parent);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Create a new UnsatisfiedDependencyException.
 * @param resourceDescription description of the resource that the bean definition came from
 * @param beanName the name of the bean requested
 * @param ctorArgIndex the index of the constructor argument that couldn't be satisfied
 * @param ctorArgType the type of the constructor argument that couldn't be satisfied
 * @param msg the detail message
 * @deprecated in favor of {@link #UnsatisfiedDependencyException(String,String,InjectionPoint,String)}
 */
@Deprecated public UnsatisfiedDependencyException(String resourceDescription,String beanName,int ctorArgIndex,Class<?> ctorArgType,String msg){
  super(resourceDescription,beanName,""Unsatisfied dependency expressed through constructor argument with index "" + ctorArgIndex + "" of type [""+ ClassUtils.getQualifiedName(ctorArgType)+ ""]""+ (msg != null ? "": "" + msg : """"));
}
"
"/** 
 * Create a new UnsatisfiedDependencyException.
 * @param resourceDescription description of the resource that the bean definition came from
 * @param beanName the name of the bean requested
 * @param ctorArgIndex the index of the constructor argument that couldn't be satisfied
 * @param ctorArgType the type of the constructor argument that couldn't be satisfied
 * @param ex the bean creation exception that indicated the unsatisfied dependency
 * @deprecated in favor of {@link #UnsatisfiedDependencyException(String,String,InjectionPoint,BeansException)}
 */
@Deprecated public UnsatisfiedDependencyException(String resourceDescription,String beanName,int ctorArgIndex,Class<?> ctorArgType,BeansException ex){
  this(resourceDescription,beanName,ctorArgIndex,ctorArgType,(ex != null ? ex.getMessage() : """"));
  initCause(ex);
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied parameters. <p>Delegates to {@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @param cacheAwareContextLoaderDelegate a cache-aware context loaderdelegate with which to retrieve the parent context
 * @param parent the parent configuration or {@code null} if there is no parent
 * @since 3.2.2
 * @deprecated as of Spring 4.1, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}instead.
 */
@Deprecated public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader,CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,MergedContextConfiguration parent){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,null,null,resourceBasePath,contextLoader,cacheAwareContextLoaderDelegate,parent);
}
"
"/** 
 * Adds a handle to the constant pool of the class being build. Does nothing if the constant pool already contains a similar item. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed byclass generators or adapters.</i>
 * @param tag the kind of this handle. Must be  {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC},  {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC},  {@link Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link Opcodes#H_NEWINVOKESPECIAL} or{@link Opcodes#H_INVOKEINTERFACE}.
 * @param owner the internal name of the field or method owner class.
 * @param name the name of the field or method.
 * @param desc the descriptor of the field or method.
 * @return the index of a new or already existing method type referenceitem.
 * @deprecated this method is superseded by{@link #newHandle(int,String,String,String,boolean)}.
 */
@Deprecated public int newHandle(final int tag,final String owner,final String name,final String desc){
  return newHandle(tag,owner,name,desc,tag == Opcodes.H_INVOKEINTERFACE);
}
"
"/** 
 * Constructs a new field or method handle.
 * @param tag the kind of field or method designated by this Handle. Must be {@link Opcodes#H_GETFIELD},  {@link Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD},  {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link Opcodes#H_NEWINVOKESPECIAL} or{@link Opcodes#H_INVOKEINTERFACE}.
 * @param owner the internal name of the class that owns the field or method designated by this handle.
 * @param name the name of the field or method designated by this handle.
 * @param desc the descriptor of the field or method designated by this handle.
 * @deprecated this constructor has been supersededby  {@link #Handle(int,String,String,String,boolean)}.
 */
@Deprecated public Handle(int tag,String owner,String name,String desc){
  this(tag,owner,name,desc,tag == Opcodes.H_INVOKEINTERFACE);
}
"
"/** 
 * Create a new  {@code WebMergedContextConfiguration} instance for thesupplied parameters. <p>Delegates to {@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}.
 * @param testClass the test class for which the configuration was merged
 * @param locations the merged resource locations
 * @param classes the merged annotated classes
 * @param contextInitializerClasses the merged context initializer classes
 * @param activeProfiles the merged active bean definition profiles
 * @param resourceBasePath the resource path to the root directory of the web application
 * @param contextLoader the resolved {@code ContextLoader}
 * @param cacheAwareContextLoaderDelegate a cache-aware context loaderdelegate with which to retrieve the parent context
 * @param parent the parent configuration or {@code null} if there is no parent
 * @since 3.2.2
 * @deprecated as of Spring 4.1, use{@link #WebMergedContextConfiguration(Class,String[],Class[],Set,String[],String[],String[],String,ContextLoader,CacheAwareContextLoaderDelegate,MergedContextConfiguration)}instead.
 */
@Deprecated public WebMergedContextConfiguration(Class<?> testClass,String[] locations,Class<?>[] classes,Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,String[] activeProfiles,String resourceBasePath,ContextLoader contextLoader,CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate,MergedContextConfiguration parent){
  this(testClass,locations,classes,contextInitializerClasses,activeProfiles,null,null,resourceBasePath,contextLoader,cacheAwareContextLoaderDelegate,parent);
}
"
"/** 
 * Create a new instance that assumes the context path of the application is  {@code """"} (i.e., the root context).<p>For example, the URL  {@code http://localhost/test/this} would use{@code """"} as the context path.
 * @param mockMvc the {@code MockMvc} instance to use; never {@code null}
 * @deprecated Use {@link #MockMvcWebConnection(MockMvc,WebClient)}
 */
@Deprecated public MockMvcWebConnection(MockMvc mockMvc){
  this(mockMvc,"""");
}
"
"/** 
 * Create a new instance with the specified context path. <p>The path may be  {@code null} in which case the first path segmentof the URL is turned into the contextPath. Otherwise it must conform to  {@link javax.servlet.http.HttpServletRequest#getContextPath()}which states that it can be an empty string and otherwise must start with a ""/"" character and not end with a ""/"" character.
 * @param mockMvc the {@code MockMvc} instance to use; never {@code null}
 * @param contextPath the contextPath to use
 * @deprecated use {@link #MockMvcWebConnection(MockMvc,WebClient,String)}
 */
@Deprecated public MockMvcWebConnection(MockMvc mockMvc,String contextPath){
  this(mockMvc,new WebClient(),contextPath);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Create a new instance that assumes the context path of the application is  {@code """"} (i.e., the root context).<p>For example, the URL  {@code http://localhost/test/this} would use{@code """"} as the context path.
 * @param mockMvc the {@code MockMvc} instance to use; never {@code null}
 * @deprecated Use {@link #MockMvcWebConnection(MockMvc,WebClient)}
 */
@Deprecated public MockMvcWebConnection(MockMvc mockMvc){
  this(mockMvc,"""");
}
"
"/** 
 * Create a new instance with the specified context path. <p>The path may be  {@code null} in which case the first path segmentof the URL is turned into the contextPath. Otherwise it must conform to  {@link javax.servlet.http.HttpServletRequest#getContextPath()}which states that it can be an empty string and otherwise must start with a ""/"" character and not end with a ""/"" character.
 * @param mockMvc the {@code MockMvc} instance to use; never {@code null}
 * @param contextPath the contextPath to use
 * @deprecated use {@link #MockMvcWebConnection(MockMvc,WebClient,String)}
 */
@Deprecated public MockMvcWebConnection(MockMvc mockMvc,String contextPath){
  this(mockMvc,new WebClient(),contextPath);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * Create a new instance that assumes the context path of the application is  {@code """"} (i.e., the root context).<p>For example, the URL  {@code http://localhost/test/this} would use{@code """"} as the context path.
 * @param mockMvc the {@code MockMvc} instance to use; never {@code null}
 * @deprecated Use {@link #MockMvcWebConnection(MockMvc,WebClient)}
 */
@Deprecated public MockMvcWebConnection(MockMvc mockMvc){
  this(mockMvc,"""");
}
"
"/** 
 * Create a new instance with the specified context path. <p>The path may be  {@code null} in which case the first path segmentof the URL is turned into the contextPath. Otherwise it must conform to  {@link javax.servlet.http.HttpServletRequest#getContextPath()}which states that it can be an empty string and otherwise must start with a ""/"" character and not end with a ""/"" character.
 * @param mockMvc the {@code MockMvc} instance to use; never {@code null}
 * @param contextPath the contextPath to use
 * @deprecated use {@link #MockMvcWebConnection(MockMvc,WebClient,String)}
 */
@Deprecated public MockMvcWebConnection(MockMvc mockMvc,String contextPath){
  this(mockMvc,new WebClient(),contextPath);
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}. <p>This method follows <em>find semantics</em> as described in the {@linkplain AnnotatedElementUtils class-level javadoc}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}. <p>This method follows <em>find semantics</em> as described in the {@linkplain AnnotatedElementUtils class-level javadoc}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}. <p>This method follows <em>find semantics</em> as described in the {@linkplain AnnotatedElementUtils class-level javadoc}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element);
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is {@code false})
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * @see #fromMethod(Class,Method,Object)
 * @see #fromMethod(UriComponentsBuilder,Class,Method,Object)
 * @deprecated as of 4.2, this is deprecated in favor of the overloadedmethod that also accepts a controllerType argument
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @see #MethodArgumentBuilder(Class,Method)
 * @deprecated as of 4.2, this is deprecated in favor of alternative constructorsthat accept a controllerType argument
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}. <p>This method follows <em>find semantics</em> as described in the {@linkplain AnnotatedElementUtils class-level javadoc}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}. <p>This method follows <em>find semantics</em> as described in the {@linkplain AnnotatedElementUtils class-level javadoc}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Set the name of the form attribute in the model. <p>May be a runtime expression.
 * @see #setModelAttribute
 * @deprecated as of Spring 4.3, in favor of {@link #setModelAttribute}
 */
@Deprecated public void setCommandName(String commandName){
  this.modelAttribute=commandName;
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}. <p>This method follows <em>find semantics</em> as described in the {@linkplain AnnotatedElementUtils class-level javadoc}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element);
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}. This variant just remains around for Spring Security 2.x compatibility.
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}. This variant just remains around for Spring Security 2.x compatibility.
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Create a new instance that assumes the context path of the application is  {@code """"} (i.e., the root context).<p>For example, the URL  {@code http://localhost/test/this} would use{@code """"} as the context path.
 * @param mockMvc the {@code MockMvc} instance to use; never {@code null}
 * @deprecated Use {@link #MockMvcWebConnection(MockMvc,WebClient)}
 */
@Deprecated public MockMvcWebConnection(MockMvc mockMvc){
  this(mockMvc,"""");
}
"
"/** 
 * Create a new instance with the specified context path. <p>The path may be  {@code null} in which case the first path segmentof the URL is turned into the contextPath. Otherwise it must conform to  {@link javax.servlet.http.HttpServletRequest#getContextPath()}which states that it can be an empty string and otherwise must start with a ""/"" character and not end with a ""/"" character.
 * @param mockMvc the {@code MockMvc} instance to use; never {@code null}
 * @param contextPath the contextPath to use
 * @deprecated use {@link #MockMvcWebConnection(MockMvc,WebClient,String)}
 */
@Deprecated public MockMvcWebConnection(MockMvc mockMvc,String contextPath){
  this(mockMvc,new WebClient(),contextPath);
}
"
"/** 
 * Return the character set, as indicated by a  {@code charset} parameter, if any.
 * @return the character set, or {@code null} if not available
 * @deprecated as of Spring 4.3, in favor of {@link #getCharset()} with its namealigned with the Java return type name
 */
@Deprecated public Charset getCharSet(){
  return getCharset();
}
"
"/** 
 * @see #fromMethod(Class,Method,Object)
 * @see #fromMethod(UriComponentsBuilder,Class,Method,Object)
 * @deprecated as of 4.2, this is deprecated in favor of the overloadedmethod that also accepts a controllerType argument
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @see #MethodArgumentBuilder(Class,Method)
 * @deprecated as of 4.2, this is deprecated in favor of alternative constructorsthat accept a controllerType argument
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * Look for the WebApplicationContext associated with the DispatcherServlet that has initiated request processing.
 * @param request current HTTP request
 * @return the request-specific web application context
 * @throws IllegalStateException if no servlet-specific context has been found
 * @see #getWebApplicationContext(ServletRequest,ServletContext)
 * @deprecated as of Spring 4.2.1, in favor of{@link #findWebApplicationContext(HttpServletRequest)}
 */
@Deprecated public static WebApplicationContext getWebApplicationContext(ServletRequest request) throws IllegalStateException {
  return getWebApplicationContext(request,null);
}
"
"/** 
 * Look for the WebApplicationContext associated with the DispatcherServlet that has initiated request processing, and for the global context if none was found associated with the current request. This method is useful to allow components outside the framework, such as JSP tag handlers, to access the most specific application context available.
 * @param request current HTTP request
 * @param servletContext current servlet context
 * @return the request-specific WebApplicationContext, or the global oneif no request-specific context has been found
 * @throws IllegalStateException if neither a servlet-specific nor aglobal context has been found
 * @see DispatcherServlet#WEB_APPLICATION_CONTEXT_ATTRIBUTE
 * @see WebApplicationContextUtils#getRequiredWebApplicationContext(ServletContext)
 * @deprecated as of Spring 4.2.1, in favor of{@link #findWebApplicationContext(HttpServletRequest,ServletContext)}
 */
@Deprecated public static WebApplicationContext getWebApplicationContext(ServletRequest request,ServletContext servletContext) throws IllegalStateException {
  WebApplicationContext webApplicationContext=(WebApplicationContext)request.getAttribute(DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE);
  if (webApplicationContext == null) {
    if (servletContext == null) {
      throw new IllegalStateException(""No WebApplicationContext found: not in a DispatcherServlet request?"");
    }
    webApplicationContext=WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);
  }
  return webApplicationContext;
}
"
"/** 
 * @see #fromMethod(Class,Method,Object)
 * @see #fromMethod(UriComponentsBuilder,Class,Method,Object)
 * @deprecated as of 4.2, this is deprecated in favor of the overloadedmethod that also accepts a controllerType argument
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @see #MethodArgumentBuilder(Class,Method)
 * @deprecated as of 4.2, this is deprecated in favor of alternative constructorsthat accept a controllerType argument
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * Look for the WebApplicationContext associated with the DispatcherServlet that has initiated request processing.
 * @param request current HTTP request
 * @return the request-specific web application context
 * @throws IllegalStateException if no servlet-specific context has been found
 * @see #getWebApplicationContext(ServletRequest,ServletContext)
 * @deprecated as of Spring 4.2.1, in favor of{@link #findWebApplicationContext(HttpServletRequest)}
 */
@Deprecated public static WebApplicationContext getWebApplicationContext(ServletRequest request) throws IllegalStateException {
  return getWebApplicationContext(request,null);
}
"
"/** 
 * Look for the WebApplicationContext associated with the DispatcherServlet that has initiated request processing, and for the global context if none was found associated with the current request. This method is useful to allow components outside the framework, such as JSP tag handlers, to access the most specific application context available.
 * @param request current HTTP request
 * @param servletContext current servlet context
 * @return the request-specific WebApplicationContext, or the global oneif no request-specific context has been found
 * @throws IllegalStateException if neither a servlet-specific nor aglobal context has been found
 * @see DispatcherServlet#WEB_APPLICATION_CONTEXT_ATTRIBUTE
 * @see WebApplicationContextUtils#getRequiredWebApplicationContext(ServletContext)
 * @deprecated as of Spring 4.2.1, in favor of{@link #findWebApplicationContext(HttpServletRequest,ServletContext)}
 */
@Deprecated public static WebApplicationContext getWebApplicationContext(ServletRequest request,ServletContext servletContext) throws IllegalStateException {
  WebApplicationContext webApplicationContext=(WebApplicationContext)request.getAttribute(DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE);
  if (webApplicationContext == null) {
    if (servletContext == null) {
      throw new IllegalStateException(""No WebApplicationContext found: not in a DispatcherServlet request?"");
    }
    webApplicationContext=WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);
  }
  return webApplicationContext;
}
"
"/** 
 * @deprecated as of 4.3, in favor of {@link #setBeanFactory}
 */
@Deprecated public void setApplicationContext(ApplicationContext applicationContext){
  this.beanFactory=applicationContext;
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}. <p>This method follows <em>find semantics</em> as described in the {@linkplain AnnotatedElementUtils class-level javadoc}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Create a new instance that assumes the context path of the application is  {@code """"} (i.e., the root context).<p>For example, the URL  {@code http://localhost/test/this} would use{@code """"} as the context path.
 * @param mockMvc the {@code MockMvc} instance to use; never {@code null}
 * @deprecated Use {@link #MockMvcWebConnection(MockMvc,WebClient)}
 */
@Deprecated public MockMvcWebConnection(MockMvc mockMvc){
  this(mockMvc,"""");
}
"
"/** 
 * Create a new instance with the specified context path. <p>The path may be  {@code null} in which case the first path segmentof the URL is turned into the contextPath. Otherwise it must conform to  {@link javax.servlet.http.HttpServletRequest#getContextPath()}which states that it can be an empty string and otherwise must start with a ""/"" character and not end with a ""/"" character.
 * @param mockMvc the {@code MockMvc} instance to use; never {@code null}
 * @param contextPath the contextPath to use
 * @deprecated use {@link #MockMvcWebConnection(MockMvc,WebClient,String)}
 */
@Deprecated public MockMvcWebConnection(MockMvc mockMvc,String contextPath){
  this(mockMvc,new WebClient(),contextPath);
}
"
"/** 
 * Create a new instance that assumes the context path of the application is  {@code """"} (i.e., the root context).<p>For example, the URL  {@code http://localhost/test/this} would use{@code """"} as the context path.
 * @param mockMvc the {@code MockMvc} instance to use; never {@code null}
 * @deprecated Use {@link #MockMvcWebConnection(MockMvc,WebClient)}
 */
@Deprecated public MockMvcWebConnection(MockMvc mockMvc){
  this(mockMvc,"""");
}
"
"/** 
 * Create a new instance with the specified context path. <p>The path may be  {@code null} in which case the first path segmentof the URL is turned into the contextPath. Otherwise it must conform to  {@link javax.servlet.http.HttpServletRequest#getContextPath()}which states that it can be an empty string and otherwise must start with a ""/"" character and not end with a ""/"" character.
 * @param mockMvc the {@code MockMvc} instance to use; never {@code null}
 * @param contextPath the contextPath to use
 * @deprecated use {@link #MockMvcWebConnection(MockMvc,WebClient,String)}
 */
@Deprecated public MockMvcWebConnection(MockMvc mockMvc,String contextPath){
  this(mockMvc,new WebClient(),contextPath);
}
"
"/** 
 * Create a new instance that assumes the context path of the application is  {@code """"} (i.e., the root context).<p>For example, the URL  {@code http://localhost/test/this} would use{@code """"} as the context path.
 * @param mockMvc the {@code MockMvc} instance to use; never {@code null}
 * @deprecated Use {@link #MockMvcWebConnection(MockMvc,WebClient)}
 */
@Deprecated public MockMvcWebConnection(MockMvc mockMvc){
  this(mockMvc,"""");
}
"
"/** 
 * Create a new instance with the specified context path. <p>The path may be  {@code null} in which case the first path segmentof the URL is turned into the contextPath. Otherwise it must conform to  {@link javax.servlet.http.HttpServletRequest#getContextPath()}which states that it can be an empty string and otherwise must start with a ""/"" character and not end with a ""/"" character.
 * @param mockMvc the {@code MockMvc} instance to use; never {@code null}
 * @param contextPath the contextPath to use
 * @deprecated use {@link #MockMvcWebConnection(MockMvc,WebClient,String)}
 */
@Deprecated public MockMvcWebConnection(MockMvc mockMvc,String contextPath){
  this(mockMvc,new WebClient(),contextPath);
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is {@code false})
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * @see #fromMethod(Class,Method,Object)
 * @see #fromMethod(UriComponentsBuilder,Class,Method,Object)
 * @deprecated as of 4.2, this is deprecated in favor of the overloadedmethod that also accepts a controllerType argument
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @see #MethodArgumentBuilder(Class,Method)
 * @deprecated as of 4.2, this is deprecated in favor of alternative constructorsthat accept a controllerType argument
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}. <p>This method follows <em>find semantics</em> as described in the {@linkplain AnnotatedElementUtils class-level javadoc}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element);
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * @deprecated as of 4.3, in favor of {@link #setBeanFactory}
 */
@Deprecated public void setApplicationContext(ApplicationContext applicationContext){
  this.beanFactory=applicationContext;
}
"
"/** 
 * Allows for providing JAX-WS 2.2 WebServiceFeature specifications: in the form of actual  {@link javax.xml.ws.WebServiceFeature} objects,WebServiceFeature Class references, or WebServiceFeature class names. <p>As of Spring 4.0, this is effectively just an alternative way of specifying  {@link #setEndpointFeatures ""endpointFeatures""}. Do not specify both properties at the same time; prefer ""endpointFeatures"" moving forward.
 * @deprecated as of Spring 4.0, in favor of {@link #setEndpointFeatures}
 */
@Deprecated public void setWebServiceFeatures(Object[] webServiceFeatures){
  this.webServiceFeatures=webServiceFeatures;
}
"
"/** 
 * @see #fromMethod(Class,Method,Object)
 * @see #fromMethod(UriComponentsBuilder,Class,Method,Object)
 * @deprecated as of 4.2, this is deprecated in favor of the overloadedmethod that also accepts a controllerType argument
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @deprecated as of 4.2, this is deprecated in favor of alternative constructorsthat accept a controllerType argument
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * Determine the target type for the given parameter specification.
 * @param methodParameter the method parameter specification
 * @return the corresponding generic parameter type
 * @deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()}
 */
@Deprecated public static Type getTargetType(MethodParameter methodParameter){
  Assert.notNull(methodParameter,""MethodParameter must not be null"");
  return methodParameter.getGenericParameterType();
}
"
"/** 
 * Resolve the specified generic type against the given TypeVariable map.
 * @param genericType the generic type to resolve
 * @param map the TypeVariable Map to resolved against
 * @return the type if it resolves to a Class, or {@code Object.class} otherwise
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated @SuppressWarnings(""rawtypes"") public static Class<?> resolveType(Type genericType,Map<TypeVariable,Type> map){
  return ResolvableType.forType(genericType,new TypeVariableMapVariableResolver(map)).resolve(Object.class);
}
"
"/** 
 * Build a mapping of  {@link TypeVariable#getName TypeVariable names} to{@link Class concrete classes} for the specified {@link Class}. Searches all super types, enclosing types and interfaces.
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated @SuppressWarnings(""rawtypes"") public static Map<TypeVariable,Type> getTypeVariableMap(Class<?> clazz){
  Map<TypeVariable,Type> typeVariableMap=typeVariableCache.get(clazz);
  if (typeVariableMap == null) {
    typeVariableMap=new HashMap<>();
    buildTypeVariableMap(ResolvableType.forClass(clazz),typeVariableMap);
    typeVariableCache.put(clazz,Collections.unmodifiableMap(typeVariableMap));
  }
  return typeVariableMap;
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resourceLoader the resource loader with which to load the SQL script
 * @param sqlResourcePath the Spring resource path for the SQL script
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see #executeSqlScript(JdbcTemplate,Resource,boolean)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,ResourceLoader resourceLoader,String sqlResourcePath,boolean continueOnError) throws DataAccessException {
  Resource resource=resourceLoader.getResource(sqlResourcePath);
  executeSqlScript(jdbcTemplate,resource,continueOnError);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. Statements should be delimited with a semicolon. If statements are not delimited with a semicolon then there should be one statement per line. Statements are allowed to span lines only if they are delimited with a semicolon. Any line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource to load the SQL script from
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see #executeSqlScript(JdbcTemplate,EncodedResource,boolean)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,Resource resource,boolean continueOnError) throws DataAccessException {
  executeSqlScript(jdbcTemplate,new EncodedResource(resource),continueOnError);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource (potentially associated with a specific encoding)to load the SQL script from
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,EncodedResource resource,boolean continueOnError) throws DataAccessException {
  new ResourceDatabasePopulator(continueOnError,false,resource.getEncoding(),resource.getResource()).execute(jdbcTemplate.getDataSource());
}
"
"/** 
 * Read a script from the provided  {@code LineNumberReader}, using "" {@code --}"" as the comment prefix, and build a  {@code String} containingthe lines.
 * @param lineNumberReader the {@code LineNumberReader} containing the scriptto be processed
 * @return a {@code String} containing the script lines
 * @see #readScript(LineNumberReader,String)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader,String,String)}
 */
@Deprecated public static String readScript(LineNumberReader lineNumberReader) throws IOException {
  return readScript(lineNumberReader,ScriptUtils.DEFAULT_COMMENT_PREFIX);
}
"
"/** 
 * Read a script from the provided  {@code LineNumberReader}, using the supplied comment prefix, and build a  {@code String} containing the lines.<p>Lines <em>beginning</em> with the comment prefix are excluded from the results; however, line comments anywhere else &mdash; for example, within a statement &mdash; will be included in the results.
 * @param lineNumberReader the {@code LineNumberReader} containing the scriptto be processed
 * @param commentPrefix the prefix that identifies comments in the SQL script &mdash; typically ""--""
 * @return a {@code String} containing the script lines
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader,String,String)}
 */
@Deprecated public static String readScript(LineNumberReader lineNumberReader,String commentPrefix) throws IOException {
  return ScriptUtils.readScript(lineNumberReader,commentPrefix,ScriptUtils.DEFAULT_STATEMENT_SEPARATOR);
}
"
"/** 
 * Determine if the provided SQL script contains the specified delimiter.
 * @param script the SQL script
 * @param delim character delimiting each statement &mdash; typically a ';' character
 * @return {@code true} if the script contains the delimiter; {@code false} otherwise
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#containsSqlScriptDelimiters}
 */
@Deprecated public static boolean containsSqlScriptDelimiters(String script,char delim){
  return ScriptUtils.containsSqlScriptDelimiters(script,String.valueOf(delim));
}
"
"/** 
 * Split an SQL script into separate statements delimited by the provided delimiter character. Each individual statement will be added to the provided  {@code List}. <p>Within a statement, "" {@code --}"" will be used as the comment prefix; any text beginning with the comment prefix and extending to the end of the line will be omitted from the statement. In addition, multiple adjacent whitespace characters will be collapsed into a single space.
 * @param script the SQL script
 * @param delim character delimiting each statement &mdash; typically a ';' character
 * @param statements the list that will contain the individual statements
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(String,char,List)}
 */
@Deprecated public static void splitSqlScript(String script,char delim,List<String> statements){
  ScriptUtils.splitSqlScript(script,delim,statements);
}
"
"/** 
 * Configure headers to be added to every executed HTTP request.
 * @param requestHeaders the headers to add to requests
 * @deprecated as of 4.2 in favor of {@link SockJsClient#setHttpHeaderNames}.
 */
@Deprecated public void setRequestHeaders(HttpHeaders requestHeaders){
  this.requestHeaders.clear();
  if (requestHeaders != null) {
    this.requestHeaders.putAll(requestHeaders);
  }
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resourceLoader the resource loader with which to load the SQL script
 * @param sqlResourcePath the Spring resource path for the SQL script
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see #executeSqlScript(JdbcTemplate,Resource,boolean)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,ResourceLoader resourceLoader,String sqlResourcePath,boolean continueOnError) throws DataAccessException {
  Resource resource=resourceLoader.getResource(sqlResourcePath);
  executeSqlScript(jdbcTemplate,resource,continueOnError);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. Statements should be delimited with a semicolon. If statements are not delimited with a semicolon then there should be one statement per line. Statements are allowed to span lines only if they are delimited with a semicolon. Any line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource to load the SQL script from
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @see #executeSqlScript(JdbcTemplate,EncodedResource,boolean)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,Resource resource,boolean continueOnError) throws DataAccessException {
  executeSqlScript(jdbcTemplate,new EncodedResource(resource),continueOnError);
}
"
"/** 
 * Execute the given SQL script. <p>The script will typically be loaded from the classpath. There should be one statement per line. Any semicolons and line comments will be removed. <p><b>Do not use this method to execute DDL if you expect rollback.</b>
 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
 * @param resource the resource (potentially associated with a specific encoding)to load the SQL script from
 * @param continueOnError whether or not to continue without throwing anexception in the event of an error
 * @throws DataAccessException if there is an error executing a statementand  {@code continueOnError} is {@code false}
 * @see ResourceDatabasePopulator
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}or  {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.
 */
@Deprecated public static void executeSqlScript(JdbcTemplate jdbcTemplate,EncodedResource resource,boolean continueOnError) throws DataAccessException {
  new ResourceDatabasePopulator(continueOnError,false,resource.getEncoding(),resource.getResource()).execute(jdbcTemplate.getDataSource());
}
"
"/** 
 * Read a script from the provided  {@code LineNumberReader}, using "" {@code --}"" as the comment prefix, and build a  {@code String} containingthe lines.
 * @param lineNumberReader the {@code LineNumberReader} containing the scriptto be processed
 * @return a {@code String} containing the script lines
 * @see #readScript(LineNumberReader,String)
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader,String,String)}
 */
@Deprecated public static String readScript(LineNumberReader lineNumberReader) throws IOException {
  return readScript(lineNumberReader,ScriptUtils.DEFAULT_COMMENT_PREFIX);
}
"
"/** 
 * Read a script from the provided  {@code LineNumberReader}, using the supplied comment prefix, and build a  {@code String} containing the lines.<p>Lines <em>beginning</em> with the comment prefix are excluded from the results; however, line comments anywhere else &mdash; for example, within a statement &mdash; will be included in the results.
 * @param lineNumberReader the {@code LineNumberReader} containing the scriptto be processed
 * @param commentPrefix the prefix that identifies comments in the SQL script &mdash; typically ""--""
 * @return a {@code String} containing the script lines
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader,String,String)}
 */
@Deprecated public static String readScript(LineNumberReader lineNumberReader,String commentPrefix) throws IOException {
  return ScriptUtils.readScript(lineNumberReader,commentPrefix,ScriptUtils.DEFAULT_STATEMENT_SEPARATOR);
}
"
"/** 
 * Determine if the provided SQL script contains the specified delimiter.
 * @param script the SQL script
 * @param delim character delimiting each statement &mdash; typically a ';' character
 * @return {@code true} if the script contains the delimiter; {@code false} otherwise
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#containsSqlScriptDelimiters}
 */
@Deprecated public static boolean containsSqlScriptDelimiters(String script,char delim){
  return ScriptUtils.containsSqlScriptDelimiters(script,String.valueOf(delim));
}
"
"/** 
 * Split an SQL script into separate statements delimited by the provided delimiter character. Each individual statement will be added to the provided  {@code List}. <p>Within a statement, "" {@code --}"" will be used as the comment prefix; any text beginning with the comment prefix and extending to the end of the line will be omitted from the statement. In addition, multiple adjacent whitespace characters will be collapsed into a single space.
 * @param script the SQL script
 * @param delim character delimiting each statement &mdash; typically a ';' character
 * @param statements the list that will contain the individual statements
 * @deprecated as of Spring 4.0.3, in favor of using{@link org.springframework.jdbc.datasource.init.ScriptUtils#splitSqlScript(String,char,List)}
 */
@Deprecated public static void splitSqlScript(String script,char delim,List<String> statements){
  ScriptUtils.splitSqlScript(script,delim,statements);
}
"
"/** 
 * Configure headers to be added to every executed HTTP request.
 * @param requestHeaders the headers to add to requests
 * @deprecated as of 4.2 in favor of {@link SockJsClient#setHttpHeaderNames}.
 */
@Deprecated public void setRequestHeaders(HttpHeaders requestHeaders){
  this.requestHeaders.clear();
  if (requestHeaders != null) {
    this.requestHeaders.putAll(requestHeaders);
  }
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * Create a new MethodParameter for the given method or constructor. <p>This is a convenience factory method for scenarios where a Method or Constructor reference is treated in a generic fashion.
 * @param methodOrConstructor the Method or Constructor to specify a parameter for
 * @param parameterIndex the index of the parameter
 * @return the corresponding MethodParameter instance
 * @deprecated as of 5.0, in favor of {@link #forExecutable}
 */
@Deprecated public static MethodParameter forMethodOrConstructor(Object methodOrConstructor,int parameterIndex){
  if (!(methodOrConstructor instanceof Executable)) {
    throw new IllegalArgumentException(""Given object ["" + methodOrConstructor + ""] is neither a Method nor a Constructor"");
  }
  return forExecutable((Executable)methodOrConstructor,parameterIndex);
}
"
"/** 
 * Determine the target type for the given parameter specification.
 * @param methodParameter the method parameter specification
 * @return the corresponding generic parameter type
 * @deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()}
 */
@Deprecated public static Type getTargetType(MethodParameter methodParameter){
  Assert.notNull(methodParameter,""MethodParameter must not be null"");
  return methodParameter.getGenericParameterType();
}
"
"/** 
 * Resolve the specified generic type against the given TypeVariable map.
 * @param genericType the generic type to resolve
 * @param map the TypeVariable Map to resolved against
 * @return the type if it resolves to a Class, or {@code Object.class} otherwise
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated @SuppressWarnings(""rawtypes"") public static Class<?> resolveType(Type genericType,Map<TypeVariable,Type> map){
  return ResolvableType.forType(genericType,new TypeVariableMapVariableResolver(map)).resolve(Object.class);
}
"
"/** 
 * Build a mapping of  {@link TypeVariable#getName TypeVariable names} to{@link Class concrete classes} for the specified {@link Class}. Searches all super types, enclosing types and interfaces.
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated @SuppressWarnings(""rawtypes"") public static Map<TypeVariable,Type> getTypeVariableMap(Class<?> clazz){
  Map<TypeVariable,Type> typeVariableMap=typeVariableCache.get(clazz);
  if (typeVariableMap == null) {
    typeVariableMap=new HashMap<>();
    buildTypeVariableMap(ResolvableType.forClass(clazz),typeVariableMap);
    typeVariableCache.put(clazz,Collections.unmodifiableMap(typeVariableMap));
  }
  return typeVariableMap;
}
"
"/** 
 * Create a new MethodParameter for the given method or constructor. <p>This is a convenience factory method for scenarios where a Method or Constructor reference is treated in a generic fashion.
 * @param methodOrConstructor the Method or Constructor to specify a parameter for
 * @param parameterIndex the index of the parameter
 * @return the corresponding MethodParameter instance
 * @deprecated as of 5.0, in favor of {@link #forExecutable}
 */
@Deprecated public static MethodParameter forMethodOrConstructor(Object methodOrConstructor,int parameterIndex){
  if (!(methodOrConstructor instanceof Executable)) {
    throw new IllegalArgumentException(""Given object ["" + methodOrConstructor + ""] is neither a Method nor a Constructor"");
  }
  return forExecutable((Executable)methodOrConstructor,parameterIndex);
}
"
"/** 
 * Create a new MethodParameter for the given method or constructor. <p>This is a convenience factory method for scenarios where a Method or Constructor reference is treated in a generic fashion.
 * @param methodOrConstructor the Method or Constructor to specify a parameter for
 * @param parameterIndex the index of the parameter
 * @return the corresponding MethodParameter instance
 * @deprecated as of 5.0, in favor of {@link #forExecutable}
 */
@Deprecated public static MethodParameter forMethodOrConstructor(Object methodOrConstructor,int parameterIndex){
  if (!(methodOrConstructor instanceof Executable)) {
    throw new IllegalArgumentException(""Given object ["" + methodOrConstructor + ""] is neither a Method nor a Constructor"");
  }
  return forExecutable((Executable)methodOrConstructor,parameterIndex);
}
"
"/** 
 * Create a new MethodParameter for the given method or constructor. <p>This is a convenience factory method for scenarios where a Method or Constructor reference is treated in a generic fashion.
 * @param methodOrConstructor the Method or Constructor to specify a parameter for
 * @param parameterIndex the index of the parameter
 * @return the corresponding MethodParameter instance
 * @deprecated as of 5.0, in favor of {@link #forExecutable}
 */
@Deprecated public static MethodParameter forMethodOrConstructor(Object methodOrConstructor,int parameterIndex){
  if (!(methodOrConstructor instanceof Executable)) {
    throw new IllegalArgumentException(""Given object ["" + methodOrConstructor + ""] is neither a Method nor a Constructor"");
  }
  return forExecutable((Executable)methodOrConstructor,parameterIndex);
}
"
"/** 
 * @deprecated as of Spring 4.2.8, in favor of {@link #setUrlPathHelper}
 */
@Deprecated public void setPathHelper(UrlPathHelper pathHelper){
  this.urlPathHelper=pathHelper;
}
"
"/** 
 * @deprecated as of Spring 4.2.8, in favor of {@link #getUrlPathHelper}
 */
@Deprecated public UrlPathHelper getPathHelper(){
  return this.urlPathHelper;
}
"
"/** 
 * Get the value stored under the specified  {@code attributeName} as astring, taking into account alias semantics defined via {@link AliasFor @AliasFor}. <p>If there is no value stored under the specified  {@code attributeName}but the attribute has an alias declared via  {@code @AliasFor}, the value of the alias will be returned.
 * @param attributeName the name of the attribute to get; never{@code null} or empty
 * @param annotationType the type of annotation represented by this{@code AnnotationAttributes} instance; never {@code null}
 * @param annotationSource the source of the annotation represented bythis  {@code AnnotationAttributes} (e.g., the {@link AnnotatedElement}); or  {@code null} if unknown
 * @return the string value
 * @throws IllegalArgumentException if the attribute and its alias donot exist or are not of type  {@code String}
 * @throws AnnotationConfigurationException if the attribute and itsalias are both present with different non-empty values
 * @since 4.2
 * @deprecated as of Spring 4.3.2, in favor of built-in alias resolutionin  {@link #getString} itself
 */
@Deprecated public String getAliasedString(String attributeName,Class<? extends Annotation> annotationType,Object annotationSource){
  return getRequiredAttributeWithAlias(attributeName,annotationType,annotationSource,String.class);
}
"
"/** 
 * Get the value stored under the specified  {@code attributeName} as anarray of strings, taking into account alias semantics defined via {@link AliasFor @AliasFor}. <p>If there is no value stored under the specified  {@code attributeName}but the attribute has an alias declared via  {@code @AliasFor}, the value of the alias will be returned.
 * @param attributeName the name of the attribute to get; never{@code null} or empty
 * @param annotationType the type of annotation represented by this{@code AnnotationAttributes} instance; never {@code null}
 * @param annotationSource the source of the annotation represented bythis  {@code AnnotationAttributes} (e.g., the {@link AnnotatedElement}); or  {@code null} if unknown
 * @return the array of strings
 * @throws IllegalArgumentException if the attribute and its alias donot exist or are not of type  {@code String[]}
 * @throws AnnotationConfigurationException if the attribute and itsalias are both present with different non-empty values
 * @since 4.2
 * @deprecated as of Spring 4.3.2, in favor of built-in alias resolutionin  {@link #getStringArray} itself
 */
@Deprecated public String[] getAliasedStringArray(String attributeName,Class<? extends Annotation> annotationType,Object annotationSource){
  return getRequiredAttributeWithAlias(attributeName,annotationType,annotationSource,String[].class);
}
"
"/** 
 * Get the value stored under the specified  {@code attributeName} as anarray of classes, taking into account alias semantics defined via {@link AliasFor @AliasFor}. <p>If there is no value stored under the specified  {@code attributeName}but the attribute has an alias declared via  {@code @AliasFor}, the value of the alias will be returned.
 * @param attributeName the name of the attribute to get; never{@code null} or empty
 * @param annotationType the type of annotation represented by this{@code AnnotationAttributes} instance; never {@code null}
 * @param annotationSource the source of the annotation represented bythis  {@code AnnotationAttributes} (e.g., the {@link AnnotatedElement}); or  {@code null} if unknown
 * @return the array of classes
 * @throws IllegalArgumentException if the attribute and its alias donot exist or are not of type  {@code Class[]}
 * @throws AnnotationConfigurationException if the attribute and itsalias are both present with different non-empty values
 * @since 4.2
 * @deprecated as of Spring 4.3.2, in favor of built-in alias resolutionin  {@link #getClassArray} itself
 */
@Deprecated public Class<?>[] getAliasedClassArray(String attributeName,Class<? extends Annotation> annotationType,Object annotationSource){
  return getRequiredAttributeWithAlias(attributeName,annotationType,annotationSource,Class[].class);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * @deprecated as of Spring 4.2.8, in favor of {@link #setUrlPathHelper}
 */
@Deprecated public void setPathHelper(UrlPathHelper pathHelper){
  this.urlPathHelper=pathHelper;
}
"
"/** 
 * @deprecated as of Spring 4.2.8, in favor of {@link #getUrlPathHelper}
 */
@Deprecated public UrlPathHelper getPathHelper(){
  return this.urlPathHelper;
}
"
"/** 
 * @see #fromMethod(Class,Method,Object)
 * @see #fromMethod(UriComponentsBuilder,Class,Method,Object)
 * @deprecated as of 4.2, this is deprecated in favor of the overloadedmethod that also accepts a controllerType argument
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @deprecated as of 4.2, this is deprecated in favor of alternative constructorsthat accept a controllerType argument
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * Get the value stored under the specified  {@code attributeName} as astring, taking into account alias semantics defined via {@link AliasFor @AliasFor}. <p>If there is no value stored under the specified  {@code attributeName}but the attribute has an alias declared via  {@code @AliasFor}, the value of the alias will be returned.
 * @param attributeName the name of the attribute to get; never{@code null} or empty
 * @param annotationType the type of annotation represented by this{@code AnnotationAttributes} instance; never {@code null}
 * @param annotationSource the source of the annotation represented bythis  {@code AnnotationAttributes} (e.g., the {@link AnnotatedElement}); or  {@code null} if unknown
 * @return the string value
 * @throws IllegalArgumentException if the attribute and its alias donot exist or are not of type  {@code String}
 * @throws AnnotationConfigurationException if the attribute and itsalias are both present with different non-empty values
 * @since 4.2
 * @deprecated as of Spring 4.3.2, in favor of built-in alias resolutionin  {@link #getString} itself
 */
@Deprecated public String getAliasedString(String attributeName,Class<? extends Annotation> annotationType,Object annotationSource){
  return getRequiredAttributeWithAlias(attributeName,annotationType,annotationSource,String.class);
}
"
"/** 
 * Get the value stored under the specified  {@code attributeName} as anarray of strings, taking into account alias semantics defined via {@link AliasFor @AliasFor}. <p>If there is no value stored under the specified  {@code attributeName}but the attribute has an alias declared via  {@code @AliasFor}, the value of the alias will be returned.
 * @param attributeName the name of the attribute to get; never{@code null} or empty
 * @param annotationType the type of annotation represented by this{@code AnnotationAttributes} instance; never {@code null}
 * @param annotationSource the source of the annotation represented bythis  {@code AnnotationAttributes} (e.g., the {@link AnnotatedElement}); or  {@code null} if unknown
 * @return the array of strings
 * @throws IllegalArgumentException if the attribute and its alias donot exist or are not of type  {@code String[]}
 * @throws AnnotationConfigurationException if the attribute and itsalias are both present with different non-empty values
 * @since 4.2
 * @deprecated as of Spring 4.3.2, in favor of built-in alias resolutionin  {@link #getStringArray} itself
 */
@Deprecated public String[] getAliasedStringArray(String attributeName,Class<? extends Annotation> annotationType,Object annotationSource){
  return getRequiredAttributeWithAlias(attributeName,annotationType,annotationSource,String[].class);
}
"
"/** 
 * Get the value stored under the specified  {@code attributeName} as anarray of classes, taking into account alias semantics defined via {@link AliasFor @AliasFor}. <p>If there is no value stored under the specified  {@code attributeName}but the attribute has an alias declared via  {@code @AliasFor}, the value of the alias will be returned.
 * @param attributeName the name of the attribute to get; never{@code null} or empty
 * @param annotationType the type of annotation represented by this{@code AnnotationAttributes} instance; never {@code null}
 * @param annotationSource the source of the annotation represented bythis  {@code AnnotationAttributes} (e.g., the {@link AnnotatedElement}); or  {@code null} if unknown
 * @return the array of classes
 * @throws IllegalArgumentException if the attribute and its alias donot exist or are not of type  {@code Class[]}
 * @throws AnnotationConfigurationException if the attribute and itsalias are both present with different non-empty values
 * @since 4.2
 * @deprecated as of Spring 4.3.2, in favor of built-in alias resolutionin  {@link #getClassArray} itself
 */
@Deprecated public Class<?>[] getAliasedClassArray(String attributeName,Class<? extends Annotation> annotationType,Object annotationSource){
  return getRequiredAttributeWithAlias(attributeName,annotationType,annotationSource,Class[].class);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * @see #fromMethod(Class,Method,Object)
 * @see #fromMethod(UriComponentsBuilder,Class,Method,Object)
 * @deprecated as of 4.2, this is deprecated in favor of the overloadedmethod that also accepts a controllerType argument
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @deprecated as of 4.2, this is deprecated in favor of alternative constructorsthat accept a controllerType argument
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * Convenience method to instantiate a class using its no-arg constructor.
 * @param clazz class to instantiate
 * @return the new instance
 * @throws BeanInstantiationException if the bean cannot be instantiated
 * @deprecated as of Spring 5.0, following the deprecation of{@link Class#newInstance()} in JDK 9
 * @see Class#newInstance()
 */
@Deprecated public static <T>T instantiate(Class<T> clazz) throws BeanInstantiationException {
  Assert.notNull(clazz,""Class must not be null"");
  if (clazz.isInterface()) {
    throw new BeanInstantiationException(clazz,""Specified class is an interface"");
  }
  try {
    return clazz.newInstance();
  }
 catch (  InstantiationException ex) {
    throw new BeanInstantiationException(clazz,""Is it an abstract class?"",ex);
  }
catch (  IllegalAccessException ex) {
    throw new BeanInstantiationException(clazz,""Is the constructor accessible?"",ex);
  }
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is {@code false})
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Get the specified session attribute, creating and setting a new attribute if no existing found. The given class needs to have a public no-arg constructor. Useful for on-demand state objects in a web tier, like shopping carts.
 * @param session current HTTP session
 * @param name the name of the session attribute
 * @param clazz the class to instantiate for a new attribute
 * @return the value of the session attribute, newly created if not found
 * @throws IllegalArgumentException if the session attribute could not be instantiated
 * @deprecated as of Spring 4.3.2, in favor of custom code for such purposes
 */
@Deprecated public static Object getOrCreateSessionAttribute(HttpSession session,String name,Class<?> clazz) throws IllegalArgumentException {
  Assert.notNull(session,""Session must not be null"");
  Object sessionObject=session.getAttribute(name);
  if (sessionObject == null) {
    try {
      sessionObject=clazz.newInstance();
    }
 catch (    InstantiationException ex) {
      throw new IllegalArgumentException(""Could not instantiate class ["" + clazz.getName() + ""] for session attribute '""+ name+ ""': ""+ ex.getMessage());
    }
catch (    IllegalAccessException ex) {
      throw new IllegalArgumentException(""Could not access default constructor of class ["" + clazz.getName() + ""] for session attribute '""+ name+ ""': ""+ ex.getMessage());
    }
    session.setAttribute(name,sessionObject);
  }
  return sessionObject;
}
"
"/** 
 * Expose the given Map as request attributes, using the keys as attribute names and the values as corresponding attribute values. Keys need to be Strings.
 * @param request current HTTP request
 * @param attributes the attributes Map
 * @deprecated as of Spring 4.3.2, in favor of custom code for such purposes
 */
@Deprecated public static void exposeRequestAttributes(ServletRequest request,Map<String,?> attributes){
  Assert.notNull(request,""Request must not be null"");
  Assert.notNull(attributes,""Attributes Map must not be null"");
  for (  Map.Entry<String,?> entry : attributes.entrySet()) {
    request.setAttribute(entry.getKey(),entry.getValue());
  }
}
"
"/** 
 * Return the target page specified in the request.
 * @param request current servlet request
 * @param paramPrefix the parameter prefix to check for(e.g. ""_target"" for parameters like ""_target1"" or ""_target2"")
 * @param currentPage the current page, to be returned as fallbackif no target page specified
 * @return the page specified in the request, or current page if not found
 * @deprecated as of Spring 4.3.2, in favor of custom code for such purposes
 */
@Deprecated public static int getTargetPage(ServletRequest request,String paramPrefix,int currentPage){
  Enumeration<String> paramNames=request.getParameterNames();
  while (paramNames.hasMoreElements()) {
    String paramName=paramNames.nextElement();
    if (paramName.startsWith(paramPrefix)) {
      for (int i=0; i < WebUtils.SUBMIT_IMAGE_SUFFIXES.length; i++) {
        String suffix=WebUtils.SUBMIT_IMAGE_SUFFIXES[i];
        if (paramName.endsWith(suffix)) {
          paramName=paramName.substring(0,paramName.length() - suffix.length());
        }
      }
      return Integer.parseInt(paramName.substring(paramPrefix.length()));
    }
  }
  return currentPage;
}
"
"/** 
 * Extract the URL filename from the given request URL path. Correctly resolves nested paths such as ""/products/view.html"" as well.
 * @param urlPath the request URL path (e.g. ""/index.html"")
 * @return the extracted URI filename (e.g. ""index"")
 * @deprecated as of Spring 4.3.2, in favor of custom code for such purposes
 */
@Deprecated public static String extractFilenameFromUrlPath(String urlPath){
  String filename=extractFullFilenameFromUrlPath(urlPath);
  int dotIndex=filename.lastIndexOf('.');
  if (dotIndex != -1) {
    filename=filename.substring(0,dotIndex);
  }
  return filename;
}
"
"/** 
 * Extract the full URL filename (including file extension) from the given request URL path. Correctly resolve nested paths such as ""/products/view.html"" and remove any path and or query parameters.
 * @param urlPath the request URL path (e.g. ""/products/index.html"")
 * @return the extracted URI filename (e.g. ""index.html"")
 * @deprecated as of Spring 4.3.2, in favor of custom code for such purposes(or  {@link UriUtils#extractFileExtension} for the file extension use case)
 */
@Deprecated public static String extractFullFilenameFromUrlPath(String urlPath){
  int end=urlPath.indexOf('?');
  if (end == -1) {
    end=urlPath.indexOf('#');
    if (end == -1) {
      end=urlPath.length();
    }
  }
  int begin=urlPath.lastIndexOf('/',end) + 1;
  int paramIndex=urlPath.indexOf(';',begin);
  end=(paramIndex != -1 && paramIndex < end ? paramIndex : end);
  return urlPath.substring(begin,end);
}
"
"/** 
 * Replacement for  {@code Class.forName()} that also returns Class instancesfor primitives (like ""int"") and array class names (like ""String[]""). <p>Always uses the default class loader: that is, preferably the thread context class loader, or the ClassLoader that loaded the ClassUtils class as fallback.
 * @param name the name of the Class
 * @return Class instance for the supplied name
 * @throws ClassNotFoundException if the class was not found
 * @throws LinkageError if the class file could not be loaded
 * @see Class#forName(String,boolean,ClassLoader)
 * @see #getDefaultClassLoader()
 * @deprecated as of Spring 3.0, in favor of specifying a ClassLoader explicitly:see  {@link #forName(String,ClassLoader)}
 */
@Deprecated public static Class<?> forName(String name) throws ClassNotFoundException, LinkageError {
  return forName(name,getDefaultClassLoader());
}
"
"/** 
 * Determine whether the  {@link Class} identified by the supplied name is presentand can be loaded. Will return  {@code false} if either the class orone of its dependencies is not present or cannot be loaded.
 * @param className the name of the class to check
 * @return whether the specified class is present
 * @deprecated as of Spring 2.5, in favor of {@link #isPresent(String,ClassLoader)}
 */
@Deprecated public static boolean isPresent(String className){
  return isPresent(className,getDefaultClassLoader());
}
"
"/** 
 * Get the value stored under the specified  {@code attributeName} as astring, taking into account alias semantics defined via {@link AliasFor @AliasFor}. <p>If there is no value stored under the specified  {@code attributeName}but the attribute has an alias declared via  {@code @AliasFor}, the value of the alias will be returned.
 * @param attributeName the name of the attribute to get; never{@code null} or empty
 * @param annotationType the type of annotation represented by this{@code AnnotationAttributes} instance; never {@code null}
 * @param annotationSource the source of the annotation represented bythis  {@code AnnotationAttributes} (e.g., the {@link AnnotatedElement}); or  {@code null} if unknown
 * @return the string value
 * @throws IllegalArgumentException if the attribute and its alias donot exist or are not of type  {@code String}
 * @throws AnnotationConfigurationException if the attribute and itsalias are both present with different non-empty values
 * @since 4.2
 * @deprecated as of Spring 4.3.2, in favor of built-in alias resolutionin  {@link #getString} itself
 */
@Deprecated public String getAliasedString(String attributeName,Class<? extends Annotation> annotationType,Object annotationSource){
  return getRequiredAttributeWithAlias(attributeName,annotationType,annotationSource,String.class);
}
"
"/** 
 * Get the value stored under the specified  {@code attributeName} as anarray of strings, taking into account alias semantics defined via {@link AliasFor @AliasFor}. <p>If there is no value stored under the specified  {@code attributeName}but the attribute has an alias declared via  {@code @AliasFor}, the value of the alias will be returned.
 * @param attributeName the name of the attribute to get; never{@code null} or empty
 * @param annotationType the type of annotation represented by this{@code AnnotationAttributes} instance; never {@code null}
 * @param annotationSource the source of the annotation represented bythis  {@code AnnotationAttributes} (e.g., the {@link AnnotatedElement}); or  {@code null} if unknown
 * @return the array of strings
 * @throws IllegalArgumentException if the attribute and its alias donot exist or are not of type  {@code String[]}
 * @throws AnnotationConfigurationException if the attribute and itsalias are both present with different non-empty values
 * @since 4.2
 * @deprecated as of Spring 4.3.2, in favor of built-in alias resolutionin  {@link #getStringArray} itself
 */
@Deprecated public String[] getAliasedStringArray(String attributeName,Class<? extends Annotation> annotationType,Object annotationSource){
  return getRequiredAttributeWithAlias(attributeName,annotationType,annotationSource,String[].class);
}
"
"/** 
 * Get the value stored under the specified  {@code attributeName} as anarray of classes, taking into account alias semantics defined via {@link AliasFor @AliasFor}. <p>If there is no value stored under the specified  {@code attributeName}but the attribute has an alias declared via  {@code @AliasFor}, the value of the alias will be returned.
 * @param attributeName the name of the attribute to get; never{@code null} or empty
 * @param annotationType the type of annotation represented by this{@code AnnotationAttributes} instance; never {@code null}
 * @param annotationSource the source of the annotation represented bythis  {@code AnnotationAttributes} (e.g., the {@link AnnotatedElement}); or  {@code null} if unknown
 * @return the array of classes
 * @throws IllegalArgumentException if the attribute and its alias donot exist or are not of type  {@code Class[]}
 * @throws AnnotationConfigurationException if the attribute and itsalias are both present with different non-empty values
 * @since 4.2
 * @deprecated as of Spring 4.3.2, in favor of built-in alias resolutionin  {@link #getClassArray} itself
 */
@Deprecated public Class<?>[] getAliasedClassArray(String attributeName,Class<? extends Annotation> annotationType,Object annotationSource){
  return getRequiredAttributeWithAlias(attributeName,annotationType,annotationSource,Class[].class);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * @see #fromMethod(Class,Method,Object)
 * @see #fromMethod(UriComponentsBuilder,Class,Method,Object)
 * @deprecated as of 4.2, this is deprecated in favor of the overloadedmethod that also accepts a controllerType argument
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @deprecated as of 4.2, this is deprecated in favor of alternative constructorsthat accept a controllerType argument
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * Convenience method to instantiate a class using its no-arg constructor.
 * @param clazz class to instantiate
 * @return the new instance
 * @throws BeanInstantiationException if the bean cannot be instantiated
 * @deprecated as of Spring 5.0, following the deprecation of{@link Class#newInstance()} in JDK 9
 * @see Class#newInstance()
 */
@Deprecated public static <T>T instantiate(Class<T> clazz) throws BeanInstantiationException {
  Assert.notNull(clazz,""Class must not be null"");
  if (clazz.isInterface()) {
    throw new BeanInstantiationException(clazz,""Specified class is an interface"");
  }
  try {
    return clazz.newInstance();
  }
 catch (  InstantiationException ex) {
    throw new BeanInstantiationException(clazz,""Is it an abstract class?"",ex);
  }
catch (  IllegalAccessException ex) {
    throw new BeanInstantiationException(clazz,""Is the constructor accessible?"",ex);
  }
}
"
"/** 
 * @deprecated as of 4.2.8, in favor of {@link #addPlaceholderValue(String,String)}
 */
@Deprecated public StandaloneMockMvcBuilder addPlaceHolderValue(String name,String value){
  this.placeholderValues.put(name,value);
  return this;
}
"
"/** 
 * @deprecated as of 4.3, in favor of {@link #setBeanFactory}
 */
@Deprecated public void setApplicationContext(ApplicationContext applicationContext){
  this.beanFactory=applicationContext;
}
"
"/** 
 * @deprecated as of 4.2.8, in favor of {@link #addPlaceholderValue(String,String)}
 */
@Deprecated public StandaloneMockMvcBuilder addPlaceHolderValue(String name,String value){
  this.placeholderValues.put(name,value);
  return this;
}
"
"/** 
 * Create a new UnsatisfiedDependencyException.
 * @param resourceDescription description of the resource that the bean definition came from
 * @param beanName the name of the bean requested
 * @param ctorArgIndex the index of the constructor argument that couldn't be satisfied
 * @param ctorArgType the type of the constructor argument that couldn't be satisfied
 * @param msg the detail message
 * @deprecated in favor of {@link #UnsatisfiedDependencyException(String,String,InjectionPoint,String)}
 */
@Deprecated public UnsatisfiedDependencyException(String resourceDescription,String beanName,int ctorArgIndex,Class<?> ctorArgType,String msg){
  super(resourceDescription,beanName,""Unsatisfied dependency expressed through constructor argument with index "" + ctorArgIndex + "" of type [""+ ClassUtils.getQualifiedName(ctorArgType)+ ""]""+ (msg != null ? "": "" + msg : """"));
}
"
"/** 
 * Create a new UnsatisfiedDependencyException.
 * @param resourceDescription description of the resource that the bean definition came from
 * @param beanName the name of the bean requested
 * @param ctorArgIndex the index of the constructor argument that couldn't be satisfied
 * @param ctorArgType the type of the constructor argument that couldn't be satisfied
 * @param ex the bean creation exception that indicated the unsatisfied dependency
 * @deprecated in favor of {@link #UnsatisfiedDependencyException(String,String,InjectionPoint,BeansException)}
 */
@Deprecated public UnsatisfiedDependencyException(String resourceDescription,String beanName,int ctorArgIndex,Class<?> ctorArgType,BeansException ex){
  this(resourceDescription,beanName,ctorArgIndex,ctorArgType,(ex != null ? ex.getMessage() : """"));
  initCause(ex);
}
"
"/** 
 * Provide a registry with which to register active user session ids.
 * @see org.springframework.messaging.simp.user.UserDestinationMessageHandler
 * @deprecated as of 4.2 in favor of {@link DefaultSimpUserRegistry} which relieson the ApplicationContext events published by this class and is created via {@link org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#createLocalUserRegistry WebSocketMessageBrokerConfigurationSupport.createLocalUserRegistry}
 */
@Deprecated public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry){
  this.userSessionRegistry=registry;
}
"
"/** 
 * @deprecated as of 4.2
 */
@Deprecated public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry(){
  return this.userSessionRegistry;
}
"
"/** 
 * Provide a registry with which to register active user session ids.
 * @see org.springframework.messaging.simp.user.UserDestinationMessageHandler
 * @deprecated as of 4.2 in favor of {@link DefaultSimpUserRegistry} which relieson the ApplicationContext events published by this class and is created via {@link org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#createLocalUserRegistry WebSocketMessageBrokerConfigurationSupport.createLocalUserRegistry}
 */
@Deprecated public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry){
  this.userSessionRegistry=registry;
}
"
"/** 
 * @deprecated as of 4.2
 */
@Deprecated public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry(){
  return this.userSessionRegistry;
}
"
"/** 
 * Provide a registry with which to register active user session ids.
 * @see org.springframework.messaging.simp.user.UserDestinationMessageHandler
 * @deprecated as of 4.2 in favor of {@link DefaultSimpUserRegistry} which relieson the ApplicationContext events published by this class and is created via {@link org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#createLocalUserRegistry WebSocketMessageBrokerConfigurationSupport.createLocalUserRegistry}
 */
@Deprecated public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry){
  this.userSessionRegistry=registry;
}
"
"/** 
 * @deprecated as of 4.2
 */
@Deprecated public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry(){
  return this.userSessionRegistry;
}
"
"/** 
 * Provide a registry with which to register active user session ids.
 * @see org.springframework.messaging.simp.user.UserDestinationMessageHandler
 * @deprecated as of 4.2 in favor of {@link DefaultSimpUserRegistry} which relieson the ApplicationContext events published by this class and is created via {@link org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#createLocalUserRegistry WebSocketMessageBrokerConfigurationSupport.createLocalUserRegistry}
 */
@Deprecated public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry){
  this.userSessionRegistry=registry;
}
"
"/** 
 * @deprecated as of 4.2
 */
@Deprecated public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry(){
  return this.userSessionRegistry;
}
"
"/** 
 * Configure headers to be added to every executed HTTP request.
 * @param requestHeaders the headers to add to requests
 * @deprecated as of 4.2 in favor of {@link SockJsClient#setHttpHeaderNames}.
 */
@Deprecated public void setRequestHeaders(HttpHeaders requestHeaders){
  this.requestHeaders.clear();
  if (requestHeaders != null) {
    this.requestHeaders.putAll(requestHeaders);
  }
}
"
"/** 
 * Configure headers to be added to every executed HTTP request.
 * @param requestHeaders the headers to add to requests
 * @deprecated as of 4.2 in favor of {@link SockJsClient#setHttpHeaderNames}.
 */
@Deprecated public void setRequestHeaders(HttpHeaders requestHeaders){
  this.requestHeaders.clear();
  if (requestHeaders != null) {
    this.requestHeaders.putAll(requestHeaders);
  }
}
"
"/** 
 * Provide a registry with which to register active user session ids.
 * @see org.springframework.messaging.simp.user.UserDestinationMessageHandler
 * @deprecated as of 4.2 in favor of {@link DefaultSimpUserRegistry} which relieson the ApplicationContext events published by this class and is created via {@link org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#createLocalUserRegistry WebSocketMessageBrokerConfigurationSupport.createLocalUserRegistry}
 */
@Deprecated public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry){
  this.userSessionRegistry=registry;
}
"
"/** 
 * @deprecated as of 4.2
 */
@Deprecated public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry(){
  return this.userSessionRegistry;
}
"
"/** 
 * Provide a registry with which to register active user session ids.
 * @see org.springframework.messaging.simp.user.UserDestinationMessageHandler
 * @deprecated as of 4.2 in favor of {@link DefaultSimpUserRegistry} which relieson the ApplicationContext events published by this class and is created via {@link org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#createLocalUserRegistry WebSocketMessageBrokerConfigurationSupport.createLocalUserRegistry}
 */
@Deprecated public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry){
  this.userSessionRegistry=registry;
}
"
"/** 
 * @deprecated as of 4.2
 */
@Deprecated public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry(){
  return this.userSessionRegistry;
}
"
"/** 
 * Create a new  {@code NoSuchBeanDefinitionException}.
 * @param type required type of the missing bean
 * @param dependencyDescription a description of the originating dependency
 * @param message detailed message describing the problem
 * @deprecated as of Spring 5.0, in favor of {@link #NoSuchBeanDefinitionException(ResolvableType,String)}
 */
@Deprecated public NoSuchBeanDefinitionException(Class<?> type,String dependencyDescription,String message){
  this(ResolvableType.forClass(type),dependencyDescription,message);
}
"
"/** 
 * Create a new  {@code NoSuchBeanDefinitionException}.
 * @param type required type of the missing bean
 * @param dependencyDescription a description of the originating dependency
 * @param message detailed message describing the problem
 * @deprecated as of Spring 5.0, in favor of {@link #NoSuchBeanDefinitionException(ResolvableType,String)}
 */
@Deprecated public NoSuchBeanDefinitionException(Class<?> type,String dependencyDescription,String message){
  this(ResolvableType.forClass(type),dependencyDescription,message);
}
"
"/** 
 * @deprecated as of 4.3, in favor of {@link #setBeanFactory}
 */
@Deprecated public void setApplicationContext(ApplicationContext applicationContext){
  this.beanFactory=applicationContext;
}
"
"/** 
 * @deprecated as of 4.3, in favor of {@link #setBeanFactory}
 */
@Deprecated public void setApplicationContext(ApplicationContext applicationContext){
  this.beanFactory=applicationContext;
}
"
"/** 
 * @deprecated as of 4.3, in favor of {@link #setBeanFactory}
 */
@Deprecated public void setApplicationContext(ApplicationContext applicationContext){
  this.beanFactory=applicationContext;
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Create a new  {@code NoSuchBeanDefinitionException}.
 * @param type required type of the missing bean
 * @param dependencyDescription a description of the originating dependency
 * @param message detailed message describing the problem
 * @deprecated as of 4.3.4, in favor of {@link #NoSuchBeanDefinitionException(ResolvableType,String)}
 */
@Deprecated public NoSuchBeanDefinitionException(Class<?> type,String dependencyDescription,String message){
  super(""No qualifying bean"" + (!StringUtils.hasLength(dependencyDescription) ? "" of type '"" + ClassUtils.getQualifiedName(type) + ""'"" : """") + "" found for dependency""+ (StringUtils.hasLength(dependencyDescription) ? "" ["" + dependencyDescription + ""]"" : """")+ "": ""+ message);
  this.resolvableType=ResolvableType.forClass(type);
}
"
"/** 
 * Produce a complete message including the prefix, the position (if known) and with the inserts applied to the message.
 * @param pos the position (ignored and not included in the message if less than 0)
 * @param inserts the inserts to put into the formatted message
 * @return a formatted message
 * @deprecated as of Spring 4.3.5, in favor of {@link #formatMessage(Object)}
 */
@Deprecated public String formatMessage(int pos,Object... inserts){
  StringBuilder formattedMessage=new StringBuilder();
  formattedMessage.append(""EL"").append(this.code);
switch (this.kind) {
case ERROR:
    formattedMessage.append(""E"");
  break;
}
formattedMessage.append("":"");
if (pos >= 0) {
formattedMessage.append(""(pos "").append(pos).append(""): "");
}
formattedMessage.append(MessageFormat.format(this.message,inserts));
return formattedMessage.toString();
}
"
"/** 
 * Create a new MethodParameter for the given method or constructor. <p>This is a convenience factory method for scenarios where a Method or Constructor reference is treated in a generic fashion.
 * @param methodOrConstructor the Method or Constructor to specify a parameter for
 * @param parameterIndex the index of the parameter
 * @return the corresponding MethodParameter instance
 * @deprecated as of 5.0, in favor of {@link #forExecutable}
 */
@Deprecated public static MethodParameter forMethodOrConstructor(Object methodOrConstructor,int parameterIndex){
  if (!(methodOrConstructor instanceof Executable)) {
    throw new IllegalArgumentException(""Given object ["" + methodOrConstructor + ""] is neither a Method nor a Constructor"");
  }
  return forExecutable((Executable)methodOrConstructor,parameterIndex);
}
"
"/** 
 * Create a new MethodParameter for the given method or constructor. <p>This is a convenience factory method for scenarios where a Method or Constructor reference is treated in a generic fashion.
 * @param methodOrConstructor the Method or Constructor to specify a parameter for
 * @param parameterIndex the index of the parameter
 * @return the corresponding MethodParameter instance
 * @deprecated as of 5.0, in favor of {@link #forExecutable}
 */
@Deprecated public static MethodParameter forMethodOrConstructor(Object methodOrConstructor,int parameterIndex){
  if (!(methodOrConstructor instanceof Executable)) {
    throw new IllegalArgumentException(""Given object ["" + methodOrConstructor + ""] is neither a Method nor a Constructor"");
  }
  return forExecutable((Executable)methodOrConstructor,parameterIndex);
}
"
"/** 
 * Produce a complete message including the prefix, the position (if known) and with the inserts applied to the message.
 * @param pos the position (ignored and not included in the message if less than 0)
 * @param inserts the inserts to put into the formatted message
 * @return a formatted message
 * @deprecated as of Spring 4.3.5, in favor of {@link #formatMessage(Object)}
 */
@Deprecated public String formatMessage(int pos,Object... inserts){
  StringBuilder formattedMessage=new StringBuilder();
  formattedMessage.append(""EL"").append(this.code);
switch (this.kind) {
case ERROR:
    formattedMessage.append(""E"");
  break;
}
formattedMessage.append("":"");
if (pos >= 0) {
formattedMessage.append(""(pos "").append(pos).append(""): "");
}
formattedMessage.append(MessageFormat.format(this.message,inserts));
return formattedMessage.toString();
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}. <p>This method follows <em>find semantics</em> as described in the {@linkplain AnnotatedElementUtils class-level javadoc}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Provide a registry with which to register active user session ids.
 * @see org.springframework.messaging.simp.user.UserDestinationMessageHandler
 * @deprecated as of 4.2 in favor of {@link DefaultSimpUserRegistry} which relieson the ApplicationContext events published by this class and is created via {@link org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#createLocalUserRegistry WebSocketMessageBrokerConfigurationSupport.createLocalUserRegistry}
 */
@Deprecated public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry){
  this.userSessionRegistry=registry;
}
"
"/** 
 * @deprecated as of 4.2
 */
@Deprecated public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry(){
  return this.userSessionRegistry;
}
"
"/** 
 * @deprecated as of Spring 4.2.8, in favor of {@link #getUrlPathHelper}
 */
@Deprecated public UrlPathHelper getPathHelper(){
  return this.urlPathHelper;
}
"
"/** 
 * Create a new MethodParameter for the given method or constructor. <p>This is a convenience factory method for scenarios where a Method or Constructor reference is treated in a generic fashion.
 * @param methodOrConstructor the Method or Constructor to specify a parameter for
 * @param parameterIndex the index of the parameter
 * @return the corresponding MethodParameter instance
 * @deprecated as of 5.0, in favor of {@link #forExecutable}
 */
@Deprecated public static MethodParameter forMethodOrConstructor(Object methodOrConstructor,int parameterIndex){
  if (!(methodOrConstructor instanceof Executable)) {
    throw new IllegalArgumentException(""Given object ["" + methodOrConstructor + ""] is neither a Method nor a Constructor"");
  }
  return forExecutable((Executable)methodOrConstructor,parameterIndex);
}
"
"/** 
 * Provide a registry with which to register active user session ids.
 * @see org.springframework.messaging.simp.user.UserDestinationMessageHandler
 * @deprecated as of 4.2 in favor of {@link DefaultSimpUserRegistry} which relieson the ApplicationContext events published by this class and is created via {@link org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#createLocalUserRegistry WebSocketMessageBrokerConfigurationSupport.createLocalUserRegistry}
 */
@Deprecated public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry){
  this.userSessionRegistry=registry;
}
"
"/** 
 * @deprecated as of 4.2
 */
@Deprecated public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry(){
  return this.userSessionRegistry;
}
"
"/** 
 * Create a new MethodParameter for the given method or constructor. <p>This is a convenience factory method for scenarios where a Method or Constructor reference is treated in a generic fashion.
 * @param methodOrConstructor the Method or Constructor to specify a parameter for
 * @param parameterIndex the index of the parameter
 * @return the corresponding MethodParameter instance
 * @deprecated as of 5.0, in favor of {@link #forExecutable}
 */
@Deprecated public static MethodParameter forMethodOrConstructor(Object methodOrConstructor,int parameterIndex){
  if (!(methodOrConstructor instanceof Executable)) {
    throw new IllegalArgumentException(""Given object ["" + methodOrConstructor + ""] is neither a Method nor a Constructor"");
  }
  return forExecutable((Executable)methodOrConstructor,parameterIndex);
}
"
"/** 
 * Return the character set, as indicated by a  {@code charset} parameter, if any.
 * @return the character set, or {@code null} if not available
 * @deprecated as of Spring 4.3, in favor of {@link #getCharset()} with its namealigned with the Java return type name
 */
@Deprecated public Charset getCharSet(){
  return getCharset();
}
"
"/** 
 * Create a new  {@code NoSuchBeanDefinitionException}.
 * @param type required type of the missing bean
 * @param dependencyDescription a description of the originating dependency
 * @param message detailed message describing the problem
 * @deprecated as of 4.3.4, in favor of {@link #NoSuchBeanDefinitionException(ResolvableType,String)}
 */
@Deprecated public NoSuchBeanDefinitionException(Class<?> type,String dependencyDescription,String message){
  super(""No qualifying bean"" + (!StringUtils.hasLength(dependencyDescription) ? "" of type '"" + ClassUtils.getQualifiedName(type) + ""'"" : """") + "" found for dependency""+ (StringUtils.hasLength(dependencyDescription) ? "" ["" + dependencyDescription + ""]"" : """")+ "": ""+ message);
  this.resolvableType=ResolvableType.forClass(type);
}
"
"/** 
 * Set whether to extract the old field value when applying a property editor to a new value for a field. <p>Default is ""true"", exposing previous field values to custom editors. Turn this to ""false"" to avoid side effects caused by getters.
 * @deprecated as of Spring 4.3.5, in favor of customizing this in{@link #createBeanPropertyBindingResult()} or{@link #createDirectFieldBindingResult()} itself
 */
@Deprecated public void setExtractOldValueForEditor(boolean extractOldValueForEditor){
  getPropertyAccessor().setExtractOldValueForEditor(extractOldValueForEditor);
}
"
"/** 
 * Set whether to extract the old field value when applying a property editor to a new value for a field. <p>Default is ""true"", exposing previous field values to custom editors. Turn this to ""false"" to avoid side effects caused by getters.
 * @deprecated as of Spring 4.3.5, in favor of customizing this in{@link #createBeanPropertyBindingResult()} or{@link #createDirectFieldBindingResult()} itself
 */
@Deprecated public void setExtractOldValueForEditor(boolean extractOldValueForEditor){
  getPropertyAccessor().setExtractOldValueForEditor(extractOldValueForEditor);
}
"
"/** 
 * Provide a registry with which to register active user session ids.
 * @see org.springframework.messaging.simp.user.UserDestinationMessageHandler
 * @deprecated as of 4.2 in favor of {@link DefaultSimpUserRegistry} which relieson the ApplicationContext events published by this class and is created via {@link org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport#createLocalUserRegistry WebSocketMessageBrokerConfigurationSupport.createLocalUserRegistry}
 */
@Deprecated public void setUserSessionRegistry(org.springframework.messaging.simp.user.UserSessionRegistry registry){
  this.userSessionRegistry=registry;
}
"
"/** 
 * @deprecated as of 4.2
 */
@Deprecated public org.springframework.messaging.simp.user.UserSessionRegistry getUserSessionRegistry(){
  return this.userSessionRegistry;
}
"
"/** 
 * Adds a handle to the constant pool of the class being build. Does nothing if the constant pool already contains a similar item. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed byclass generators or adapters.</i>
 * @param tag the kind of this handle. Must be  {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC},  {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC},  {@link Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link Opcodes#H_NEWINVOKESPECIAL} or{@link Opcodes#H_INVOKEINTERFACE}.
 * @param owner the internal name of the field or method owner class.
 * @param name the name of the field or method.
 * @param desc the descriptor of the field or method.
 * @return the index of a new or already existing method type referenceitem.
 * @deprecated this method is superseded by{@link #newHandle(int,String,String,String,boolean)}.
 */
@Deprecated public int newHandle(final int tag,final String owner,final String name,final String desc){
  return newHandle(tag,owner,name,desc,tag == Opcodes.H_INVOKEINTERFACE);
}
"
"/** 
 * Adds a handle to the constant pool of the class being build. Does nothing if the constant pool already contains a similar item. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed byclass generators or adapters.</i>
 * @param tag the kind of this handle. Must be  {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC},  {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC},  {@link Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link Opcodes#H_NEWINVOKESPECIAL} or{@link Opcodes#H_INVOKEINTERFACE}.
 * @param owner the internal name of the field or method owner class.
 * @param name the name of the field or method.
 * @param desc the descriptor of the field or method.
 * @return the index of a new or already existing method type referenceitem.
 * @deprecated this method is superseded by{@link #newHandle(int,String,String,String,boolean)}.
 */
@Deprecated public int newHandle(final int tag,final String owner,final String name,final String desc){
  return newHandle(tag,owner,name,desc,tag == Opcodes.H_INVOKEINTERFACE);
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * Add an indexed constructor arg value. The current index is tracked internally and all additions are at the present point.
 * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}. This variant just remains around for Spring Security 2.x compatibility.
 */
@Deprecated public BeanDefinitionBuilder addConstructorArg(Object value){
  return addConstructorArgValue(value);
}
"
"/** 
 * Determine the target type for the given parameter specification.
 * @param methodParameter the method parameter specification
 * @return the corresponding generic parameter type
 * @deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()}
 */
@Deprecated public static Type getTargetType(MethodParameter methodParameter){
  Assert.notNull(methodParameter,""MethodParameter must not be null"");
  return methodParameter.getGenericParameterType();
}
"
"/** 
 * Resolve the specified generic type against the given TypeVariable map.
 * @param genericType the generic type to resolve
 * @param map the TypeVariable Map to resolved against
 * @return the type if it resolves to a Class, or {@code Object.class} otherwise
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated @SuppressWarnings(""rawtypes"") public static Class<?> resolveType(Type genericType,Map<TypeVariable,Type> map){
  return ResolvableType.forType(genericType,new TypeVariableMapVariableResolver(map)).resolve(Object.class);
}
"
"/** 
 * Build a mapping of  {@link TypeVariable#getName TypeVariable names} to{@link Class concrete classes} for the specified {@link Class}. Searches all super types, enclosing types and interfaces.
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated @SuppressWarnings(""rawtypes"") public static Map<TypeVariable,Type> getTypeVariableMap(Class<?> clazz){
  Map<TypeVariable,Type> typeVariableMap=typeVariableCache.get(clazz);
  if (typeVariableMap == null) {
    typeVariableMap=new HashMap<>();
    buildTypeVariableMap(ResolvableType.forClass(clazz),typeVariableMap);
    typeVariableCache.put(clazz,Collections.unmodifiableMap(typeVariableMap));
  }
  return typeVariableMap;
}
"
"/** 
 * Create a new MethodParameter for the given method or constructor. <p>This is a convenience factory method for scenarios where a Method or Constructor reference is treated in a generic fashion.
 * @param methodOrConstructor the Method or Constructor to specify a parameter for
 * @param parameterIndex the index of the parameter
 * @return the corresponding MethodParameter instance
 * @deprecated as of 5.0, in favor of {@link #forExecutable}
 */
@Deprecated public static MethodParameter forMethodOrConstructor(Object methodOrConstructor,int parameterIndex){
  if (!(methodOrConstructor instanceof Executable)) {
    throw new IllegalArgumentException(""Given object ["" + methodOrConstructor + ""] is neither a Method nor a Constructor"");
  }
  return forExecutable((Executable)methodOrConstructor,parameterIndex);
}
"
"/** 
 * Determine the generic element type of the wrapped Collection parameter/field, if any.
 * @return the generic type, or {@code null} if none
 * @deprecated as of 4.3.6, in favor of direct {@link ResolvableType} usage
 */
@Deprecated public Class<?> getCollectionType(){
  return (this.field != null ? org.springframework.core.GenericCollectionTypeResolver.getCollectionFieldType(this.field,this.nestingLevel) : org.springframework.core.GenericCollectionTypeResolver.getCollectionParameterType(this.methodParameter));
}
"
"/** 
 * Determine the generic key type of the wrapped Map parameter/field, if any.
 * @return the generic type, or {@code null} if none
 * @deprecated as of 4.3.6, in favor of direct {@link ResolvableType} usage
 */
@Deprecated public Class<?> getMapKeyType(){
  return (this.field != null ? org.springframework.core.GenericCollectionTypeResolver.getMapKeyFieldType(this.field,this.nestingLevel) : org.springframework.core.GenericCollectionTypeResolver.getMapKeyParameterType(this.methodParameter));
}
"
"/** 
 * Determine the generic value type of the wrapped Map parameter/field, if any.
 * @return the generic type, or {@code null} if none
 * @deprecated as of 4.3.6, in favor of direct {@link ResolvableType} usage
 */
@Deprecated public Class<?> getMapValueType(){
  return (this.field != null ? org.springframework.core.GenericCollectionTypeResolver.getMapValueFieldType(this.field,this.nestingLevel) : org.springframework.core.GenericCollectionTypeResolver.getMapValueParameterType(this.methodParameter));
}
"
"/** 
 * Determine the generic element type of the given Collection field.
 * @param collectionField the collection field to introspect
 * @param nestingLevel the nesting level of the target type(typically 1; e.g. in case of a List of Lists, 1 would indicate the nested List, whereas 2 would indicate the element of the nested List)
 * @param typeIndexesPerLevel Map keyed by nesting level, with each valueexpressing the type index for traversal at that level
 * @return the generic type, or {@code null} if none
 * @deprecated as of 4.0, in favor of using {@link ResolvableType} for arbitrary nesting levels
 */
@Deprecated public static Class<?> getCollectionFieldType(Field collectionField,int nestingLevel,Map<Integer,Integer> typeIndexesPerLevel){
  return ResolvableType.forField(collectionField).getNested(nestingLevel,typeIndexesPerLevel).asCollection().resolveGeneric();
}
"
"/** 
 * Determine the generic key type of the given Map field.
 * @param mapField the map field to introspect
 * @param nestingLevel the nesting level of the target type(typically 1; e.g. in case of a List of Lists, 1 would indicate the nested List, whereas 2 would indicate the element of the nested List)
 * @param typeIndexesPerLevel Map keyed by nesting level, with each valueexpressing the type index for traversal at that level
 * @return the generic type, or {@code null} if none
 * @deprecated as of 4.0, in favor of using {@link ResolvableType} for arbitrary nesting levels
 */
@Deprecated public static Class<?> getMapKeyFieldType(Field mapField,int nestingLevel,Map<Integer,Integer> typeIndexesPerLevel){
  return ResolvableType.forField(mapField).getNested(nestingLevel,typeIndexesPerLevel).asMap().resolveGeneric(0);
}
"
"/** 
 * Determine the generic value type of the given Map field.
 * @param mapField the map field to introspect
 * @param nestingLevel the nesting level of the target type(typically 1; e.g. in case of a List of Lists, 1 would indicate the nested List, whereas 2 would indicate the element of the nested List)
 * @param typeIndexesPerLevel Map keyed by nesting level, with each valueexpressing the type index for traversal at that level
 * @return the generic type, or {@code null} if none
 * @deprecated as of 4.0, in favor of using {@link ResolvableType} for arbitrary nesting levels
 */
@Deprecated public static Class<?> getMapValueFieldType(Field mapField,int nestingLevel,Map<Integer,Integer> typeIndexesPerLevel){
  return ResolvableType.forField(mapField).getNested(nestingLevel,typeIndexesPerLevel).asMap().resolveGeneric(1);
}
"
"/** 
 * Determine the target type for the given parameter specification.
 * @param methodParameter the method parameter specification
 * @return the corresponding generic parameter type
 * @deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()}
 */
@Deprecated public static Type getTargetType(MethodParameter methodParameter){
  Assert.notNull(methodParameter,""MethodParameter must not be null"");
  return methodParameter.getGenericParameterType();
}
"
"/** 
 * Resolve the specified generic type against the given TypeVariable map.
 * @param genericType the generic type to resolve
 * @param map the TypeVariable Map to resolved against
 * @return the type if it resolves to a Class, or {@code Object.class} otherwise
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated @SuppressWarnings(""rawtypes"") public static Class<?> resolveType(Type genericType,Map<TypeVariable,Type> map){
  return ResolvableType.forType(genericType,new TypeVariableMapVariableResolver(map)).resolve(Object.class);
}
"
"/** 
 * Build a mapping of  {@link TypeVariable#getName TypeVariable names} to{@link Class concrete classes} for the specified {@link Class}. Searches all super types, enclosing types and interfaces.
 * @deprecated as of Spring 4.0 in favor of {@link ResolvableType}
 */
@Deprecated @SuppressWarnings(""rawtypes"") public static Map<TypeVariable,Type> getTypeVariableMap(Class<?> clazz){
  Map<TypeVariable,Type> typeVariableMap=typeVariableCache.get(clazz);
  if (typeVariableMap == null) {
    typeVariableMap=new HashMap<TypeVariable,Type>();
    buildTypeVariableMap(ResolvableType.forClass(clazz),typeVariableMap);
    typeVariableCache.put(clazz,Collections.unmodifiableMap(typeVariableMap));
  }
  return typeVariableMap;
}
"
"/** 
 * Create a  {@link MockMultipartHttpServletRequestBuilder} for a multipart request.
 * @param urlTemplate a URL template; the resulting URL will be encoded
 * @param uriVars zero or more URI variables
 * @deprecated in favor of {@link #multipart(String,Object)}
 */
@Deprecated public static MockMultipartHttpServletRequestBuilder fileUpload(String urlTemplate,Object... uriVars){
  return new MockMultipartHttpServletRequestBuilder(urlTemplate,uriVars);
}
"
"/** 
 * Create a  {@link MockMultipartHttpServletRequestBuilder} for a multipart request.
 * @param uri the URL
 * @since 4.0.3
 * @deprecated in favor of {@link #multipart(URI)}
 */
@Deprecated public static MockMultipartHttpServletRequestBuilder fileUpload(URI uri){
  return new MockMultipartHttpServletRequestBuilder(uri);
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #isTrue(boolean,String)}
 */
@Deprecated public static void isTrue(boolean expression){
  isTrue(expression,""[Assertion failed] - this expression must be true"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #isNull(Object,String)}
 */
@Deprecated public static void isNull(Object object){
  isNull(object,""[Assertion failed] - the object argument must be null"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notNull(Object,String)}
 */
@Deprecated public static void notNull(Object object){
  notNull(object,""[Assertion failed] - this argument is required; it must not be null"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #hasLength(String,String)}
 */
@Deprecated public static void hasLength(String text){
  hasLength(text,""[Assertion failed] - this String argument must have length; it must not be null or empty"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #hasText(String,String)}
 */
@Deprecated public static void hasText(String text){
  hasText(text,""[Assertion failed] - this String argument must have text; it must not be null, empty, or blank"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #doesNotContain(String,String,String)}
 */
@Deprecated public static void doesNotContain(String textToSearch,String substring){
  doesNotContain(textToSearch,substring,() -> ""[Assertion failed] - this String argument must not contain the substring ["" + substring + ""]"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Object[],String)}
 */
@Deprecated public static void notEmpty(Object[] array){
  notEmpty(array,""[Assertion failed] - this array must not be empty: it must contain at least 1 element"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #noNullElements(Object[],String)}
 */
@Deprecated public static void noNullElements(Object[] array){
  noNullElements(array,""[Assertion failed] - this array must not contain any null elements"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Collection,String)}
 */
@Deprecated public static void notEmpty(Collection<?> collection){
  notEmpty(collection,""[Assertion failed] - this collection must not be empty: it must contain at least 1 element"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Map,String)}
 */
@Deprecated public static void notEmpty(Map<?,?> map){
  notEmpty(map,""[Assertion failed] - this map must not be empty; it must contain at least one entry"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #state(boolean,String)}
 */
@Deprecated public static void state(boolean expression){
  state(expression,""[Assertion failed] - this state invariant must be true"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #isTrue(boolean,String)}
 */
@Deprecated public static void isTrue(boolean expression){
  isTrue(expression,""[Assertion failed] - this expression must be true"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #isNull(Object,String)}
 */
@Deprecated public static void isNull(Object object){
  isNull(object,""[Assertion failed] - the object argument must be null"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notNull(Object,String)}
 */
@Deprecated public static void notNull(Object object){
  notNull(object,""[Assertion failed] - this argument is required; it must not be null"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #hasLength(String,String)}
 */
@Deprecated public static void hasLength(String text){
  hasLength(text,""[Assertion failed] - this String argument must have length; it must not be null or empty"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #hasText(String,String)}
 */
@Deprecated public static void hasText(String text){
  hasText(text,""[Assertion failed] - this String argument must have text; it must not be null, empty, or blank"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #doesNotContain(String,String,String)}
 */
@Deprecated public static void doesNotContain(String textToSearch,String substring){
  doesNotContain(textToSearch,substring,""[Assertion failed] - this String argument must not contain the substring ["" + substring + ""]"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Object[],String)}
 */
@Deprecated public static void notEmpty(Object[] array){
  notEmpty(array,""[Assertion failed] - this array must not be empty: it must contain at least 1 element"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #noNullElements(Object[],String)}
 */
@Deprecated public static void noNullElements(Object[] array){
  noNullElements(array,""[Assertion failed] - this array must not contain any null elements"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Collection,String)}
 */
@Deprecated public static void notEmpty(Collection<?> collection){
  notEmpty(collection,""[Assertion failed] - this collection must not be empty: it must contain at least 1 element"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Map,String)}
 */
@Deprecated public static void notEmpty(Map<?,?> map){
  notEmpty(map,""[Assertion failed] - this map must not be empty; it must contain at least one entry"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #state(boolean,String)}
 */
@Deprecated public static void state(boolean expression){
  state(expression,""[Assertion failed] - this state invariant must be true"");
}
"
"/** 
 * @see #fromMethod(Class,Method,Object)
 * @see #fromMethod(UriComponentsBuilder,Class,Method,Object)
 * @deprecated as of 4.2, this is deprecated in favor of the overloadedmethod that also accepts a controllerType argument
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @deprecated as of 4.2, this is deprecated in favor of alternative constructorsthat accept a controllerType argument
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.MOVED_TEMPORARILY} (302).
 * @see #isFound()
 * @deprecated in favor of {@link #isFound()}
 */
@Deprecated public ExchangeActions isMovedTemporarily(){
  return doMatch(HttpStatus.MOVED_TEMPORARILY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.USE_PROXY} (305).
 * @deprecated matching the deprecation of {@code HttpStatus.USE_PROXY}
 */
@Deprecated public ExchangeActions isUseProxy(){
  return doMatch(HttpStatus.USE_PROXY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE} (413).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE}
 * @see #isPayloadTooLarge()
 */
@Deprecated public ExchangeActions isRequestEntityTooLarge(){
  return doMatch(HttpStatus.REQUEST_ENTITY_TOO_LARGE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_URI_TOO_LONG} (414).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_URI_TOO_LONG}
 * @see #isUriTooLong()
 */
@Deprecated public ExchangeActions isRequestUriTooLong(){
  return doMatch(HttpStatus.REQUEST_URI_TOO_LONG);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE}
 */
@Deprecated public ExchangeActions isInsufficientSpaceOnResource(){
  return doMatch(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of {@code HttpStatus.METHOD_FAILURE}
 */
@Deprecated public ExchangeActions isMethodFailure(){
  return doMatch(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of {@code HttpStatus.DESTINATION_LOCKED}
 */
@Deprecated public ExchangeActions isDestinationLocked(){
  return doMatch(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.MOVED_TEMPORARILY} (302).
 * @see #isFound()
 * @deprecated in favor of {@link #isFound()}
 */
@Deprecated public ExchangeActions isMovedTemporarily(){
  return doMatch(HttpStatus.MOVED_TEMPORARILY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.USE_PROXY} (305).
 * @deprecated matching the deprecation of {@code HttpStatus.USE_PROXY}
 */
@Deprecated public ExchangeActions isUseProxy(){
  return doMatch(HttpStatus.USE_PROXY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE} (413).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE}
 * @see #isPayloadTooLarge()
 */
@Deprecated public ExchangeActions isRequestEntityTooLarge(){
  return doMatch(HttpStatus.REQUEST_ENTITY_TOO_LARGE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_URI_TOO_LONG} (414).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_URI_TOO_LONG}
 * @see #isUriTooLong()
 */
@Deprecated public ExchangeActions isRequestUriTooLong(){
  return doMatch(HttpStatus.REQUEST_URI_TOO_LONG);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE}
 */
@Deprecated public ExchangeActions isInsufficientSpaceOnResource(){
  return doMatch(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of {@code HttpStatus.METHOD_FAILURE}
 */
@Deprecated public ExchangeActions isMethodFailure(){
  return doMatch(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of {@code HttpStatus.DESTINATION_LOCKED}
 */
@Deprecated public ExchangeActions isDestinationLocked(){
  return doMatch(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.MOVED_TEMPORARILY} (302).
 * @see #isFound()
 * @deprecated in favor of {@link #isFound()}
 */
@Deprecated public ExchangeActions isMovedTemporarily(){
  return assertStatusIsEqualTo(HttpStatus.MOVED_TEMPORARILY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.USE_PROXY} (305).
 * @deprecated matching the deprecation of {@code HttpStatus.USE_PROXY}
 */
@Deprecated public ExchangeActions isUseProxy(){
  return assertStatusIsEqualTo(HttpStatus.USE_PROXY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE} (413).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE}
 * @see #isPayloadTooLarge()
 */
@Deprecated public ExchangeActions isRequestEntityTooLarge(){
  return assertStatusIsEqualTo(HttpStatus.REQUEST_ENTITY_TOO_LARGE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_URI_TOO_LONG} (414).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_URI_TOO_LONG}
 * @see #isUriTooLong()
 */
@Deprecated public ExchangeActions isRequestUriTooLong(){
  return assertStatusIsEqualTo(HttpStatus.REQUEST_URI_TOO_LONG);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE}
 */
@Deprecated public ExchangeActions isInsufficientSpaceOnResource(){
  return assertStatusIsEqualTo(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of {@code HttpStatus.METHOD_FAILURE}
 */
@Deprecated public ExchangeActions isMethodFailure(){
  return assertStatusIsEqualTo(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of {@code HttpStatus.DESTINATION_LOCKED}
 */
@Deprecated public ExchangeActions isDestinationLocked(){
  return assertStatusIsEqualTo(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #state(boolean,String)}
 */
@Deprecated public static void state(boolean expression){
  state(expression,""[Assertion failed] - this state invariant must be true"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #isTrue(boolean,String)}
 */
@Deprecated public static void isTrue(boolean expression){
  isTrue(expression,""[Assertion failed] - this expression must be true"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #isNull(Object,String)}
 */
@Deprecated public static void isNull(Object object){
  isNull(object,""[Assertion failed] - the object argument must be null"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notNull(Object,String)}
 */
@Deprecated public static void notNull(Object object){
  notNull(object,""[Assertion failed] - this argument is required; it must not be null"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #hasLength(String,String)}
 */
@Deprecated public static void hasLength(String text){
  hasLength(text,""[Assertion failed] - this String argument must have length; it must not be null or empty"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #hasText(String,String)}
 */
@Deprecated public static void hasText(String text){
  hasText(text,""[Assertion failed] - this String argument must have text; it must not be null, empty, or blank"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #doesNotContain(String,String,String)}
 */
@Deprecated public static void doesNotContain(String textToSearch,String substring){
  doesNotContain(textToSearch,substring,() -> ""[Assertion failed] - this String argument must not contain the substring ["" + substring + ""]"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Object[],String)}
 */
@Deprecated public static void notEmpty(Object[] array){
  notEmpty(array,""[Assertion failed] - this array must not be empty: it must contain at least 1 element"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #noNullElements(Object[],String)}
 */
@Deprecated public static void noNullElements(Object[] array){
  noNullElements(array,""[Assertion failed] - this array must not contain any null elements"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Collection,String)}
 */
@Deprecated public static void notEmpty(Collection<?> collection){
  notEmpty(collection,""[Assertion failed] - this collection must not be empty: it must contain at least 1 element"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Map,String)}
 */
@Deprecated public static void notEmpty(Map<?,?> map){
  notEmpty(map,""[Assertion failed] - this map must not be empty; it must contain at least one entry"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #state(boolean,String)}
 */
@Deprecated public static void state(boolean expression){
  state(expression,""[Assertion failed] - this state invariant must be true"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #isTrue(boolean,String)}
 */
@Deprecated public static void isTrue(boolean expression){
  isTrue(expression,""[Assertion failed] - this expression must be true"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #isNull(Object,String)}
 */
@Deprecated public static void isNull(Object object){
  isNull(object,""[Assertion failed] - the object argument must be null"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notNull(Object,String)}
 */
@Deprecated public static void notNull(Object object){
  notNull(object,""[Assertion failed] - this argument is required; it must not be null"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #hasLength(String,String)}
 */
@Deprecated public static void hasLength(String text){
  hasLength(text,""[Assertion failed] - this String argument must have length; it must not be null or empty"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #hasText(String,String)}
 */
@Deprecated public static void hasText(String text){
  hasText(text,""[Assertion failed] - this String argument must have text; it must not be null, empty, or blank"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #doesNotContain(String,String,String)}
 */
@Deprecated public static void doesNotContain(String textToSearch,String substring){
  doesNotContain(textToSearch,substring,() -> ""[Assertion failed] - this String argument must not contain the substring ["" + substring + ""]"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Object[],String)}
 */
@Deprecated public static void notEmpty(Object[] array){
  notEmpty(array,""[Assertion failed] - this array must not be empty: it must contain at least 1 element"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #noNullElements(Object[],String)}
 */
@Deprecated public static void noNullElements(Object[] array){
  noNullElements(array,""[Assertion failed] - this array must not contain any null elements"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Collection,String)}
 */
@Deprecated public static void notEmpty(Collection<?> collection){
  notEmpty(collection,""[Assertion failed] - this collection must not be empty: it must contain at least 1 element"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Map,String)}
 */
@Deprecated public static void notEmpty(Map<?,?> map){
  notEmpty(map,""[Assertion failed] - this map must not be empty; it must contain at least one entry"");
}
"
"/** 
 * Get the  {@link Environment} associated with this helper instance.
 * @deprecated in favor of {@link XmlReaderContext#getEnvironment()}
 */
@Deprecated public final Environment getEnvironment(){
  return this.readerContext.getEnvironment();
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}. <p>This method follows <em>find semantics</em> as described in the {@linkplain AnnotatedElementUtils class-level javadoc}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element);
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #state(boolean,String)}
 */
@Deprecated public static void state(boolean expression){
  state(expression,""[Assertion failed] - this state invariant must be true"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #isTrue(boolean,String)}
 */
@Deprecated public static void isTrue(boolean expression){
  isTrue(expression,""[Assertion failed] - this expression must be true"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #isNull(Object,String)}
 */
@Deprecated public static void isNull(Object object){
  isNull(object,""[Assertion failed] - the object argument must be null"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notNull(Object,String)}
 */
@Deprecated public static void notNull(Object object){
  notNull(object,""[Assertion failed] - this argument is required; it must not be null"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #hasLength(String,String)}
 */
@Deprecated public static void hasLength(String text){
  hasLength(text,""[Assertion failed] - this String argument must have length; it must not be null or empty"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #hasText(String,String)}
 */
@Deprecated public static void hasText(String text){
  hasText(text,""[Assertion failed] - this String argument must have text; it must not be null, empty, or blank"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #doesNotContain(String,String,String)}
 */
@Deprecated public static void doesNotContain(String textToSearch,String substring){
  doesNotContain(textToSearch,substring,""[Assertion failed] - this String argument must not contain the substring ["" + substring + ""]"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Object[],String)}
 */
@Deprecated public static void notEmpty(Object[] array){
  notEmpty(array,""[Assertion failed] - this array must not be empty: it must contain at least 1 element"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #noNullElements(Object[],String)}
 */
@Deprecated public static void noNullElements(Object[] array){
  noNullElements(array,""[Assertion failed] - this array must not contain any null elements"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Collection,String)}
 */
@Deprecated public static void notEmpty(Collection<?> collection){
  notEmpty(collection,""[Assertion failed] - this collection must not be empty: it must contain at least 1 element"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Map,String)}
 */
@Deprecated public static void notEmpty(Map<?,?> map){
  notEmpty(map,""[Assertion failed] - this map must not be empty; it must contain at least one entry"");
}
"
"/** 
 * @deprecated as of 4.2.8, in favor of {@link #addPlaceholderValue(String,String)}
 */
@Deprecated public StandaloneMockMvcBuilder addPlaceHolderValue(String name,String value){
  this.placeholderValues.put(name,value);
  return this;
}
"
"/** 
 * @deprecated as 5.0, in favor of {@link MediaTypeFactory}, which has no JAF dependency.
 */
@Deprecated public void setUseJaf(boolean useJaf){
}
"
"/** 
 * @deprecated as 5.0, in favor of {@link MediaTypeFactory}, which has no JAF dependency.
 */
@Deprecated public void setUseJaf(boolean useJaf){
}
"
"/** 
 * @deprecated as 5.0, in favor of {@link MediaTypeFactory}, which has no JAF dependency.
 */
@Deprecated public void setUseJaf(boolean useJaf){
}
"
"/** 
 * @deprecated as 5.0, in favor of {@link MediaTypeFactory}, which has no JAF dependency.
 */
@Deprecated public void setUseJaf(boolean useJaf){
}
"
"/** 
 * @deprecated as 5.0, in favor of {@link MediaTypeFactory}, which has no JAF dependency.
 */
@Deprecated public ContentNegotiationConfigurer useJaf(boolean useJaf){
  return this;
}
"
"/** 
 * @deprecated as 5.0, in favor of {@link MediaTypeFactory}, which has no JAF dependency.
 */
@Deprecated public ContentNegotiationConfigurer useJaf(boolean useJaf){
  return this;
}
"
"/** 
 * @deprecated as 5.0, in favor of {@link MediaTypeFactory}, which has no JAF dependency.
 */
@Deprecated public void setUseJaf(boolean useJaf){
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #setUseRegisteredExtensionsOnly(boolean)}, which has reverse behavior.
 */
@Deprecated public void setUseJaf(boolean useJaf){
  setUseRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #setUseRegisteredExtensionsOnly(boolean)}.
 */
@Deprecated public void setUseJaf(boolean useJaf){
  setUseRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #useRegisteredExtensionsOnly(boolean)}, which has reverse behavior.
 */
@Deprecated public ContentNegotiationConfigurer useJaf(boolean useJaf){
  return this.useRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * Return the same value as  {@link Boolean#hashCode(boolean)}}.
 * @deprecated as of Spring Framework 5.0, in favor of the native JDK 8 variant
 */
@Deprecated public static int hashCode(boolean bool){
  return Boolean.hashCode(bool);
}
"
"/** 
 * Return the same value as  {@link Double#hashCode(double)}}.
 * @deprecated as of Spring Framework 5.0, in favor of the native JDK 8 variant
 */
@Deprecated public static int hashCode(double dbl){
  return Double.hashCode(dbl);
}
"
"/** 
 * Return the same value as  {@link Float#hashCode(float)}}.
 * @deprecated as of Spring Framework 5.0, in favor of the native JDK 8 variant
 */
@Deprecated public static int hashCode(float flt){
  return Float.hashCode(flt);
}
"
"/** 
 * Return the same value as  {@link Long#hashCode(long)}}.
 * @deprecated as of Spring Framework 5.0, in favor of the native JDK 8 variant
 */
@Deprecated public static int hashCode(long lng){
  return Long.hashCode(lng);
}
"
"/** 
 * Return the map with  {@code DeferredResult} adapters.<p>By default the map contains adapters for  {@code DeferredResult}, which simply downcasts,  {@link ListenableFuture}, and  {@link CompletionStage}.
 * @return the map of adapters
 * @deprecated in 4.3.8, see comments on {@link DeferredResultAdapter}
 */
@Deprecated public Map<Class<?>,DeferredResultAdapter> getAdapterMap(){
  return this.adapterMap;
}
"
"/** 
 * Return the map with  {@code ResponseBodyEmitter} adapters.By default the map contains a single adapter  {@code ResponseBodyEmitter}that simply downcasts the return value.
 * @return the map of adapters
 * @deprecated in 4.3.8, see comments on {@link ResponseBodyEmitterAdapter}
 */
@Deprecated public Map<Class<?>,ResponseBodyEmitterAdapter> getAdapterMap(){
  return this.adapterMap;
}
"
"/** 
 * This method only exists for compatibility with unusual Commons Logging API usage like e.g.  {@code LogFactory.getFactory().getInstance(Class/String)}.
 * @see #getInstance(Class)
 * @see #getInstance(String)
 * @deprecated in favor of {@link #getLog(Class)}/ {@link #getLog(String)}
 */
@Deprecated public static LogFactory getFactory(){
  return new LogFactory(){
  }
;
}
"
"/** 
 * Convenience method to return a named logger. <p>This variant just dispatches straight to  {@link #getLog(Class)}.
 * @param clazz containing Class from which a log name will be derived
 * @deprecated in favor of {@link #getLog(Class)}
 */
@Deprecated public Log getInstance(Class<?> clazz){
  return getLog(clazz);
}
"
"/** 
 * Convenience method to return a named logger. <p>This variant just dispatches straight to  {@link #getLog(String)}.
 * @param name logical name of the <code>Log</code> instance to be returned
 * @deprecated in favor of {@link #getLog(String)}
 */
@Deprecated public Log getInstance(String name){
  return getLog(name);
}
"
"/** 
 * This method only exists for compatibility with unusual Commons Logging API usage like e.g.  {@code LogFactory.getFactory().getInstance(Class/String)}.
 * @see #getInstance(Class)
 * @see #getInstance(String)
 * @deprecated in favor of {@link #getLog(Class)}/ {@link #getLog(String)}
 */
@Deprecated public static LogFactory getFactory(){
  return new LogFactory(){
  }
;
}
"
"/** 
 * Convenience method to return a named logger. <p>This variant just dispatches straight to  {@link #getLog(Class)}.
 * @param clazz containing Class from which a log name will be derived
 * @deprecated in favor of {@link #getLog(Class)}
 */
@Deprecated public Log getInstance(Class<?> clazz){
  return getLog(clazz);
}
"
"/** 
 * Convenience method to return a named logger. <p>This variant just dispatches straight to  {@link #getLog(String)}.
 * @param name logical name of the <code>Log</code> instance to be returned
 * @deprecated in favor of {@link #getLog(String)}
 */
@Deprecated public Log getInstance(String name){
  return getLog(name);
}
"
"/** 
 * This method only exists for compatibility with unusual Commons Logging API usage like e.g.  {@code LogFactory.getFactory().getInstance(Class/String)}.
 * @see #getInstance(Class)
 * @see #getInstance(String)
 * @deprecated in favor of {@link #getLog(Class)}/ {@link #getLog(String)}
 */
@Deprecated public static LogFactory getFactory(){
  return new LogFactory(){
  }
;
}
"
"/** 
 * Convenience method to return a named logger. <p>This variant just dispatches straight to  {@link #getLog(Class)}.
 * @param clazz containing Class from which a log name will be derived
 * @deprecated in favor of {@link #getLog(Class)}
 */
@Deprecated public Log getInstance(Class<?> clazz){
  return getLog(clazz);
}
"
"/** 
 * Convenience method to return a named logger. <p>This variant just dispatches straight to  {@link #getLog(String)}.
 * @param name logical name of the <code>Log</code> instance to be returned
 * @deprecated in favor of {@link #getLog(String)}
 */
@Deprecated public Log getInstance(String name){
  return getLog(name);
}
"
"/** 
 * This method only exists for compatibility with unusual Commons Logging API usage like e.g.  {@code LogFactory.getFactory().getInstance(Class/String)}.
 * @see #getInstance(Class)
 * @see #getInstance(String)
 * @deprecated in favor of {@link #getLog(Class)}/ {@link #getLog(String)}
 */
@Deprecated public static LogFactory getFactory(){
  return new LogFactory(){
  }
;
}
"
"/** 
 * Convenience method to return a named logger. <p>This variant just dispatches straight to  {@link #getLog(Class)}.
 * @param clazz containing Class from which a log name will be derived
 * @deprecated in favor of {@link #getLog(Class)}
 */
@Deprecated public Log getInstance(Class<?> clazz){
  return getLog(clazz);
}
"
"/** 
 * Convenience method to return a named logger. <p>This variant just dispatches straight to  {@link #getLog(String)}.
 * @param name logical name of the <code>Log</code> instance to be returned
 * @deprecated in favor of {@link #getLog(String)}
 */
@Deprecated public Log getInstance(String name){
  return getLog(name);
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #setUseRegisteredExtensionsOnly(boolean)}, which has reverse behavior.
 */
@Deprecated public void setUseJaf(boolean useJaf){
  setUseRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #useRegisteredExtensionsOnly(boolean)}, which has reverse behavior.
 */
@Deprecated public ContentNegotiationConfigurer useJaf(boolean useJaf){
  return this.useRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #setUseRegisteredExtensionsOnly(boolean)}, which has reverse behavior.
 */
@Deprecated public void setUseJaf(boolean useJaf){
  setUseRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #useRegisteredExtensionsOnly(boolean)}, which has reverse behavior.
 */
@Deprecated public ContentNegotiationConfigurer useJaf(boolean useJaf){
  return this.useRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #setUseRegisteredExtensionsOnly(boolean)}, which has reverse behavior.
 */
@Deprecated public void setUseJaf(boolean useJaf){
  setUseRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #useRegisteredExtensionsOnly(boolean)}, which has reverse behavior.
 */
@Deprecated public ContentNegotiationConfigurer useJaf(boolean useJaf){
  return this.useRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * Deprecated constructor with a TaskScheduler.
 * @deprecated as of 5.0 a TaskScheduler is not provided upfront, not untilit is obvious that it is needed, see  {@link #getSockJsServiceRegistration()}.
 */
@Deprecated public AbstractWebSocketHandlerRegistration(TaskScheduler defaultTaskScheduler){
  this.scheduler=defaultTaskScheduler;
}
"
"/** 
 * Deprecated constructor with a TaskScheduler for SockJS use.
 * @deprecated as of 5.0 a TaskScheduler is not provided upfront, not untilit is obvious that it is needed, see  {@link #getSockJsServiceRegistration()}.
 */
@Deprecated @SuppressWarnings(""deprecated"") public ServletWebSocketHandlerRegistration(TaskScheduler scheduler){
  super(scheduler);
}
"
"/** 
 * Deprecated constructor with a TaskScheduler for SockJS use.
 * @deprecated as of 5.0 a TaskScheduler is not provided upfront, not untilit is obvious that it is needed, see  {@link #requiresTaskScheduler()} and{@link #setTaskScheduler}.
 */
@Deprecated public ServletWebSocketHandlerRegistry(ThreadPoolTaskScheduler scheduler){
  this.scheduler=scheduler;
}
"
"/** 
 * Deprecated constructor with a TaskScheduler.
 * @deprecated as of 5.0 a TaskScheduler is not provided upfront, not untilit is obvious that it is needed; call  {@link #getTaskScheduler()} to checkand then  {@link #setTaskScheduler(TaskScheduler)} to set it before a callto  {@link #createSockJsService()}
 */
@Deprecated public SockJsServiceRegistration(TaskScheduler defaultTaskScheduler){
  this.scheduler=defaultTaskScheduler;
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}. <p>This method follows <em>find semantics</em> as described in the {@linkplain AnnotatedElementUtils class-level javadoc}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Determine the target type for the given parameter specification.
 * @param methodParameter the method parameter specification
 * @return the corresponding generic parameter type
 * @deprecated as of Spring 4.0, use {@link MethodParameter#getGenericParameterType()}
 */
@Deprecated public static Type getTargetType(MethodParameter methodParameter){
  Assert.notNull(methodParameter,""MethodParameter must not be null"");
  return methodParameter.getGenericParameterType();
}
"
"/** 
 * Determine the target type for the generic return type of the given <em>generic method</em>, where formal type variables are declared on the given method itself. <p>For example, given a factory method with the following signature, if  {@code resolveReturnTypeForGenericMethod()} is invoked with the reflectedmethod for  {@code creatProxy()} and an {@code Object[]} array containing{@code MyService.class},  {@code resolveReturnTypeForGenericMethod()} willinfer that the target return type is  {@code MyService}. <pre class=""code""> {@code public static <T> T createProxy(Class<T> clazz)}</pre> <h4>Possible Return Values</h4> <ul> <li>the target return type, if it can be inferred</li> <li>the  {@linkplain Method#getReturnType() standard return type}, if the given  {@code method} does not declare any {@linkplain Method#getTypeParameters() formal type variables}</li> <li>the  {@linkplain Method#getReturnType() standard return type}, if the target return type cannot be inferred (e.g., due to type erasure)</li> <li> {@code null}, if the length of the given arguments array is shorter than the length of the  {@linkplain Method#getGenericParameterTypes() formal argument list} for the givenmethod</li> </ul>
 * @param method the method to introspect, never {@code null}
 * @param args the arguments that will be supplied to the method when it isinvoked (never  {@code null})
 * @param classLoader the ClassLoader to resolve class names against, if necessary(may be  {@code null})
 * @return the resolved target return type, the standard return type, or {@code null}
 * @since 3.2.5
 * @deprecated as of Spring Framework 4.3.8, superseded by {@link ResolvableType} usage
 */
@Deprecated public static Class<?> resolveReturnTypeForGenericMethod(Method method,Object[] args,ClassLoader classLoader){
  Assert.notNull(method,""Method must not be null"");
  Assert.notNull(args,""Argument array must not be null"");
  TypeVariable<Method>[] declaredTypeVariables=method.getTypeParameters();
  Type genericReturnType=method.getGenericReturnType();
  Type[] methodArgumentTypes=method.getGenericParameterTypes();
  if (declaredTypeVariables.length == 0) {
    return method.getReturnType();
  }
  if (args.length < methodArgumentTypes.length) {
    return null;
  }
  boolean locallyDeclaredTypeVariableMatchesReturnType=false;
  for (  TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {
    if (currentTypeVariable.equals(genericReturnType)) {
      locallyDeclaredTypeVariableMatchesReturnType=true;
      break;
    }
  }
  if (locallyDeclaredTypeVariableMatchesReturnType) {
    for (int i=0; i < methodArgumentTypes.length; i++) {
      Type currentMethodArgumentType=methodArgumentTypes[i];
      if (currentMethodArgumentType.equals(genericReturnType)) {
        return args[i].getClass();
      }
      if (currentMethodArgumentType instanceof ParameterizedType) {
        ParameterizedType parameterizedType=(ParameterizedType)currentMethodArgumentType;
        Type[] actualTypeArguments=parameterizedType.getActualTypeArguments();
        for (        Type typeArg : actualTypeArguments) {
          if (typeArg.equals(genericReturnType)) {
            Object arg=args[i];
            if (arg instanceof Class) {
              return (Class<?>)arg;
            }
 else             if (arg instanceof String && classLoader != null) {
              try {
                return classLoader.loadClass((String)arg);
              }
 catch (              ClassNotFoundException ex) {
                throw new IllegalStateException(""Could not resolve specific class name argument ["" + arg + ""]"",ex);
              }
            }
 else {
              return method.getReturnType();
            }
          }
        }
      }
    }
  }
  return method.getReturnType();
}
"
"/** 
 * This method only exists for compatibility with unusual Commons Logging API usage like e.g.  {@code LogFactory.getFactory().getInstance(Class/String)}.
 * @see #getInstance(Class)
 * @see #getInstance(String)
 * @deprecated in favor of {@link #getLog(Class)}/ {@link #getLog(String)}
 */
@Deprecated public static LogFactory getFactory(){
  return new LogFactory(){
  }
;
}
"
"/** 
 * Convenience method to return a named logger. <p>This variant just dispatches straight to  {@link #getLog(Class)}.
 * @param clazz containing Class from which a log name will be derived
 * @deprecated in favor of {@link #getLog(Class)}
 */
@Deprecated public Log getInstance(Class<?> clazz){
  return getLog(clazz);
}
"
"/** 
 * Convenience method to return a named logger. <p>This variant just dispatches straight to  {@link #getLog(String)}.
 * @param name logical name of the <code>Log</code> instance to be returned
 * @deprecated in favor of {@link #getLog(String)}
 */
@Deprecated public Log getInstance(String name){
  return getLog(name);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.MOVED_TEMPORARILY} (302).
 * @see #isFound()
 * @deprecated in favor of {@link #isFound()}
 */
@Deprecated public ResultMatcher isMovedTemporarily(){
  return matcher(HttpStatus.MOVED_TEMPORARILY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.USE_PROXY} (305).
 * @deprecated matching the deprecation of {@code HttpStatus.USE_PROXY}
 */
@Deprecated public ResultMatcher isUseProxy(){
  return matcher(HttpStatus.USE_PROXY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE} (413).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE}
 * @see #isPayloadTooLarge()
 */
@Deprecated public ResultMatcher isRequestEntityTooLarge(){
  return matcher(HttpStatus.REQUEST_ENTITY_TOO_LARGE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_URI_TOO_LONG} (414).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_URI_TOO_LONG}
 * @see #isUriTooLong()
 */
@Deprecated public ResultMatcher isRequestUriTooLong(){
  return matcher(HttpStatus.REQUEST_URI_TOO_LONG);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE}
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of {@code HttpStatus.METHOD_FAILURE}
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of {@code HttpStatus.DESTINATION_LOCKED}
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * This method only exists for compatibility with unusual Commons Logging API usage like e.g.  {@code LogFactory.getFactory().getInstance(Class/String)}.
 * @see #getInstance(Class)
 * @see #getInstance(String)
 * @deprecated in favor of {@link #getLog(Class)}/ {@link #getLog(String)}
 */
@Deprecated public static LogFactory getFactory(){
  return new LogFactory(){
  }
;
}
"
"/** 
 * Convenience method to return a named logger. <p>This variant just dispatches straight to  {@link #getLog(Class)}.
 * @param clazz containing Class from which a log name will be derived
 * @deprecated in favor of {@link #getLog(Class)}
 */
@Deprecated public Log getInstance(Class<?> clazz){
  return getLog(clazz);
}
"
"/** 
 * Convenience method to return a named logger. <p>This variant just dispatches straight to  {@link #getLog(String)}.
 * @param name logical name of the <code>Log</code> instance to be returned
 * @deprecated in favor of {@link #getLog(String)}
 */
@Deprecated public Log getInstance(String name){
  return getLog(name);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.MOVED_TEMPORARILY} (302).
 * @see #isFound()
 * @deprecated in favor of {@link #isFound()}
 */
@Deprecated public ResultMatcher isMovedTemporarily(){
  return matcher(HttpStatus.MOVED_TEMPORARILY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.USE_PROXY} (305).
 * @deprecated matching the deprecation of {@code HttpStatus.USE_PROXY}
 */
@Deprecated public ResultMatcher isUseProxy(){
  return matcher(HttpStatus.USE_PROXY);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE} (413).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_ENTITY_TOO_LARGE}
 * @see #isPayloadTooLarge()
 */
@Deprecated public ResultMatcher isRequestEntityTooLarge(){
  return matcher(HttpStatus.REQUEST_ENTITY_TOO_LARGE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.REQUEST_URI_TOO_LONG} (414).
 * @deprecated matching the deprecation of {@code HttpStatus.REQUEST_URI_TOO_LONG}
 * @see #isUriTooLong()
 */
@Deprecated public ResultMatcher isRequestUriTooLong(){
  return matcher(HttpStatus.REQUEST_URI_TOO_LONG);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE} (419).
 * @deprecated matching the deprecation of {@code HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE}
 */
@Deprecated public ResultMatcher isInsufficientSpaceOnResource(){
  return matcher(HttpStatus.INSUFFICIENT_SPACE_ON_RESOURCE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.METHOD_FAILURE} (420).
 * @deprecated matching the deprecation of {@code HttpStatus.METHOD_FAILURE}
 */
@Deprecated public ResultMatcher isMethodFailure(){
  return matcher(HttpStatus.METHOD_FAILURE);
}
"
"/** 
 * Assert the response status code is  {@code HttpStatus.DESTINATION_LOCKED} (421).
 * @deprecated matching the deprecation of {@code HttpStatus.DESTINATION_LOCKED}
 */
@Deprecated public ResultMatcher isDestinationLocked(){
  return matcher(HttpStatus.DESTINATION_LOCKED);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(Method method,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(method,annotationType,containerAnnotationType);
}
"
"/** 
 * Delegates to  {@link #getRepeatableAnnotations(AnnotatedElement,Class,Class)}.
 * @since 4.0
 * @see #getRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement,Class,Class)
 * @deprecated As of Spring Framework 4.2, use {@code getRepeatableAnnotations()}or  {@code getDeclaredRepeatableAnnotations()} instead.
 */
@Deprecated public static <A extends Annotation>Set<A> getRepeatableAnnotation(AnnotatedElement annotatedElement,Class<? extends Annotation> containerAnnotationType,Class<A> annotationType){
  return getRepeatableAnnotations(annotatedElement,annotationType,containerAnnotationType);
}
"
"/** 
 * Convenience method to instantiate a class using its no-arg constructor.
 * @param clazz class to instantiate
 * @return the new instance
 * @throws BeanInstantiationException if the bean cannot be instantiated
 * @deprecated as of Spring 5.0, following the deprecation of{@link Class#newInstance()} in JDK 9
 * @see Class#newInstance()
 */
@Deprecated public static <T>T instantiate(Class<T> clazz) throws BeanInstantiationException {
  Assert.notNull(clazz,""Class must not be null"");
  if (clazz.isInterface()) {
    throw new BeanInstantiationException(clazz,""Specified class is an interface"");
  }
  try {
    return clazz.newInstance();
  }
 catch (  InstantiationException ex) {
    throw new BeanInstantiationException(clazz,""Is it an abstract class?"",ex);
  }
catch (  IllegalAccessException ex) {
    throw new BeanInstantiationException(clazz,""Is the constructor accessible?"",ex);
  }
}
"
"/** 
 * Convenience method to instantiate a class using its no-arg constructor.
 * @param clazz class to instantiate
 * @return the new instance
 * @throws BeanInstantiationException if the bean cannot be instantiated
 * @deprecated as of Spring 5.0, following the deprecation of{@link Class#newInstance()} in JDK 9
 * @see Class#newInstance()
 */
@Deprecated public static <T>T instantiate(Class<T> clazz) throws BeanInstantiationException {
  Assert.notNull(clazz,""Class must not be null"");
  if (clazz.isInterface()) {
    throw new BeanInstantiationException(clazz,""Specified class is an interface"");
  }
  try {
    return clazz.newInstance();
  }
 catch (  InstantiationException ex) {
    throw new BeanInstantiationException(clazz,""Is it an abstract class?"",ex);
  }
catch (  IllegalAccessException ex) {
    throw new BeanInstantiationException(clazz,""Is the constructor accessible?"",ex);
  }
}
"
"/** 
 * @see #fromMethod(Class,Method,Object)
 * @see #fromMethod(UriComponentsBuilder,Class,Method,Object)
 * @deprecated as of 4.2, this is deprecated in favor of the overloadedmethod that also accepts a controllerType argument
 */
@Deprecated public static UriComponentsBuilder fromMethod(Method method,Object... args){
  return fromMethodInternal(null,method.getDeclaringClass(),method,args);
}
"
"/** 
 * @deprecated as of 4.2, this is deprecated in favor of alternative constructorsthat accept a controllerType argument
 */
@Deprecated public MethodArgumentBuilder(Method method){
  this(method.getDeclaringClass(),method);
}
"
"/** 
 * Create a new MethodParameter for the given method or constructor. <p>This is a convenience factory method for scenarios where a Method or Constructor reference is treated in a generic fashion.
 * @param methodOrConstructor the Method or Constructor to specify a parameter for
 * @param parameterIndex the index of the parameter
 * @return the corresponding MethodParameter instance
 * @deprecated as of 5.0, in favor of {@link #forExecutable}
 */
@Deprecated public static MethodParameter forMethodOrConstructor(Object methodOrConstructor,int parameterIndex){
  if (!(methodOrConstructor instanceof Executable)) {
    throw new IllegalArgumentException(""Given object ["" + methodOrConstructor + ""] is neither a Method nor a Constructor"");
  }
  return forExecutable((Executable)methodOrConstructor,parameterIndex);
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #state(boolean,String)}
 */
@Deprecated public static void state(boolean expression){
  state(expression,""[Assertion failed] - this state invariant must be true"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #isTrue(boolean,String)}
 */
@Deprecated public static void isTrue(boolean expression){
  isTrue(expression,""[Assertion failed] - this expression must be true"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #isNull(Object,String)}
 */
@Deprecated public static void isNull(@Nullable Object object){
  isNull(object,""[Assertion failed] - the object argument must be null"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notNull(Object,String)}
 */
@Deprecated public static void notNull(@Nullable Object object){
  notNull(object,""[Assertion failed] - this argument is required; it must not be null"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #hasLength(String,String)}
 */
@Deprecated public static void hasLength(@Nullable String text){
  hasLength(text,""[Assertion failed] - this String argument must have length; it must not be null or empty"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #hasText(String,String)}
 */
@Deprecated public static void hasText(@Nullable String text){
  hasText(text,""[Assertion failed] - this String argument must have text; it must not be null, empty, or blank"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #doesNotContain(String,String,String)}
 */
@Deprecated public static void doesNotContain(@Nullable String textToSearch,String substring){
  doesNotContain(textToSearch,substring,() -> ""[Assertion failed] - this String argument must not contain the substring ["" + substring + ""]"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Object[],String)}
 */
@Deprecated public static void notEmpty(@Nullable Object[] array){
  notEmpty(array,""[Assertion failed] - this array must not be empty: it must contain at least 1 element"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #noNullElements(Object[],String)}
 */
@Deprecated public static void noNullElements(@Nullable Object[] array){
  noNullElements(array,""[Assertion failed] - this array must not contain any null elements"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Collection,String)}
 */
@Deprecated public static void notEmpty(@Nullable Collection<?> collection){
  notEmpty(collection,""[Assertion failed] - this collection must not be empty: it must contain at least 1 element"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Map,String)}
 */
@Deprecated public static void notEmpty(@Nullable Map<?,?> map){
  notEmpty(map,""[Assertion failed] - this map must not be empty; it must contain at least one entry"");
}
"
"/** 
 * Return the same value as  {@link Boolean#hashCode(boolean)}}.
 * @deprecated as of Spring Framework 5.0, in favor of the native JDK 8 variant
 */
@Deprecated public static int hashCode(boolean bool){
  return Boolean.hashCode(bool);
}
"
"/** 
 * Return the same value as  {@link Double#hashCode(double)}}.
 * @deprecated as of Spring Framework 5.0, in favor of the native JDK 8 variant
 */
@Deprecated public static int hashCode(double dbl){
  return Double.hashCode(dbl);
}
"
"/** 
 * Return the same value as  {@link Float#hashCode(float)}}.
 * @deprecated as of Spring Framework 5.0, in favor of the native JDK 8 variant
 */
@Deprecated public static int hashCode(float flt){
  return Float.hashCode(flt);
}
"
"/** 
 * Return the same value as  {@link Long#hashCode(long)}}.
 * @deprecated as of Spring Framework 5.0, in favor of the native JDK 8 variant
 */
@Deprecated public static int hashCode(long lng){
  return Long.hashCode(lng);
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #setUseRegisteredExtensionsOnly(boolean)}.
 */
@Deprecated public void setUseJaf(boolean useJaf){
  setUseRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * Convenience method to instantiate a class using its no-arg constructor.
 * @param clazz class to instantiate
 * @return the new instance
 * @throws BeanInstantiationException if the bean cannot be instantiated
 * @deprecated as of Spring 5.0, following the deprecation of{@link Class#newInstance()} in JDK 9
 * @see Class#newInstance()
 */
@Deprecated public static <T>T instantiate(Class<T> clazz) throws BeanInstantiationException {
  Assert.notNull(clazz,""Class must not be null"");
  if (clazz.isInterface()) {
    throw new BeanInstantiationException(clazz,""Specified class is an interface"");
  }
  try {
    return clazz.newInstance();
  }
 catch (  InstantiationException ex) {
    throw new BeanInstantiationException(clazz,""Is it an abstract class?"",ex);
  }
catch (  IllegalAccessException ex) {
    throw new BeanInstantiationException(clazz,""Is the constructor accessible?"",ex);
  }
}
"
"/** 
 * Deprecated constructor with a TaskScheduler.
 * @deprecated as of 5.0 a TaskScheduler is not provided upfront, not untilit is obvious that it is needed, see  {@link #getSockJsServiceRegistration()}.
 */
@Deprecated public AbstractWebSocketHandlerRegistration(TaskScheduler defaultTaskScheduler){
  this.scheduler=defaultTaskScheduler;
}
"
"/** 
 * Create a new MethodParameter for the given method or constructor. <p>This is a convenience factory method for scenarios where a Method or Constructor reference is treated in a generic fashion.
 * @param methodOrConstructor the Method or Constructor to specify a parameter for
 * @param parameterIndex the index of the parameter
 * @return the corresponding MethodParameter instance
 * @deprecated as of 5.0, in favor of {@link #forExecutable}
 */
@Deprecated public static MethodParameter forMethodOrConstructor(Object methodOrConstructor,int parameterIndex){
  if (!(methodOrConstructor instanceof Executable)) {
    throw new IllegalArgumentException(""Given object ["" + methodOrConstructor + ""] is neither a Method nor a Constructor"");
  }
  return forExecutable((Executable)methodOrConstructor,parameterIndex);
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #state(boolean,String)}
 */
@Deprecated public static void state(boolean expression){
  state(expression,""[Assertion failed] - this state invariant must be true"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #isTrue(boolean,String)}
 */
@Deprecated public static void isTrue(boolean expression){
  isTrue(expression,""[Assertion failed] - this expression must be true"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #isNull(Object,String)}
 */
@Deprecated public static void isNull(@Nullable Object object){
  isNull(object,""[Assertion failed] - the object argument must be null"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notNull(Object,String)}
 */
@Deprecated public static void notNull(@Nullable Object object){
  notNull(object,""[Assertion failed] - this argument is required; it must not be null"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #hasLength(String,String)}
 */
@Deprecated public static void hasLength(@Nullable String text){
  hasLength(text,""[Assertion failed] - this String argument must have length; it must not be null or empty"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #hasText(String,String)}
 */
@Deprecated public static void hasText(@Nullable String text){
  hasText(text,""[Assertion failed] - this String argument must have text; it must not be null, empty, or blank"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #doesNotContain(String,String,String)}
 */
@Deprecated public static void doesNotContain(@Nullable String textToSearch,String substring){
  doesNotContain(textToSearch,substring,() -> ""[Assertion failed] - this String argument must not contain the substring ["" + substring + ""]"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Object[],String)}
 */
@Deprecated public static void notEmpty(@Nullable Object[] array){
  notEmpty(array,""[Assertion failed] - this array must not be empty: it must contain at least 1 element"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #noNullElements(Object[],String)}
 */
@Deprecated public static void noNullElements(@Nullable Object[] array){
  noNullElements(array,""[Assertion failed] - this array must not contain any null elements"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Collection,String)}
 */
@Deprecated public static void notEmpty(@Nullable Collection<?> collection){
  notEmpty(collection,""[Assertion failed] - this collection must not be empty: it must contain at least 1 element"");
}
"
"/** 
 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Map,String)}
 */
@Deprecated public static void notEmpty(@Nullable Map<?,?> map){
  notEmpty(map,""[Assertion failed] - this map must not be empty; it must contain at least one entry"");
}
"
"/** 
 * Return the same value as  {@link Boolean#hashCode(boolean)}}.
 * @deprecated as of Spring Framework 5.0, in favor of the native JDK 8 variant
 */
@Deprecated public static int hashCode(boolean bool){
  return Boolean.hashCode(bool);
}
"
"/** 
 * Return the same value as  {@link Double#hashCode(double)}}.
 * @deprecated as of Spring Framework 5.0, in favor of the native JDK 8 variant
 */
@Deprecated public static int hashCode(double dbl){
  return Double.hashCode(dbl);
}
"
"/** 
 * Return the same value as  {@link Float#hashCode(float)}}.
 * @deprecated as of Spring Framework 5.0, in favor of the native JDK 8 variant
 */
@Deprecated public static int hashCode(float flt){
  return Float.hashCode(flt);
}
"
"/** 
 * Return the same value as  {@link Long#hashCode(long)}}.
 * @deprecated as of Spring Framework 5.0, in favor of the native JDK 8 variant
 */
@Deprecated public static int hashCode(long lng){
  return Long.hashCode(lng);
}
"
"/** 
 * Set the  {@code CloseableHttpAsyncClient} used for{@linkplain #createAsyncRequest(URI,HttpMethod) asynchronous execution}.
 * @deprecated as of 4.3.10, in favor of {@link #setAsyncClient(HttpAsyncClient)}
 */
@Deprecated public void setHttpAsyncClient(CloseableHttpAsyncClient asyncClient){
  this.asyncClient=asyncClient;
}
"
"/** 
 * Return the  {@code CloseableHttpAsyncClient} used for{@linkplain #createAsyncRequest(URI,HttpMethod) asynchronous execution}.
 * @deprecated as of 4.3.10, in favor of {@link #getAsyncClient()}
 */
@Deprecated public CloseableHttpAsyncClient getHttpAsyncClient(){
  Assert.state(this.asyncClient == null || this.asyncClient instanceof CloseableHttpAsyncClient,""No CloseableHttpAsyncClient - use getAsyncClient() instead"");
  return (CloseableHttpAsyncClient)this.asyncClient;
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #setUseRegisteredExtensionsOnly(boolean)}, which has reverse behavior.
 */
@Deprecated public void setUseJaf(boolean useJaf){
  setUseRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #setUseRegisteredExtensionsOnly(boolean)}.
 */
@Deprecated public void setUseJaf(boolean useJaf){
  setUseRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #useRegisteredExtensionsOnly(boolean)}, which has reverse behavior.
 */
@Deprecated public ContentNegotiationConfigurer useJaf(boolean useJaf){
  return this.useRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * Deprecated constructor with a TaskScheduler.
 * @deprecated as of 5.0 a TaskScheduler is not provided upfront, not untilit is obvious that it is needed; call  {@link #getTaskScheduler()} to checkand then  {@link #setTaskScheduler(TaskScheduler)} to set it before a callto  {@link #createSockJsService()}
 */
@Deprecated public SockJsServiceRegistration(TaskScheduler defaultTaskScheduler){
  this.scheduler=defaultTaskScheduler;
}
"
"/** 
 * Set the  {@code CloseableHttpAsyncClient} used for{@linkplain #createAsyncRequest(URI,HttpMethod) asynchronous execution}.
 * @deprecated as of 4.3.10, in favor of {@link #setAsyncClient(HttpAsyncClient)}
 */
@Deprecated public void setHttpAsyncClient(CloseableHttpAsyncClient asyncClient){
  this.asyncClient=asyncClient;
}
"
"/** 
 * Return the  {@code CloseableHttpAsyncClient} used for{@linkplain #createAsyncRequest(URI,HttpMethod) asynchronous execution}.
 * @deprecated as of 4.3.10, in favor of {@link #getAsyncClient()}
 */
@Deprecated public CloseableHttpAsyncClient getHttpAsyncClient(){
  Assert.state(this.asyncClient == null || this.asyncClient instanceof CloseableHttpAsyncClient,""No CloseableHttpAsyncClient - use getAsyncClient() instead"");
  return (CloseableHttpAsyncClient)this.asyncClient;
}
"
"/** 
 * Convenience method to instantiate a class using its no-arg constructor.
 * @param clazz class to instantiate
 * @return the new instance
 * @throws BeanInstantiationException if the bean cannot be instantiated
 * @deprecated as of Spring 5.0, following the deprecation of{@link Class#newInstance()} in JDK 9
 * @see Class#newInstance()
 */
@Deprecated public static <T>T instantiate(Class<T> clazz) throws BeanInstantiationException {
  Assert.notNull(clazz,""Class must not be null"");
  if (clazz.isInterface()) {
    throw new BeanInstantiationException(clazz,""Specified class is an interface"");
  }
  try {
    return clazz.newInstance();
  }
 catch (  InstantiationException ex) {
    throw new BeanInstantiationException(clazz,""Is it an abstract class?"",ex);
  }
catch (  IllegalAccessException ex) {
    throw new BeanInstantiationException(clazz,""Is the constructor accessible?"",ex);
  }
}
"
"/** 
 * Create a new MethodParameter for the given method or constructor. <p>This is a convenience factory method for scenarios where a Method or Constructor reference is treated in a generic fashion.
 * @param methodOrConstructor the Method or Constructor to specify a parameter for
 * @param parameterIndex the index of the parameter
 * @return the corresponding MethodParameter instance
 * @deprecated as of 5.0, in favor of {@link #forExecutable}
 */
@Deprecated public static MethodParameter forMethodOrConstructor(Object methodOrConstructor,int parameterIndex){
  if (!(methodOrConstructor instanceof Executable)) {
    throw new IllegalArgumentException(""Given object ["" + methodOrConstructor + ""] is neither a Method nor a Constructor"");
  }
  return forExecutable((Executable)methodOrConstructor,parameterIndex);
}
"
"/** 
 * Return a builder for a  {@code MockRestServiceServer} that should be usedto reply to the given  {@code AsyncRestTemplate}.
 * @since 4.3
 * @deprecated see deprecation notice on{@link org.springframework.web.client.AsyncRestTemplate} itself
 */
@Deprecated public static MockRestServiceServerBuilder bindTo(org.springframework.web.client.AsyncRestTemplate asyncRestTemplate){
  return new DefaultBuilder(asyncRestTemplate);
}
"
"/** 
 * A shortcut for  {@code bindTo(asyncRestTemplate).build()}.
 * @param asyncRestTemplate the AsyncRestTemplate to set up for mock testing
 * @return the created mock server
 * @deprecated see deprecation notice on{@link org.springframework.web.client.AsyncRestTemplate} itself
 */
@Deprecated public static MockRestServiceServer createServer(org.springframework.web.client.AsyncRestTemplate asyncRestTemplate){
  return bindTo(asyncRestTemplate).build();
}
"
"/** 
 * Callback for destruction of this instance, originally attached to a  {@code DisposableBean} implementation (not anymore in 5.0).<p>The  {@link #close()} method is the native way to shut downan ApplicationContext, which this method simply delegates to.
 * @deprecated as of Spring Framework 5.0, in favor of {@link #close()}
 */
@Deprecated public void destroy(){
  close();
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #setUseRegisteredExtensionsOnly(boolean)}, which has reverse behavior.
 */
@Deprecated public void setUseJaf(boolean useJaf){
  setUseRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #setUseRegisteredExtensionsOnly(boolean)}.
 */
@Deprecated public void setUseJaf(boolean useJaf){
  setUseRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #setUseRegisteredExtensionsOnly(boolean)}, which has reverse behavior.
 */
@Deprecated public void setUseJaf(boolean useJaf){
  setUseRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #useRegisteredExtensionsOnly(boolean)}, which has reverse behavior.
 */
@Deprecated public ContentNegotiationConfigurer useJaf(boolean useJaf){
  return this.useRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * Set the  {@code CloseableHttpAsyncClient} used for{@linkplain #createAsyncRequest(URI,HttpMethod) asynchronous execution}.
 * @deprecated as of 4.3.10, in favor of {@link #setAsyncClient(HttpAsyncClient)}
 */
@Deprecated public void setHttpAsyncClient(CloseableHttpAsyncClient asyncClient){
  this.asyncClient=asyncClient;
}
"
"/** 
 * Return the  {@code CloseableHttpAsyncClient} used for{@linkplain #createAsyncRequest(URI,HttpMethod) asynchronous execution}.
 * @deprecated as of 4.3.10, in favor of {@link #getAsyncClient()}
 */
@Deprecated public CloseableHttpAsyncClient getHttpAsyncClient(){
  Assert.state(this.asyncClient == null || this.asyncClient instanceof CloseableHttpAsyncClient,""No CloseableHttpAsyncClient - use getAsyncClient() instead"");
  return (CloseableHttpAsyncClient)this.asyncClient;
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #setUseRegisteredExtensionsOnly(boolean)}, which has reverse behavior.
 */
@Deprecated public void setUseJaf(boolean useJaf){
  setUseRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #useRegisteredExtensionsOnly(boolean)}, which has reverse behavior.
 */
@Deprecated public ContentNegotiationConfigurer useJaf(boolean useJaf){
  return this.useRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * Deprecated constructor with a TaskScheduler.
 * @deprecated as of 5.0 a TaskScheduler is not provided upfront, not untilit is obvious that it is needed, see  {@link #getSockJsServiceRegistration()}.
 */
@Deprecated public AbstractWebSocketHandlerRegistration(TaskScheduler defaultTaskScheduler){
  this.scheduler=defaultTaskScheduler;
}
"
"/** 
 * Deprecated constructor with a TaskScheduler for SockJS use.
 * @deprecated as of 5.0 a TaskScheduler is not provided upfront, not untilit is obvious that it is needed, see  {@link #requiresTaskScheduler()} and{@link #setTaskScheduler}.
 */
@Deprecated public ServletWebSocketHandlerRegistry(ThreadPoolTaskScheduler scheduler){
  this.scheduler=scheduler;
}
"
"/** 
 * Deprecated constructor with a TaskScheduler.
 * @deprecated as of 5.0 a TaskScheduler is not provided upfront, not untilit is obvious that it is needed; call  {@link #getTaskScheduler()} to checkand then  {@link #setTaskScheduler(TaskScheduler)} to set it before a callto  {@link #createSockJsService()}
 */
@Deprecated public SockJsServiceRegistration(TaskScheduler defaultTaskScheduler){
  this.scheduler=defaultTaskScheduler;
}
"
"/** 
 * Set the  {@code CloseableHttpAsyncClient} used for{@linkplain #createAsyncRequest(URI,HttpMethod) asynchronous execution}.
 * @deprecated as of 4.3.10, in favor of {@link #setAsyncClient(HttpAsyncClient)}
 */
@Deprecated public void setHttpAsyncClient(CloseableHttpAsyncClient asyncClient){
  this.asyncClient=asyncClient;
}
"
"/** 
 * Return the  {@code CloseableHttpAsyncClient} used for{@linkplain #createAsyncRequest(URI,HttpMethod) asynchronous execution}.
 * @deprecated as of 4.3.10, in favor of {@link #getAsyncClient()}
 */
@Deprecated public CloseableHttpAsyncClient getHttpAsyncClient(){
  Assert.state(this.asyncClient instanceof CloseableHttpAsyncClient,""No CloseableHttpAsyncClient - use getAsyncClient() instead"");
  return (CloseableHttpAsyncClient)this.asyncClient;
}
"
"/** 
 * Convenience method to instantiate a class using its no-arg constructor.
 * @param clazz class to instantiate
 * @return the new instance
 * @throws BeanInstantiationException if the bean cannot be instantiated
 * @deprecated as of Spring 5.0, following the deprecation of{@link Class#newInstance()} in JDK 9
 * @see Class#newInstance()
 */
@Deprecated public static <T>T instantiate(Class<T> clazz) throws BeanInstantiationException {
  Assert.notNull(clazz,""Class must not be null"");
  if (clazz.isInterface()) {
    throw new BeanInstantiationException(clazz,""Specified class is an interface"");
  }
  try {
    return clazz.newInstance();
  }
 catch (  InstantiationException ex) {
    throw new BeanInstantiationException(clazz,""Is it an abstract class?"",ex);
  }
catch (  IllegalAccessException ex) {
    throw new BeanInstantiationException(clazz,""Is the constructor accessible?"",ex);
  }
}
"
"/** 
 * Create a new MethodParameter for the given method or constructor. <p>This is a convenience factory method for scenarios where a Method or Constructor reference is treated in a generic fashion.
 * @param methodOrConstructor the Method or Constructor to specify a parameter for
 * @param parameterIndex the index of the parameter
 * @return the corresponding MethodParameter instance
 * @deprecated as of 5.0, in favor of {@link #forExecutable}
 */
@Deprecated public static MethodParameter forMethodOrConstructor(Object methodOrConstructor,int parameterIndex){
  if (!(methodOrConstructor instanceof Executable)) {
    throw new IllegalArgumentException(""Given object ["" + methodOrConstructor + ""] is neither a Method nor a Constructor"");
  }
  return forExecutable((Executable)methodOrConstructor,parameterIndex);
}
"
"/** 
 * Convenience method to instantiate a class using its no-arg constructor.
 * @param clazz class to instantiate
 * @return the new instance
 * @throws BeanInstantiationException if the bean cannot be instantiated
 * @deprecated as of Spring 5.0, following the deprecation of{@link Class#newInstance()} in JDK 9
 * @see Class#newInstance()
 */
@Deprecated public static <T>T instantiate(Class<T> clazz) throws BeanInstantiationException {
  Assert.notNull(clazz,""Class must not be null"");
  if (clazz.isInterface()) {
    throw new BeanInstantiationException(clazz,""Specified class is an interface"");
  }
  try {
    return clazz.newInstance();
  }
 catch (  InstantiationException ex) {
    throw new BeanInstantiationException(clazz,""Is it an abstract class?"",ex);
  }
catch (  IllegalAccessException ex) {
    throw new BeanInstantiationException(clazz,""Is the constructor accessible?"",ex);
  }
}
"
"/** 
 * Set whether to use the HTTP 1.0 expires header. Default is ""false"", as of 4.2. <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseExpiresHeader(boolean useExpiresHeader){
  this.useExpiresHeader=useExpiresHeader;
}
"
"/** 
 * Return whether the HTTP 1.0 expires header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseExpiresHeader(){
  return this.useExpiresHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header. Default is ""true"". <p>Note: Cache headers will only get applied if caching is enabled (or explicitly prevented) for the current request.
 * @deprecated as of 4.2, since going forward, the HTTP 1.1 cache-controlheader will be required, with the HTTP 1.0 headers disappearing
 */
@Deprecated public final void setUseCacheControlHeader(boolean useCacheControlHeader){
  this.useCacheControlHeader=useCacheControlHeader;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlHeader(){
  return this.useCacheControlHeader;
}
"
"/** 
 * Set whether to use the HTTP 1.1 cache-control header value ""no-store"" when preventing caching. Default is ""true"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setUseCacheControlNoStore(boolean useCacheControlNoStore){
  this.useCacheControlNoStore=useCacheControlNoStore;
}
"
"/** 
 * Return whether the HTTP 1.1 cache-control header value ""no-store"" is used.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isUseCacheControlNoStore(){
  return this.useCacheControlNoStore;
}
"
"/** 
 * An option to add 'must-revalidate' to every Cache-Control header. This may be useful with annotated controller methods, which can programmatically do a last-modified calculation as described in {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}. <p>Default is ""false"".
 * @deprecated as of 4.2, in favor of {@link #setCacheControl}
 */
@Deprecated public final void setAlwaysMustRevalidate(boolean mustRevalidate){
  this.alwaysMustRevalidate=mustRevalidate;
}
"
"/** 
 * Return whether 'must-revalidate' is added to every Cache-Control header.
 * @deprecated as of 4.2, in favor of {@link #getCacheControl()}
 */
@Deprecated public final boolean isAlwaysMustRevalidate(){
  return this.alwaysMustRevalidate;
}
"
"/** 
 * Deprecated constructor with a TaskScheduler.
 * @deprecated as of 5.0 a TaskScheduler is not provided upfront, not untilit is obvious that it is needed, see  {@link #getSockJsServiceRegistration()}.
 */
@Deprecated public AbstractWebSocketHandlerRegistration(TaskScheduler defaultTaskScheduler){
  this.scheduler=defaultTaskScheduler;
}
"
"/** 
 * Deprecated constructor with a TaskScheduler for SockJS use.
 * @deprecated as of 5.0 a TaskScheduler is not provided upfront, not untilit is obvious that it is needed, see  {@link #requiresTaskScheduler()} and{@link #setTaskScheduler}.
 */
@Deprecated public ServletWebSocketHandlerRegistry(ThreadPoolTaskScheduler scheduler){
  this.scheduler=scheduler;
}
"
"/** 
 * Construct a new TypeMismatchNamingException.
 * @param explanation the explanation text
 * @deprecated as of Spring Framework 4.3.10
 */
@Deprecated public TypeMismatchNamingException(String explanation){
  super(explanation);
}
"
"/** 
 * Set the (new) value of the  {@code Content-Disposition} headerfor  {@code form-data}, optionally encoding the filename using the RFC 5987. <p>Only the US-ASCII, UTF-8 and ISO-8859-1 charsets are supported.
 * @param name the control name
 * @param filename the filename (may be {@code null})
 * @param charset the charset used for the filename (may be {@code null})
 * @deprecated deprecated in 4.3.11 and removed from 5.0; as per<a link=""https://tools.ietf.org/html/rfc7578#section-4.2"">RFC 7578, Section 4.2</a>, an RFC 5987 style encoding should not be used for multipart/form-data requests. Furthermore there should be no reason for applications to set this header explicitly; for more details also read {@link #setContentDispositionFormData(String,String)}
 */
@Deprecated public void setContentDispositionFormData(String name,String filename,Charset charset){
  Assert.notNull(name,""'name' must not be null"");
  StringBuilder builder=new StringBuilder(""form-data; name=\"""");
  builder.append(name).append('\""');
  if (filename != null) {
    if (charset == null || charset.name().equals(""US-ASCII"")) {
      builder.append(""; filename=\"""");
      builder.append(filename).append('\""');
    }
 else {
      builder.append(""; filename*="");
      builder.append(encodeHeaderFieldParam(filename,charset));
    }
  }
  set(CONTENT_DISPOSITION,builder.toString());
}
"
"/** 
 * Return a builder for a  {@code MockRestServiceServer} that should be usedto reply to the given  {@code AsyncRestTemplate}.
 * @since 4.3
 * @deprecated see deprecation notice on{@link org.springframework.web.client.AsyncRestTemplate} itself
 */
@Deprecated public static MockRestServiceServerBuilder bindTo(org.springframework.web.client.AsyncRestTemplate asyncRestTemplate){
  return new DefaultBuilder(asyncRestTemplate);
}
"
"/** 
 * A shortcut for  {@code bindTo(asyncRestTemplate).build()}.
 * @param asyncRestTemplate the AsyncRestTemplate to set up for mock testing
 * @return the created mock server
 * @deprecated see deprecation notice on{@link org.springframework.web.client.AsyncRestTemplate} itself
 */
@Deprecated public static MockRestServiceServer createServer(org.springframework.web.client.AsyncRestTemplate asyncRestTemplate){
  return bindTo(asyncRestTemplate).build();
}
"
"/** 
 * Convenience method to instantiate a class using its no-arg constructor.
 * @param clazz class to instantiate
 * @return the new instance
 * @throws BeanInstantiationException if the bean cannot be instantiated
 * @deprecated as of Spring 5.0, following the deprecation of{@link Class#newInstance()} in JDK 9
 * @see Class#newInstance()
 */
@Deprecated public static <T>T instantiate(Class<T> clazz) throws BeanInstantiationException {
  Assert.notNull(clazz,""Class must not be null"");
  if (clazz.isInterface()) {
    throw new BeanInstantiationException(clazz,""Specified class is an interface"");
  }
  try {
    return clazz.newInstance();
  }
 catch (  InstantiationException ex) {
    throw new BeanInstantiationException(clazz,""Is it an abstract class?"",ex);
  }
catch (  IllegalAccessException ex) {
    throw new BeanInstantiationException(clazz,""Is the constructor accessible?"",ex);
  }
}
"
"/** 
 * Callback for destruction of this instance, originally attached to a  {@code DisposableBean} implementation (not anymore in 5.0).<p>The  {@link #close()} method is the native way to shut downan ApplicationContext, which this method simply delegates to.
 * @deprecated as of Spring Framework 5.0, in favor of {@link #close()}
 */
@Deprecated public void destroy(){
  close();
}
"
"/** 
 * Convenience method to instantiate a class using its no-arg constructor.
 * @param clazz class to instantiate
 * @return the new instance
 * @throws BeanInstantiationException if the bean cannot be instantiated
 * @deprecated as of Spring 5.0, following the deprecation of{@link Class#newInstance()} in JDK 9
 * @see Class#newInstance()
 */
@Deprecated public static <T>T instantiate(Class<T> clazz) throws BeanInstantiationException {
  Assert.notNull(clazz,""Class must not be null"");
  if (clazz.isInterface()) {
    throw new BeanInstantiationException(clazz,""Specified class is an interface"");
  }
  try {
    return clazz.newInstance();
  }
 catch (  InstantiationException ex) {
    throw new BeanInstantiationException(clazz,""Is it an abstract class?"",ex);
  }
catch (  IllegalAccessException ex) {
    throw new BeanInstantiationException(clazz,""Is the constructor accessible?"",ex);
  }
}
"
"/** 
 * Create a new MethodParameter for the given method or constructor. <p>This is a convenience factory method for scenarios where a Method or Constructor reference is treated in a generic fashion.
 * @param methodOrConstructor the Method or Constructor to specify a parameter for
 * @param parameterIndex the index of the parameter
 * @return the corresponding MethodParameter instance
 * @deprecated as of 5.0, in favor of {@link #forExecutable}
 */
@Deprecated public static MethodParameter forMethodOrConstructor(Object methodOrConstructor,int parameterIndex){
  if (!(methodOrConstructor instanceof Executable)) {
    throw new IllegalArgumentException(""Given object ["" + methodOrConstructor + ""] is neither a Method nor a Constructor"");
  }
  return forExecutable((Executable)methodOrConstructor,parameterIndex);
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #setUseRegisteredExtensionsOnly(boolean)}, which has reverse behavior.
 */
@Deprecated public void setUseJaf(boolean useJaf){
  setUseRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #setUseRegisteredExtensionsOnly(boolean)}.
 */
@Deprecated public void setUseJaf(boolean useJaf){
  setUseRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * Convenience method to instantiate a class using its no-arg constructor.
 * @param clazz class to instantiate
 * @return the new instance
 * @throws BeanInstantiationException if the bean cannot be instantiated
 * @deprecated as of Spring 5.0, following the deprecation of{@link Class#newInstance()} in JDK 9
 * @see Class#newInstance()
 */
@Deprecated public static <T>T instantiate(Class<T> clazz) throws BeanInstantiationException {
  Assert.notNull(clazz,""Class must not be null"");
  if (clazz.isInterface()) {
    throw new BeanInstantiationException(clazz,""Specified class is an interface"");
  }
  try {
    return clazz.newInstance();
  }
 catch (  InstantiationException ex) {
    throw new BeanInstantiationException(clazz,""Is it an abstract class?"",ex);
  }
catch (  IllegalAccessException ex) {
    throw new BeanInstantiationException(clazz,""Is the constructor accessible?"",ex);
  }
}
"
"/** 
 * Create a new MethodParameter for the given method or constructor. <p>This is a convenience factory method for scenarios where a Method or Constructor reference is treated in a generic fashion.
 * @param methodOrConstructor the Method or Constructor to specify a parameter for
 * @param parameterIndex the index of the parameter
 * @return the corresponding MethodParameter instance
 * @deprecated as of 5.0, in favor of {@link #forExecutable}
 */
@Deprecated public static MethodParameter forMethodOrConstructor(Object methodOrConstructor,int parameterIndex){
  if (!(methodOrConstructor instanceof Executable)) {
    throw new IllegalArgumentException(""Given object ["" + methodOrConstructor + ""] is neither a Method nor a Constructor"");
  }
  return forExecutable((Executable)methodOrConstructor,parameterIndex);
}
"
"/** 
 * This method only exists for compatibility with unusual Commons Logging API usage like e.g.  {@code LogFactory.getFactory().getInstance(Class/String)}.
 * @see #getInstance(Class)
 * @see #getInstance(String)
 * @deprecated in favor of {@link #getLog(Class)}/ {@link #getLog(String)}
 */
@Deprecated public static LogFactory getFactory(){
  return new LogFactory(){
  }
;
}
"
"/** 
 * Convenience method to return a named logger. <p>This variant just dispatches straight to  {@link #getLog(Class)}.
 * @param clazz containing Class from which a log name will be derived
 * @deprecated in favor of {@link #getLog(Class)}
 */
@Deprecated public Log getInstance(Class<?> clazz){
  return getLog(clazz);
}
"
"/** 
 * Convenience method to return a named logger. <p>This variant just dispatches straight to  {@link #getLog(String)}.
 * @param name logical name of the <code>Log</code> instance to be returned
 * @deprecated in favor of {@link #getLog(String)}
 */
@Deprecated public Log getInstance(String name){
  return getLog(name);
}
"
"/** 
 * Return the same value as  {@link Boolean#hashCode(boolean)}}.
 * @deprecated as of Spring Framework 5.0, in favor of the native JDK 8 variant
 */
@Deprecated public static int hashCode(boolean bool){
  return Boolean.hashCode(bool);
}
"
"/** 
 * Return the same value as  {@link Double#hashCode(double)}}.
 * @deprecated as of Spring Framework 5.0, in favor of the native JDK 8 variant
 */
@Deprecated public static int hashCode(double dbl){
  return Double.hashCode(dbl);
}
"
"/** 
 * Return the same value as  {@link Float#hashCode(float)}}.
 * @deprecated as of Spring Framework 5.0, in favor of the native JDK 8 variant
 */
@Deprecated public static int hashCode(float flt){
  return Float.hashCode(flt);
}
"
"/** 
 * Return the same value as  {@link Long#hashCode(long)}}.
 * @deprecated as of Spring Framework 5.0, in favor of the native JDK 8 variant
 */
@Deprecated public static int hashCode(long lng){
  return Long.hashCode(lng);
}
"
"/** 
 * @deprecated as of 4.3.12, in favor of {@link #interceptors(ChannelInterceptor)}
 */
@Deprecated public ChannelRegistration setInterceptors(ChannelInterceptor... interceptors){
  return interceptors(interceptors);
}
"
"/** 
 * Adds a handle to the constant pool of the class being build. Does nothing if the constant pool already contains a similar item. <i>This method is intended for  {@link Attribute} sub classes, and is normally not needed byclass generators or adapters.</i>
 * @param tag the kind of this handle. Must be  {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC},  {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC},  {@link Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link Opcodes#H_NEWINVOKESPECIAL} or{@link Opcodes#H_INVOKEINTERFACE}.
 * @param owner the internal name of the field or method owner class.
 * @param name the name of the field or method.
 * @param desc the descriptor of the field or method.
 * @return the index of a new or already existing method type referenceitem.
 * @deprecated this method is superseded by{@link #newHandle(int,String,String,String,boolean)}.
 */
@Deprecated public int newHandle(final int tag,final String owner,final String name,final String desc){
  return newHandle(tag,owner,name,desc,tag == Opcodes.H_INVOKEINTERFACE);
}
"
"/** 
 * Convenience method to instantiate a class using its no-arg constructor.
 * @param clazz class to instantiate
 * @return the new instance
 * @throws BeanInstantiationException if the bean cannot be instantiated
 * @deprecated as of Spring 5.0, following the deprecation of{@link Class#newInstance()} in JDK 9
 * @see Class#newInstance()
 */
@Deprecated public static <T>T instantiate(Class<T> clazz) throws BeanInstantiationException {
  Assert.notNull(clazz,""Class must not be null"");
  if (clazz.isInterface()) {
    throw new BeanInstantiationException(clazz,""Specified class is an interface"");
  }
  try {
    return clazz.newInstance();
  }
 catch (  InstantiationException ex) {
    throw new BeanInstantiationException(clazz,""Is it an abstract class?"",ex);
  }
catch (  IllegalAccessException ex) {
    throw new BeanInstantiationException(clazz,""Is the constructor accessible?"",ex);
  }
}
"
"/** 
 * Configure interceptors for the message channel.
 * @deprecated as of 4.3.12, in favor of {@link #interceptors(ChannelInterceptor)}
 */
@Deprecated public ChannelRegistration setInterceptors(ChannelInterceptor... interceptors){
  if (interceptors != null) {
    this.interceptors.addAll(Arrays.asList(interceptors));
  }
  return this;
}
"
"/** 
 * Convenience method to instantiate a class using its no-arg constructor.
 * @param clazz class to instantiate
 * @return the new instance
 * @throws BeanInstantiationException if the bean cannot be instantiated
 * @deprecated as of Spring 5.0, following the deprecation of{@link Class#newInstance()} in JDK 9
 * @see Class#newInstance()
 */
@Deprecated public static <T>T instantiate(Class<T> clazz) throws BeanInstantiationException {
  Assert.notNull(clazz,""Class must not be null"");
  if (clazz.isInterface()) {
    throw new BeanInstantiationException(clazz,""Specified class is an interface"");
  }
  try {
    return clazz.newInstance();
  }
 catch (  InstantiationException ex) {
    throw new BeanInstantiationException(clazz,""Is it an abstract class?"",ex);
  }
catch (  IllegalAccessException ex) {
    throw new BeanInstantiationException(clazz,""Is the constructor accessible?"",ex);
  }
}
"
"/** 
 * @deprecated as of 4.3, in favor of {@link #setBeanFactory}
 */
@Deprecated public void setApplicationContext(ApplicationContext applicationContext){
  this.beanFactory=applicationContext;
}
"
"/** 
 * Configure interceptors for the message channel.
 * @deprecated as of 4.3.12, in favor of {@link #interceptors(ChannelInterceptor)}
 */
@Deprecated public ChannelRegistration setInterceptors(@Nullable ChannelInterceptor... interceptors){
  if (interceptors != null) {
    this.interceptors.addAll(Arrays.asList(interceptors));
  }
  return this;
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName){
  return getMergedAnnotationAttributes(element,annotationName);
}
"
"/** 
 * @deprecated As of Spring Framework 4.2, use {@link #getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)} instead.
 */
@Deprecated public static AnnotationAttributes getAnnotationAttributes(AnnotatedElement element,String annotationName,boolean classValuesAsString,boolean nestedAnnotationsAsMap){
  return getMergedAnnotationAttributes(element,annotationName,classValuesAsString,nestedAnnotationsAsMap);
}
"
"/** 
 * Find the first annotation of the specified  {@code annotationName} withinthe annotation hierarchy <em>above</em> the supplied  {@code element}, merge that annotation's attributes with <em>matching</em> attributes from annotations in lower levels of the annotation hierarchy, and synthesize the result back into an annotation of the specified  {@code annotationName}. <p> {@link AliasFor @AliasFor} semantics are fully supported, bothwithin a single annotation and within the annotation hierarchy. <p>This method delegates to  {@link #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)}(supplying  {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}) and  {@link AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)}. <p>This method follows <em>find semantics</em> as described in the {@linkplain AnnotatedElementUtils class-level javadoc}.
 * @param element the annotated element
 * @param annotationName the fully qualified class name of the annotation type to find
 * @return the merged, synthesized {@code Annotation}, or  {@code null} if not found
 * @since 4.2
 * @see #findMergedAnnotation(AnnotatedElement,Class)
 * @see #findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)
 * @see AnnotationUtils#synthesizeAnnotation(Map,Class,AnnotatedElement)
 * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement,Class)} instead.
 */
@Deprecated @SuppressWarnings(""unchecked"") public static <A extends Annotation>A findMergedAnnotation(AnnotatedElement element,String annotationName){
  AnnotationAttributes attributes=findMergedAnnotationAttributes(element,annotationName,false,false);
  return AnnotationUtils.synthesizeAnnotation(attributes,(Class<A>)attributes.annotationType(),element);
}
"
"/** 
 * Get the value stored under the specified  {@code attributeName} as astring, taking into account alias semantics defined via {@link AliasFor @AliasFor}. <p>If there is no value stored under the specified  {@code attributeName}but the attribute has an alias declared via  {@code @AliasFor}, the value of the alias will be returned.
 * @param attributeName the name of the attribute to get; never{@code null} or empty
 * @param annotationType the type of annotation represented by this{@code AnnotationAttributes} instance; never {@code null}
 * @param annotationSource the source of the annotation represented bythis  {@code AnnotationAttributes} (e.g., the {@link AnnotatedElement}); or  {@code null} if unknown
 * @return the string value
 * @throws IllegalArgumentException if the attribute and its alias donot exist or are not of type  {@code String}
 * @throws AnnotationConfigurationException if the attribute and itsalias are both present with different non-empty values
 * @since 4.2
 * @deprecated as of Spring 4.3.2, in favor of built-in alias resolutionin  {@link #getString} itself
 */
@Deprecated public String getAliasedString(String attributeName,Class<? extends Annotation> annotationType,Object annotationSource){
  return getRequiredAttributeWithAlias(attributeName,annotationType,annotationSource,String.class);
}
"
"/** 
 * Get the value stored under the specified  {@code attributeName} as anarray of strings, taking into account alias semantics defined via {@link AliasFor @AliasFor}. <p>If there is no value stored under the specified  {@code attributeName}but the attribute has an alias declared via  {@code @AliasFor}, the value of the alias will be returned.
 * @param attributeName the name of the attribute to get; never{@code null} or empty
 * @param annotationType the type of annotation represented by this{@code AnnotationAttributes} instance; never {@code null}
 * @param annotationSource the source of the annotation represented bythis  {@code AnnotationAttributes} (e.g., the {@link AnnotatedElement}); or  {@code null} if unknown
 * @return the array of strings
 * @throws IllegalArgumentException if the attribute and its alias donot exist or are not of type  {@code String[]}
 * @throws AnnotationConfigurationException if the attribute and itsalias are both present with different non-empty values
 * @since 4.2
 * @deprecated as of Spring 4.3.2, in favor of built-in alias resolutionin  {@link #getStringArray} itself
 */
@Deprecated public String[] getAliasedStringArray(String attributeName,Class<? extends Annotation> annotationType,Object annotationSource){
  return getRequiredAttributeWithAlias(attributeName,annotationType,annotationSource,String[].class);
}
"
"/** 
 * Get the value stored under the specified  {@code attributeName} as anarray of classes, taking into account alias semantics defined via {@link AliasFor @AliasFor}. <p>If there is no value stored under the specified  {@code attributeName}but the attribute has an alias declared via  {@code @AliasFor}, the value of the alias will be returned.
 * @param attributeName the name of the attribute to get; never{@code null} or empty
 * @param annotationType the type of annotation represented by this{@code AnnotationAttributes} instance; never {@code null}
 * @param annotationSource the source of the annotation represented bythis  {@code AnnotationAttributes} (e.g., the {@link AnnotatedElement}); or  {@code null} if unknown
 * @return the array of classes
 * @throws IllegalArgumentException if the attribute and its alias donot exist or are not of type  {@code Class[]}
 * @throws AnnotationConfigurationException if the attribute and itsalias are both present with different non-empty values
 * @since 4.2
 * @deprecated as of Spring 4.3.2, in favor of built-in alias resolutionin  {@link #getClassArray} itself
 */
@Deprecated public Class<?>[] getAliasedClassArray(String attributeName,Class<? extends Annotation> annotationType,Object annotationSource){
  return getRequiredAttributeWithAlias(attributeName,annotationType,annotationSource,Class[].class);
}
"
"/** 
 * Create a new instance that assumes the context path of the application is  {@code """"} (i.e., the root context).<p>For example, the URL  {@code http://localhost/test/this} would use{@code """"} as the context path.
 * @param mockMvc the {@code MockMvc} instance to use; never {@code null}
 * @deprecated Use {@link #MockMvcWebConnection(MockMvc,WebClient)}
 */
@Deprecated public MockMvcWebConnection(MockMvc mockMvc){
  this(mockMvc,"""");
}
"
"/** 
 * Create a new instance with the specified context path. <p>The path may be  {@code null} in which case the first path segmentof the URL is turned into the contextPath. Otherwise it must conform to  {@link javax.servlet.http.HttpServletRequest#getContextPath()}which states that it can be an empty string and otherwise must start with a ""/"" character and not end with a ""/"" character.
 * @param mockMvc the {@code MockMvc} instance to use; never {@code null}
 * @param contextPath the contextPath to use
 * @deprecated use {@link #MockMvcWebConnection(MockMvc,WebClient,String)}
 */
@Deprecated public MockMvcWebConnection(MockMvc mockMvc,String contextPath){
  this(mockMvc,new WebClient(),contextPath);
}
"
"/** 
 * Register Velocity view resolver with an empty default view name prefix and a default suffix of "".vm"". <p><strong>Note</strong> that you must also configure Velocity by adding a {@link org.springframework.web.servlet.view.velocity.VelocityConfigurer} bean.
 * @deprecated as of Spring 4.3, in favor of FreeMarker
 */
@Deprecated public UrlBasedViewResolverRegistration velocity(){
  if (this.applicationContext != null && !hasBeanOfType(org.springframework.web.servlet.view.velocity.VelocityConfigurer.class)) {
    throw new BeanInitializationException(""In addition to a Velocity view resolver "" + ""there must also be a single VelocityConfig bean in this web application context "" + ""(or its parent): VelocityConfigurer is the usual implementation. ""+ ""This bean may be given any name."");
  }
  VelocityRegistration registration=new VelocityRegistration();
  this.viewResolvers.add(registration.getViewResolver());
  return registration;
}
"
"/** 
 * @deprecated as of Spring 4.2.8, in favor of {@link #setUrlPathHelper}
 */
@Deprecated public void setPathHelper(UrlPathHelper pathHelper){
  this.urlPathHelper=pathHelper;
}
"
"/** 
 * Determine the generic element type of the wrapped Collection parameter/field, if any.
 * @return the generic type, or {@code null} if none
 * @deprecated as of 4.3.6, in favor of direct {@link ResolvableType} usage
 */
@Deprecated public Class<?> getCollectionType(){
  return (this.field != null ? org.springframework.core.GenericCollectionTypeResolver.getCollectionFieldType(this.field,this.nestingLevel) : org.springframework.core.GenericCollectionTypeResolver.getCollectionParameterType(this.methodParameter));
}
"
"/** 
 * Determine the generic key type of the wrapped Map parameter/field, if any.
 * @return the generic type, or {@code null} if none
 * @deprecated as of 4.3.6, in favor of direct {@link ResolvableType} usage
 */
@Deprecated public Class<?> getMapKeyType(){
  return (this.field != null ? org.springframework.core.GenericCollectionTypeResolver.getMapKeyFieldType(this.field,this.nestingLevel) : org.springframework.core.GenericCollectionTypeResolver.getMapKeyParameterType(this.methodParameter));
}
"
"/** 
 * Determine the generic value type of the wrapped Map parameter/field, if any.
 * @return the generic type, or {@code null} if none
 * @deprecated as of 4.3.6, in favor of direct {@link ResolvableType} usage
 */
@Deprecated public Class<?> getMapValueType(){
  return (this.field != null ? org.springframework.core.GenericCollectionTypeResolver.getMapValueFieldType(this.field,this.nestingLevel) : org.springframework.core.GenericCollectionTypeResolver.getMapValueParameterType(this.methodParameter));
}
"
"/** 
 * Get the  {@link Environment} associated with this helper instance.
 * @deprecated in favor of {@link XmlReaderContext#getEnvironment()}
 */
@Deprecated public final Environment getEnvironment(){
  return this.readerContext.getEnvironment();
}
"
"/** 
 * Set the (new) value of the  {@code Content-Disposition} headerfor  {@code form-data}, optionally encoding the filename using the RFC 5987. <p>Only the US-ASCII, UTF-8 and ISO-8859-1 charsets are supported.
 * @param name the control name
 * @param filename the filename (may be {@code null})
 * @param charset the charset used for the filename (may be {@code null})
 * @deprecated deprecated in 4.3.11 and removed from 5.0; as per<a link=""https://tools.ietf.org/html/rfc7578#section-4.2"">RFC 7578, Section 4.2</a>, an RFC 5987 style encoding should not be used for multipart/form-data requests. Furthermore there should be no reason for applications to set this header explicitly; for more details also read {@link #setContentDispositionFormData(String,String)}
 */
@Deprecated public void setContentDispositionFormData(String name,String filename,Charset charset){
  Assert.notNull(name,""'name' must not be null"");
  StringBuilder builder=new StringBuilder(""form-data; name=\"""");
  builder.append(name).append('\""');
  if (filename != null) {
    if (charset == null || charset.name().equals(""US-ASCII"")) {
      builder.append(""; filename=\"""");
      builder.append(filename).append('\""');
    }
 else {
      builder.append(""; filename*="");
      builder.append(encodeHeaderFieldParam(filename,charset));
    }
  }
  set(CONTENT_DISPOSITION,builder.toString());
}
"
"/** 
 * Return whether default HTML escaping is enabled for the web application, i.e. the value of the ""defaultHtmlEscape"" context-param in  {@code web.xml}(if any). Falls back to  {@code false} in case of no explicit default given.
 * @param servletContext the servlet context of the web application
 * @return whether default HTML escaping is enabled (default is {@code false})
 * @deprecated as of Spring 4.1, in favor of {@link #getDefaultHtmlEscape}
 */
@Deprecated public static boolean isDefaultHtmlEscape(ServletContext servletContext){
  if (servletContext == null) {
    return false;
  }
  String param=servletContext.getInitParameter(HTML_ESCAPE_CONTEXT_PARAM);
  return Boolean.valueOf(param);
}
"
"/** 
 * Get the specified session attribute, creating and setting a new attribute if no existing found. The given class needs to have a public no-arg constructor. Useful for on-demand state objects in a web tier, like shopping carts.
 * @param session current HTTP session
 * @param name the name of the session attribute
 * @param clazz the class to instantiate for a new attribute
 * @return the value of the session attribute, newly created if not found
 * @throws IllegalArgumentException if the session attribute could not be instantiated
 * @deprecated as of Spring 4.3.2, in favor of custom code for such purposes
 */
@Deprecated public static Object getOrCreateSessionAttribute(HttpSession session,String name,Class<?> clazz) throws IllegalArgumentException {
  Assert.notNull(session,""Session must not be null"");
  Object sessionObject=session.getAttribute(name);
  if (sessionObject == null) {
    try {
      sessionObject=clazz.newInstance();
    }
 catch (    InstantiationException ex) {
      throw new IllegalArgumentException(""Could not instantiate class ["" + clazz.getName() + ""] for session attribute '""+ name+ ""': ""+ ex.getMessage());
    }
catch (    IllegalAccessException ex) {
      throw new IllegalArgumentException(""Could not access default constructor of class ["" + clazz.getName() + ""] for session attribute '""+ name+ ""': ""+ ex.getMessage());
    }
    session.setAttribute(name,sessionObject);
  }
  return sessionObject;
}
"
"/** 
 * Expose the given Map as request attributes, using the keys as attribute names and the values as corresponding attribute values. Keys need to be Strings.
 * @param request current HTTP request
 * @param attributes the attributes Map
 * @deprecated as of Spring 4.3.2, in favor of custom code for such purposes
 */
@Deprecated public static void exposeRequestAttributes(ServletRequest request,Map<String,?> attributes){
  Assert.notNull(request,""Request must not be null"");
  Assert.notNull(attributes,""Attributes Map must not be null"");
  for (  Map.Entry<String,?> entry : attributes.entrySet()) {
    request.setAttribute(entry.getKey(),entry.getValue());
  }
}
"
"/** 
 * Return the target page specified in the request.
 * @param request current servlet request
 * @param paramPrefix the parameter prefix to check for(e.g. ""_target"" for parameters like ""_target1"" or ""_target2"")
 * @param currentPage the current page, to be returned as fallbackif no target page specified
 * @return the page specified in the request, or current page if not found
 * @deprecated as of Spring 4.3.2, in favor of custom code for such purposes
 */
@Deprecated public static int getTargetPage(ServletRequest request,String paramPrefix,int currentPage){
  Enumeration<String> paramNames=request.getParameterNames();
  while (paramNames.hasMoreElements()) {
    String paramName=paramNames.nextElement();
    if (paramName.startsWith(paramPrefix)) {
      for (int i=0; i < WebUtils.SUBMIT_IMAGE_SUFFIXES.length; i++) {
        String suffix=WebUtils.SUBMIT_IMAGE_SUFFIXES[i];
        if (paramName.endsWith(suffix)) {
          paramName=paramName.substring(0,paramName.length() - suffix.length());
        }
      }
      return Integer.parseInt(paramName.substring(paramPrefix.length()));
    }
  }
  return currentPage;
}
"
"/** 
 * Extract the URL filename from the given request URL path. Correctly resolves nested paths such as ""/products/view.html"" as well.
 * @param urlPath the request URL path (e.g. ""/index.html"")
 * @return the extracted URI filename (e.g. ""index"")
 * @deprecated as of Spring 4.3.2, in favor of custom code for such purposes
 */
@Deprecated public static String extractFilenameFromUrlPath(String urlPath){
  String filename=extractFullFilenameFromUrlPath(urlPath);
  int dotIndex=filename.lastIndexOf('.');
  if (dotIndex != -1) {
    filename=filename.substring(0,dotIndex);
  }
  return filename;
}
"
"/** 
 * Extract the full URL filename (including file extension) from the given request URL path. Correctly resolve nested paths such as ""/products/view.html"" and remove any path and or query parameters.
 * @param urlPath the request URL path (e.g. ""/products/index.html"")
 * @return the extracted URI filename (e.g. ""index.html"")
 * @deprecated as of Spring 4.3.2, in favor of custom code for such purposes(or  {@link UriUtils#extractFileExtension} for the file extension use case)
 */
@Deprecated public static String extractFullFilenameFromUrlPath(String urlPath){
  int end=urlPath.indexOf('?');
  if (end == -1) {
    end=urlPath.indexOf('#');
    if (end == -1) {
      end=urlPath.length();
    }
  }
  int begin=urlPath.lastIndexOf('/',end) + 1;
  int paramIndex=urlPath.indexOf(';',begin);
  end=(paramIndex != -1 && paramIndex < end ? paramIndex : end);
  return urlPath.substring(begin,end);
}
"
"/** 
 * Register Velocity view resolver with an empty default view name prefix and a default suffix of "".vm"". <p><strong>Note</strong> that you must also configure Velocity by adding a {@link org.springframework.web.servlet.view.velocity.VelocityConfigurer} bean.
 * @deprecated as of Spring 4.3, in favor of FreeMarker
 */
@Deprecated public UrlBasedViewResolverRegistration velocity(){
  if (!checkBeanOfType(org.springframework.web.servlet.view.velocity.VelocityConfigurer.class)) {
    throw new BeanInitializationException(""In addition to a Velocity view resolver "" + ""there must also be a single VelocityConfig bean in this web application context "" + ""(or its parent): VelocityConfigurer is the usual implementation. ""+ ""This bean may be given any name."");
  }
  VelocityRegistration registration=new VelocityRegistration();
  this.viewResolvers.add(registration.getViewResolver());
  return registration;
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #setUseRegisteredExtensionsOnly(boolean)}, which has reverse behavior.
 */
@Deprecated public void setUseJaf(boolean useJaf){
  setUseRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * @deprecated as of 5.0, in favor of {@link #useRegisteredExtensionsOnly(boolean)}which has reverse behavior
 */
@Deprecated public ContentNegotiationConfigurer useJaf(boolean useJaf){
  return this.useRegisteredExtensionsOnly(!useJaf);
}
"
"/** 
 * @deprecated as of Spring 4.2.8, in favor of {@link #setUrlPathHelper}
 */
@Deprecated public void setPathHelper(UrlPathHelper pathHelper){
  this.urlPathHelper=pathHelper;
}
"
"/** 
 * Convenience method to instantiate a class using its no-arg constructor.
 * @param clazz class to instantiate
 * @return the new instance
 * @throws BeanInstantiationException if the bean cannot be instantiated
 * @deprecated as of Spring 5.0, following the deprecation of{@link Class#newInstance()} in JDK 9
 * @see Class#newInstance()
 */
@Deprecated public static <T>T instantiate(Class<T> clazz) throws BeanInstantiationException {
  Assert.notNull(clazz,""Class must not be null"");
  if (clazz.isInterface()) {
    throw new BeanInstantiationException(clazz,""Specified class is an interface"");
  }
  try {
    return clazz.newInstance();
  }
 catch (  InstantiationException ex) {
    throw new BeanInstantiationException(clazz,""Is it an abstract class?"",ex);
  }
catch (  IllegalAccessException ex) {
    throw new BeanInstantiationException(clazz,""Is the constructor accessible?"",ex);
  }
}
"
"/** 
 * Create a new MethodParameter for the given method or constructor. <p>This is a convenience factory method for scenarios where a Method or Constructor reference is treated in a generic fashion.
 * @param methodOrConstructor the Method or Constructor to specify a parameter for
 * @param parameterIndex the index of the parameter
 * @return the corresponding MethodParameter instance
 * @deprecated as of 5.0, in favor of {@link #forExecutable}
 */
@Deprecated public static MethodParameter forMethodOrConstructor(Object methodOrConstructor,int parameterIndex){
  if (!(methodOrConstructor instanceof Executable)) {
    throw new IllegalArgumentException(""Given object ["" + methodOrConstructor + ""] is neither a Method nor a Constructor"");
  }
  return forExecutable((Executable)methodOrConstructor,parameterIndex);
}
"
